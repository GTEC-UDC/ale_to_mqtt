// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: schema.proto

#ifndef PROTOBUF_INCLUDED_schema_2eproto
#define PROTOBUF_INCLUDED_schema_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_schema_2eproto 

namespace protobuf_schema_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[97];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_schema_2eproto
namespace ce {
namespace nbapi {
class access_point;
class access_pointDefaultTypeInternal;
extern access_pointDefaultTypeInternal _access_point_default_instance_;
class air_monitor_info;
class air_monitor_infoDefaultTypeInternal;
extern air_monitor_infoDefaultTypeInternal _air_monitor_info_default_instance_;
class air_monitor_rogue_info;
class air_monitor_rogue_infoDefaultTypeInternal;
extern air_monitor_rogue_infoDefaultTypeInternal _air_monitor_rogue_info_default_instance_;
class ap_location;
class ap_locationDefaultTypeInternal;
extern ap_locationDefaultTypeInternal _ap_location_default_instance_;
class ap_neighbor;
class ap_neighborDefaultTypeInternal;
extern ap_neighborDefaultTypeInternal _ap_neighbor_default_instance_;
class ap_neighbor_list;
class ap_neighbor_listDefaultTypeInternal;
extern ap_neighbor_listDefaultTypeInternal _ap_neighbor_list_default_instance_;
class ap_rssi;
class ap_rssiDefaultTypeInternal;
extern ap_rssiDefaultTypeInternal _ap_rssi_default_instance_;
class application;
class applicationDefaultTypeInternal;
extern applicationDefaultTypeInternal _application_default_instance_;
class auth_srvr_timeout;
class auth_srvr_timeoutDefaultTypeInternal;
extern auth_srvr_timeoutDefaultTypeInternal _auth_srvr_timeout_default_instance_;
class building;
class buildingDefaultTypeInternal;
extern buildingDefaultTypeInternal _building_default_instance_;
class bytes_info;
class bytes_infoDefaultTypeInternal;
extern bytes_infoDefaultTypeInternal _bytes_info_default_instance_;
class campus;
class campusDefaultTypeInternal;
extern campusDefaultTypeInternal _campus_default_instance_;
class captive_portal;
class captive_portalDefaultTypeInternal;
extern captive_portalDefaultTypeInternal _captive_portal_default_instance_;
class cluster_info;
class cluster_infoDefaultTypeInternal;
extern cluster_infoDefaultTypeInternal _cluster_info_default_instance_;
class controller_info;
class controller_infoDefaultTypeInternal;
extern controller_infoDefaultTypeInternal _controller_info_default_instance_;
class data_prio_stats;
class data_prio_statsDefaultTypeInternal;
extern data_prio_statsDefaultTypeInternal _data_prio_stats_default_instance_;
class data_rate_stats;
class data_rate_statsDefaultTypeInternal;
extern data_rate_statsDefaultTypeInternal _data_rate_stats_default_instance_;
class data_traffic_type_stats;
class data_traffic_type_statsDefaultTypeInternal;
extern data_traffic_type_statsDefaultTypeInternal _data_traffic_type_stats_default_instance_;
class destination;
class destinationDefaultTypeInternal;
extern destinationDefaultTypeInternal _destination_default_instance_;
class dot1x;
class dot1xDefaultTypeInternal;
extern dot1xDefaultTypeInternal _dot1x_default_instance_;
class floor;
class floorDefaultTypeInternal;
extern floorDefaultTypeInternal _floor_default_instance_;
class geofence;
class geofenceDefaultTypeInternal;
extern geofenceDefaultTypeInternal _geofence_default_instance_;
class geofence_notify;
class geofence_notifyDefaultTypeInternal;
extern geofence_notifyDefaultTypeInternal _geofence_notify_default_instance_;
class geofence_notify_Access_point_info;
class geofence_notify_Access_point_infoDefaultTypeInternal;
extern geofence_notify_Access_point_infoDefaultTypeInternal _geofence_notify_Access_point_info_default_instance_;
class iap_bytes_info;
class iap_bytes_infoDefaultTypeInternal;
extern iap_bytes_infoDefaultTypeInternal _iap_bytes_info_default_instance_;
class iap_client_url;
class iap_client_urlDefaultTypeInternal;
extern iap_client_urlDefaultTypeInternal _iap_client_url_default_instance_;
class iap_message_info;
class iap_message_infoDefaultTypeInternal;
extern iap_message_infoDefaultTypeInternal _iap_message_info_default_instance_;
class info;
class infoDefaultTypeInternal;
extern infoDefaultTypeInternal _info_default_instance_;
class ip_address;
class ip_addressDefaultTypeInternal;
extern ip_addressDefaultTypeInternal _ip_address_default_instance_;
class key_value_type;
class key_value_typeDefaultTypeInternal;
extern key_value_typeDefaultTypeInternal _key_value_type_default_instance_;
class location;
class locationDefaultTypeInternal;
extern locationDefaultTypeInternal _location_default_instance_;
class location_record;
class location_recordDefaultTypeInternal;
extern location_recordDefaultTypeInternal _location_record_default_instance_;
class location_rtls_tag;
class location_rtls_tagDefaultTypeInternal;
extern location_rtls_tagDefaultTypeInternal _location_rtls_tag_default_instance_;
class mac_address;
class mac_addressDefaultTypeInternal;
extern mac_addressDefaultTypeInternal _mac_address_default_instance_;
class macauth;
class macauthDefaultTypeInternal;
extern macauthDefaultTypeInternal _macauth_default_instance_;
class nb_event;
class nb_eventDefaultTypeInternal;
extern nb_eventDefaultTypeInternal _nb_event_default_instance_;
class point;
class pointDefaultTypeInternal;
extern pointDefaultTypeInternal _point_default_instance_;
class presence;
class presenceDefaultTypeInternal;
extern presenceDefaultTypeInternal _presence_default_instance_;
class proximity;
class proximityDefaultTypeInternal;
extern proximityDefaultTypeInternal _proximity_default_instance_;
class query_response;
class query_responseDefaultTypeInternal;
extern query_responseDefaultTypeInternal _query_response_default_instance_;
class query_response_Access_point_location_result;
class query_response_Access_point_location_resultDefaultTypeInternal;
extern query_response_Access_point_location_resultDefaultTypeInternal _query_response_Access_point_location_result_default_instance_;
class query_response_Access_point_result;
class query_response_Access_point_resultDefaultTypeInternal;
extern query_response_Access_point_resultDefaultTypeInternal _query_response_Access_point_result_default_instance_;
class query_response_Application_result;
class query_response_Application_resultDefaultTypeInternal;
extern query_response_Application_resultDefaultTypeInternal _query_response_Application_result_default_instance_;
class query_response_Building_result;
class query_response_Building_resultDefaultTypeInternal;
extern query_response_Building_resultDefaultTypeInternal _query_response_Building_result_default_instance_;
class query_response_Campus_result;
class query_response_Campus_resultDefaultTypeInternal;
extern query_response_Campus_resultDefaultTypeInternal _query_response_Campus_result_default_instance_;
class query_response_Cluster_result;
class query_response_Cluster_resultDefaultTypeInternal;
extern query_response_Cluster_resultDefaultTypeInternal _query_response_Cluster_result_default_instance_;
class query_response_Controller_result;
class query_response_Controller_resultDefaultTypeInternal;
extern query_response_Controller_resultDefaultTypeInternal _query_response_Controller_result_default_instance_;
class query_response_Destination_result;
class query_response_Destination_resultDefaultTypeInternal;
extern query_response_Destination_resultDefaultTypeInternal _query_response_Destination_result_default_instance_;
class query_response_Floor_result;
class query_response_Floor_resultDefaultTypeInternal;
extern query_response_Floor_resultDefaultTypeInternal _query_response_Floor_result_default_instance_;
class query_response_Geofence_result;
class query_response_Geofence_resultDefaultTypeInternal;
extern query_response_Geofence_resultDefaultTypeInternal _query_response_Geofence_result_default_instance_;
class query_response_Info_result;
class query_response_Info_resultDefaultTypeInternal;
extern query_response_Info_resultDefaultTypeInternal _query_response_Info_result_default_instance_;
class query_response_Location_result;
class query_response_Location_resultDefaultTypeInternal;
extern query_response_Location_resultDefaultTypeInternal _query_response_Location_result_default_instance_;
class query_response_Presence_result;
class query_response_Presence_resultDefaultTypeInternal;
extern query_response_Presence_resultDefaultTypeInternal _query_response_Presence_result_default_instance_;
class query_response_Proximity_result;
class query_response_Proximity_resultDefaultTypeInternal;
extern query_response_Proximity_resultDefaultTypeInternal _query_response_Proximity_result_default_instance_;
class query_response_Radio_result;
class query_response_Radio_resultDefaultTypeInternal;
extern query_response_Radio_resultDefaultTypeInternal _query_response_Radio_result_default_instance_;
class query_response_Rssi_result;
class query_response_Rssi_resultDefaultTypeInternal;
extern query_response_Rssi_resultDefaultTypeInternal _query_response_Rssi_result_default_instance_;
class query_response_Station_result;
class query_response_Station_resultDefaultTypeInternal;
extern query_response_Station_resultDefaultTypeInternal _query_response_Station_result_default_instance_;
class query_response_Topology_result;
class query_response_Topology_resultDefaultTypeInternal;
extern query_response_Topology_resultDefaultTypeInternal _query_response_Topology_result_default_instance_;
class query_response_Virtual_access_point_result;
class query_response_Virtual_access_point_resultDefaultTypeInternal;
extern query_response_Virtual_access_point_resultDefaultTypeInternal _query_response_Virtual_access_point_result_default_instance_;
class query_response_Visibility_rec_result;
class query_response_Visibility_rec_resultDefaultTypeInternal;
extern query_response_Visibility_rec_resultDefaultTypeInternal _query_response_Visibility_rec_result_default_instance_;
class query_response_WebCCCategory_result;
class query_response_WebCCCategory_resultDefaultTypeInternal;
extern query_response_WebCCCategory_resultDefaultTypeInternal _query_response_WebCCCategory_result_default_instance_;
class radio;
class radioDefaultTypeInternal;
extern radioDefaultTypeInternal _radio_default_instance_;
class rogue_info;
class rogue_infoDefaultTypeInternal;
extern rogue_infoDefaultTypeInternal _rogue_info_default_instance_;
class rssi;
class rssiDefaultTypeInternal;
extern rssiDefaultTypeInternal _rssi_default_instance_;
class security_message;
class security_messageDefaultTypeInternal;
extern security_messageDefaultTypeInternal _security_message_default_instance_;
class spectrum_info;
class spectrum_infoDefaultTypeInternal;
extern spectrum_infoDefaultTypeInternal _spectrum_info_default_instance_;
class sta_rssi;
class sta_rssiDefaultTypeInternal;
extern sta_rssiDefaultTypeInternal _sta_rssi_default_instance_;
class state_access_point;
class state_access_pointDefaultTypeInternal;
extern state_access_pointDefaultTypeInternal _state_access_point_default_instance_;
class state_station;
class state_stationDefaultTypeInternal;
extern state_stationDefaultTypeInternal _state_station_default_instance_;
class station;
class stationDefaultTypeInternal;
extern stationDefaultTypeInternal _station_default_instance_;
class stats_ip_probe_uplink;
class stats_ip_probe_uplinkDefaultTypeInternal;
extern stats_ip_probe_uplinkDefaultTypeInternal _stats_ip_probe_uplink_default_instance_;
class stats_modem;
class stats_modemDefaultTypeInternal;
extern stats_modemDefaultTypeInternal _stats_modem_default_instance_;
class stats_port;
class stats_portDefaultTypeInternal;
extern stats_portDefaultTypeInternal _stats_port_default_instance_;
class stats_radio;
class stats_radioDefaultTypeInternal;
extern stats_radioDefaultTypeInternal _stats_radio_default_instance_;
class stats_role_iap;
class stats_role_iapDefaultTypeInternal;
extern stats_role_iapDefaultTypeInternal _stats_role_iap_default_instance_;
class stats_ssid_iap;
class stats_ssid_iapDefaultTypeInternal;
extern stats_ssid_iapDefaultTypeInternal _stats_ssid_iap_default_instance_;
class stats_station;
class stats_stationDefaultTypeInternal;
extern stats_stationDefaultTypeInternal _stats_station_default_instance_;
class stats_tunnel;
class stats_tunnelDefaultTypeInternal;
extern stats_tunnelDefaultTypeInternal _stats_tunnel_default_instance_;
class stats_uplink;
class stats_uplinkDefaultTypeInternal;
extern stats_uplinkDefaultTypeInternal _stats_uplink_default_instance_;
class stats_vap;
class stats_vapDefaultTypeInternal;
extern stats_vapDefaultTypeInternal _stats_vap_default_instance_;
class stats_vlan_iap;
class stats_vlan_iapDefaultTypeInternal;
extern stats_vlan_iapDefaultTypeInternal _stats_vlan_iap_default_instance_;
class summary_appid_iap;
class summary_appid_iapDefaultTypeInternal;
extern summary_appid_iapDefaultTypeInternal _summary_appid_iap_default_instance_;
class summary_webcat_iap;
class summary_webcat_iapDefaultTypeInternal;
extern summary_webcat_iapDefaultTypeInternal _summary_webcat_iap_default_instance_;
class summary_webrep_iap;
class summary_webrep_iapDefaultTypeInternal;
extern summary_webrep_iapDefaultTypeInternal _summary_webrep_iap_default_instance_;
class tag_rssi;
class tag_rssiDefaultTypeInternal;
extern tag_rssiDefaultTypeInternal _tag_rssi_default_instance_;
class topology;
class topologyDefaultTypeInternal;
extern topologyDefaultTypeInternal _topology_default_instance_;
class uplink_bandwidth;
class uplink_bandwidthDefaultTypeInternal;
extern uplink_bandwidthDefaultTypeInternal _uplink_bandwidth_default_instance_;
class uplink_info;
class uplink_infoDefaultTypeInternal;
extern uplink_infoDefaultTypeInternal _uplink_info_default_instance_;
class url_detail_record;
class url_detail_recordDefaultTypeInternal;
extern url_detail_recordDefaultTypeInternal _url_detail_record_default_instance_;
class util_stats;
class util_statsDefaultTypeInternal;
extern util_statsDefaultTypeInternal _util_stats_default_instance_;
class utilization_stats_radio;
class utilization_stats_radioDefaultTypeInternal;
extern utilization_stats_radioDefaultTypeInternal _utilization_stats_radio_default_instance_;
class virtual_access_point;
class virtual_access_pointDefaultTypeInternal;
extern virtual_access_pointDefaultTypeInternal _virtual_access_point_default_instance_;
class visibility_rec;
class visibility_recDefaultTypeInternal;
extern visibility_recDefaultTypeInternal _visibility_rec_default_instance_;
class wan_comp_uplink;
class wan_comp_uplinkDefaultTypeInternal;
extern wan_comp_uplinkDefaultTypeInternal _wan_comp_uplink_default_instance_;
class webcc_category;
class webcc_categoryDefaultTypeInternal;
extern webcc_categoryDefaultTypeInternal _webcc_category_default_instance_;
class webcc_info;
class webcc_infoDefaultTypeInternal;
extern webcc_infoDefaultTypeInternal _webcc_info_default_instance_;
class wpa_key_handshake;
class wpa_key_handshakeDefaultTypeInternal;
extern wpa_key_handshakeDefaultTypeInternal _wpa_key_handshake_default_instance_;
}  // namespace nbapi
}  // namespace ce
namespace google {
namespace protobuf {
template<> ::ce::nbapi::access_point* Arena::CreateMaybeMessage<::ce::nbapi::access_point>(Arena*);
template<> ::ce::nbapi::air_monitor_info* Arena::CreateMaybeMessage<::ce::nbapi::air_monitor_info>(Arena*);
template<> ::ce::nbapi::air_monitor_rogue_info* Arena::CreateMaybeMessage<::ce::nbapi::air_monitor_rogue_info>(Arena*);
template<> ::ce::nbapi::ap_location* Arena::CreateMaybeMessage<::ce::nbapi::ap_location>(Arena*);
template<> ::ce::nbapi::ap_neighbor* Arena::CreateMaybeMessage<::ce::nbapi::ap_neighbor>(Arena*);
template<> ::ce::nbapi::ap_neighbor_list* Arena::CreateMaybeMessage<::ce::nbapi::ap_neighbor_list>(Arena*);
template<> ::ce::nbapi::ap_rssi* Arena::CreateMaybeMessage<::ce::nbapi::ap_rssi>(Arena*);
template<> ::ce::nbapi::application* Arena::CreateMaybeMessage<::ce::nbapi::application>(Arena*);
template<> ::ce::nbapi::auth_srvr_timeout* Arena::CreateMaybeMessage<::ce::nbapi::auth_srvr_timeout>(Arena*);
template<> ::ce::nbapi::building* Arena::CreateMaybeMessage<::ce::nbapi::building>(Arena*);
template<> ::ce::nbapi::bytes_info* Arena::CreateMaybeMessage<::ce::nbapi::bytes_info>(Arena*);
template<> ::ce::nbapi::campus* Arena::CreateMaybeMessage<::ce::nbapi::campus>(Arena*);
template<> ::ce::nbapi::captive_portal* Arena::CreateMaybeMessage<::ce::nbapi::captive_portal>(Arena*);
template<> ::ce::nbapi::cluster_info* Arena::CreateMaybeMessage<::ce::nbapi::cluster_info>(Arena*);
template<> ::ce::nbapi::controller_info* Arena::CreateMaybeMessage<::ce::nbapi::controller_info>(Arena*);
template<> ::ce::nbapi::data_prio_stats* Arena::CreateMaybeMessage<::ce::nbapi::data_prio_stats>(Arena*);
template<> ::ce::nbapi::data_rate_stats* Arena::CreateMaybeMessage<::ce::nbapi::data_rate_stats>(Arena*);
template<> ::ce::nbapi::data_traffic_type_stats* Arena::CreateMaybeMessage<::ce::nbapi::data_traffic_type_stats>(Arena*);
template<> ::ce::nbapi::destination* Arena::CreateMaybeMessage<::ce::nbapi::destination>(Arena*);
template<> ::ce::nbapi::dot1x* Arena::CreateMaybeMessage<::ce::nbapi::dot1x>(Arena*);
template<> ::ce::nbapi::floor* Arena::CreateMaybeMessage<::ce::nbapi::floor>(Arena*);
template<> ::ce::nbapi::geofence* Arena::CreateMaybeMessage<::ce::nbapi::geofence>(Arena*);
template<> ::ce::nbapi::geofence_notify* Arena::CreateMaybeMessage<::ce::nbapi::geofence_notify>(Arena*);
template<> ::ce::nbapi::geofence_notify_Access_point_info* Arena::CreateMaybeMessage<::ce::nbapi::geofence_notify_Access_point_info>(Arena*);
template<> ::ce::nbapi::iap_bytes_info* Arena::CreateMaybeMessage<::ce::nbapi::iap_bytes_info>(Arena*);
template<> ::ce::nbapi::iap_client_url* Arena::CreateMaybeMessage<::ce::nbapi::iap_client_url>(Arena*);
template<> ::ce::nbapi::iap_message_info* Arena::CreateMaybeMessage<::ce::nbapi::iap_message_info>(Arena*);
template<> ::ce::nbapi::info* Arena::CreateMaybeMessage<::ce::nbapi::info>(Arena*);
template<> ::ce::nbapi::ip_address* Arena::CreateMaybeMessage<::ce::nbapi::ip_address>(Arena*);
template<> ::ce::nbapi::key_value_type* Arena::CreateMaybeMessage<::ce::nbapi::key_value_type>(Arena*);
template<> ::ce::nbapi::location* Arena::CreateMaybeMessage<::ce::nbapi::location>(Arena*);
template<> ::ce::nbapi::location_record* Arena::CreateMaybeMessage<::ce::nbapi::location_record>(Arena*);
template<> ::ce::nbapi::location_rtls_tag* Arena::CreateMaybeMessage<::ce::nbapi::location_rtls_tag>(Arena*);
template<> ::ce::nbapi::mac_address* Arena::CreateMaybeMessage<::ce::nbapi::mac_address>(Arena*);
template<> ::ce::nbapi::macauth* Arena::CreateMaybeMessage<::ce::nbapi::macauth>(Arena*);
template<> ::ce::nbapi::nb_event* Arena::CreateMaybeMessage<::ce::nbapi::nb_event>(Arena*);
template<> ::ce::nbapi::point* Arena::CreateMaybeMessage<::ce::nbapi::point>(Arena*);
template<> ::ce::nbapi::presence* Arena::CreateMaybeMessage<::ce::nbapi::presence>(Arena*);
template<> ::ce::nbapi::proximity* Arena::CreateMaybeMessage<::ce::nbapi::proximity>(Arena*);
template<> ::ce::nbapi::query_response* Arena::CreateMaybeMessage<::ce::nbapi::query_response>(Arena*);
template<> ::ce::nbapi::query_response_Access_point_location_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Access_point_location_result>(Arena*);
template<> ::ce::nbapi::query_response_Access_point_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Access_point_result>(Arena*);
template<> ::ce::nbapi::query_response_Application_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Application_result>(Arena*);
template<> ::ce::nbapi::query_response_Building_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Building_result>(Arena*);
template<> ::ce::nbapi::query_response_Campus_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Campus_result>(Arena*);
template<> ::ce::nbapi::query_response_Cluster_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Cluster_result>(Arena*);
template<> ::ce::nbapi::query_response_Controller_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Controller_result>(Arena*);
template<> ::ce::nbapi::query_response_Destination_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Destination_result>(Arena*);
template<> ::ce::nbapi::query_response_Floor_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Floor_result>(Arena*);
template<> ::ce::nbapi::query_response_Geofence_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Geofence_result>(Arena*);
template<> ::ce::nbapi::query_response_Info_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Info_result>(Arena*);
template<> ::ce::nbapi::query_response_Location_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Location_result>(Arena*);
template<> ::ce::nbapi::query_response_Presence_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Presence_result>(Arena*);
template<> ::ce::nbapi::query_response_Proximity_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Proximity_result>(Arena*);
template<> ::ce::nbapi::query_response_Radio_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Radio_result>(Arena*);
template<> ::ce::nbapi::query_response_Rssi_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Rssi_result>(Arena*);
template<> ::ce::nbapi::query_response_Station_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Station_result>(Arena*);
template<> ::ce::nbapi::query_response_Topology_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Topology_result>(Arena*);
template<> ::ce::nbapi::query_response_Virtual_access_point_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Virtual_access_point_result>(Arena*);
template<> ::ce::nbapi::query_response_Visibility_rec_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_Visibility_rec_result>(Arena*);
template<> ::ce::nbapi::query_response_WebCCCategory_result* Arena::CreateMaybeMessage<::ce::nbapi::query_response_WebCCCategory_result>(Arena*);
template<> ::ce::nbapi::radio* Arena::CreateMaybeMessage<::ce::nbapi::radio>(Arena*);
template<> ::ce::nbapi::rogue_info* Arena::CreateMaybeMessage<::ce::nbapi::rogue_info>(Arena*);
template<> ::ce::nbapi::rssi* Arena::CreateMaybeMessage<::ce::nbapi::rssi>(Arena*);
template<> ::ce::nbapi::security_message* Arena::CreateMaybeMessage<::ce::nbapi::security_message>(Arena*);
template<> ::ce::nbapi::spectrum_info* Arena::CreateMaybeMessage<::ce::nbapi::spectrum_info>(Arena*);
template<> ::ce::nbapi::sta_rssi* Arena::CreateMaybeMessage<::ce::nbapi::sta_rssi>(Arena*);
template<> ::ce::nbapi::state_access_point* Arena::CreateMaybeMessage<::ce::nbapi::state_access_point>(Arena*);
template<> ::ce::nbapi::state_station* Arena::CreateMaybeMessage<::ce::nbapi::state_station>(Arena*);
template<> ::ce::nbapi::station* Arena::CreateMaybeMessage<::ce::nbapi::station>(Arena*);
template<> ::ce::nbapi::stats_ip_probe_uplink* Arena::CreateMaybeMessage<::ce::nbapi::stats_ip_probe_uplink>(Arena*);
template<> ::ce::nbapi::stats_modem* Arena::CreateMaybeMessage<::ce::nbapi::stats_modem>(Arena*);
template<> ::ce::nbapi::stats_port* Arena::CreateMaybeMessage<::ce::nbapi::stats_port>(Arena*);
template<> ::ce::nbapi::stats_radio* Arena::CreateMaybeMessage<::ce::nbapi::stats_radio>(Arena*);
template<> ::ce::nbapi::stats_role_iap* Arena::CreateMaybeMessage<::ce::nbapi::stats_role_iap>(Arena*);
template<> ::ce::nbapi::stats_ssid_iap* Arena::CreateMaybeMessage<::ce::nbapi::stats_ssid_iap>(Arena*);
template<> ::ce::nbapi::stats_station* Arena::CreateMaybeMessage<::ce::nbapi::stats_station>(Arena*);
template<> ::ce::nbapi::stats_tunnel* Arena::CreateMaybeMessage<::ce::nbapi::stats_tunnel>(Arena*);
template<> ::ce::nbapi::stats_uplink* Arena::CreateMaybeMessage<::ce::nbapi::stats_uplink>(Arena*);
template<> ::ce::nbapi::stats_vap* Arena::CreateMaybeMessage<::ce::nbapi::stats_vap>(Arena*);
template<> ::ce::nbapi::stats_vlan_iap* Arena::CreateMaybeMessage<::ce::nbapi::stats_vlan_iap>(Arena*);
template<> ::ce::nbapi::summary_appid_iap* Arena::CreateMaybeMessage<::ce::nbapi::summary_appid_iap>(Arena*);
template<> ::ce::nbapi::summary_webcat_iap* Arena::CreateMaybeMessage<::ce::nbapi::summary_webcat_iap>(Arena*);
template<> ::ce::nbapi::summary_webrep_iap* Arena::CreateMaybeMessage<::ce::nbapi::summary_webrep_iap>(Arena*);
template<> ::ce::nbapi::tag_rssi* Arena::CreateMaybeMessage<::ce::nbapi::tag_rssi>(Arena*);
template<> ::ce::nbapi::topology* Arena::CreateMaybeMessage<::ce::nbapi::topology>(Arena*);
template<> ::ce::nbapi::uplink_bandwidth* Arena::CreateMaybeMessage<::ce::nbapi::uplink_bandwidth>(Arena*);
template<> ::ce::nbapi::uplink_info* Arena::CreateMaybeMessage<::ce::nbapi::uplink_info>(Arena*);
template<> ::ce::nbapi::url_detail_record* Arena::CreateMaybeMessage<::ce::nbapi::url_detail_record>(Arena*);
template<> ::ce::nbapi::util_stats* Arena::CreateMaybeMessage<::ce::nbapi::util_stats>(Arena*);
template<> ::ce::nbapi::utilization_stats_radio* Arena::CreateMaybeMessage<::ce::nbapi::utilization_stats_radio>(Arena*);
template<> ::ce::nbapi::virtual_access_point* Arena::CreateMaybeMessage<::ce::nbapi::virtual_access_point>(Arena*);
template<> ::ce::nbapi::visibility_rec* Arena::CreateMaybeMessage<::ce::nbapi::visibility_rec>(Arena*);
template<> ::ce::nbapi::wan_comp_uplink* Arena::CreateMaybeMessage<::ce::nbapi::wan_comp_uplink>(Arena*);
template<> ::ce::nbapi::webcc_category* Arena::CreateMaybeMessage<::ce::nbapi::webcc_category>(Arena*);
template<> ::ce::nbapi::webcc_info* Arena::CreateMaybeMessage<::ce::nbapi::webcc_info>(Arena*);
template<> ::ce::nbapi::wpa_key_handshake* Arena::CreateMaybeMessage<::ce::nbapi::wpa_key_handshake>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ce {
namespace nbapi {

enum ip_address_addr_family {
  ip_address_addr_family_ADDR_FAMILY_UNSPEC = 0,
  ip_address_addr_family_ADDR_FAMILY_INET = 2,
  ip_address_addr_family_ADDR_FAMILY_INET6 = 10
};
bool ip_address_addr_family_IsValid(int value);
const ip_address_addr_family ip_address_addr_family_addr_family_MIN = ip_address_addr_family_ADDR_FAMILY_UNSPEC;
const ip_address_addr_family ip_address_addr_family_addr_family_MAX = ip_address_addr_family_ADDR_FAMILY_INET6;
const int ip_address_addr_family_addr_family_ARRAYSIZE = ip_address_addr_family_addr_family_MAX + 1;

const ::google::protobuf::EnumDescriptor* ip_address_addr_family_descriptor();
inline const ::std::string& ip_address_addr_family_Name(ip_address_addr_family value) {
  return ::google::protobuf::internal::NameOfEnum(
    ip_address_addr_family_descriptor(), value);
}
inline bool ip_address_addr_family_Parse(
    const ::std::string& name, ip_address_addr_family* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ip_address_addr_family>(
    ip_address_addr_family_descriptor(), name, value);
}
enum ap_neighbor_network_type {
  ap_neighbor_network_type_INFRASTRUCTURE = 0,
  ap_neighbor_network_type_ADHOC = 1
};
bool ap_neighbor_network_type_IsValid(int value);
const ap_neighbor_network_type ap_neighbor_network_type_network_type_MIN = ap_neighbor_network_type_INFRASTRUCTURE;
const ap_neighbor_network_type ap_neighbor_network_type_network_type_MAX = ap_neighbor_network_type_ADHOC;
const int ap_neighbor_network_type_network_type_ARRAYSIZE = ap_neighbor_network_type_network_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ap_neighbor_network_type_descriptor();
inline const ::std::string& ap_neighbor_network_type_Name(ap_neighbor_network_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ap_neighbor_network_type_descriptor(), value);
}
inline bool ap_neighbor_network_type_Parse(
    const ::std::string& name, ap_neighbor_network_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ap_neighbor_network_type>(
    ap_neighbor_network_type_descriptor(), name, value);
}
enum util_stats_util_stat_type {
  util_stats_util_stat_type_UTIL_STAT_TYPE_CHANNEL = 0,
  util_stats_util_stat_type_UTIL_STAT_TYPE_CHANNEL_TX = 1,
  util_stats_util_stat_type_UTIL_STAT_TYPE_CHANNEL_RX = 2,
  util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_SWTX = 3,
  util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_BE = 4,
  util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_BK = 5,
  util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_VI = 6,
  util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_VO = 7,
  util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_BCMC = 8,
  util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_ATIM = 9
};
bool util_stats_util_stat_type_IsValid(int value);
const util_stats_util_stat_type util_stats_util_stat_type_util_stat_type_MIN = util_stats_util_stat_type_UTIL_STAT_TYPE_CHANNEL;
const util_stats_util_stat_type util_stats_util_stat_type_util_stat_type_MAX = util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_ATIM;
const int util_stats_util_stat_type_util_stat_type_ARRAYSIZE = util_stats_util_stat_type_util_stat_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* util_stats_util_stat_type_descriptor();
inline const ::std::string& util_stats_util_stat_type_Name(util_stats_util_stat_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    util_stats_util_stat_type_descriptor(), value);
}
inline bool util_stats_util_stat_type_Parse(
    const ::std::string& name, util_stats_util_stat_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<util_stats_util_stat_type>(
    util_stats_util_stat_type_descriptor(), name, value);
}
enum location_algorithm {
  location_algorithm_ALGORITHM_TRIANGULATION = 0,
  location_algorithm_ALGORITHM_AP_PLACEMENT = 1,
  location_algorithm_ALGORITHM_CALIBRATION = 2,
  location_algorithm_ALGORITHM_ESTIMATION = 3,
  location_algorithm_ALGORITHM_LOW_DENSITY = 4
};
bool location_algorithm_IsValid(int value);
const location_algorithm location_algorithm_algorithm_MIN = location_algorithm_ALGORITHM_TRIANGULATION;
const location_algorithm location_algorithm_algorithm_MAX = location_algorithm_ALGORITHM_LOW_DENSITY;
const int location_algorithm_algorithm_ARRAYSIZE = location_algorithm_algorithm_MAX + 1;

const ::google::protobuf::EnumDescriptor* location_algorithm_descriptor();
inline const ::std::string& location_algorithm_Name(location_algorithm value) {
  return ::google::protobuf::internal::NameOfEnum(
    location_algorithm_descriptor(), value);
}
inline bool location_algorithm_Parse(
    const ::std::string& name, location_algorithm* value) {
  return ::google::protobuf::internal::ParseNamedEnum<location_algorithm>(
    location_algorithm_descriptor(), name, value);
}
enum location_error_code {
  location_error_code_ERROR_CODE_NO_ERROR = 0,
  location_error_code_ERROR_CODE_0_RSSI = 1,
  location_error_code_ERROR_CODE_ONLY_1_RSSI = 2,
  location_error_code_ERROR_CODE_ONLY_2_RSSI = 3,
  location_error_code_ERROR_CODE_RSSI_QUALITY = 4,
  location_error_code_ERROR_CODE_RSSI_OLD_TIMESTAMP = 8,
  location_error_code_ERROR_CODE_RSSI_CLOSE_TIMESTAMP = 16,
  location_error_code_ERROR_CODE_LEGACY = 1048575
};
bool location_error_code_IsValid(int value);
const location_error_code location_error_code_error_code_MIN = location_error_code_ERROR_CODE_NO_ERROR;
const location_error_code location_error_code_error_code_MAX = location_error_code_ERROR_CODE_LEGACY;
const int location_error_code_error_code_ARRAYSIZE = location_error_code_error_code_MAX + 1;

const ::google::protobuf::EnumDescriptor* location_error_code_descriptor();
inline const ::std::string& location_error_code_Name(location_error_code value) {
  return ::google::protobuf::internal::NameOfEnum(
    location_error_code_descriptor(), value);
}
inline bool location_error_code_Parse(
    const ::std::string& name, location_error_code* value) {
  return ::google::protobuf::internal::ParseNamedEnum<location_error_code>(
    location_error_code_descriptor(), name, value);
}
enum access_point_deployment_mode {
  access_point_deployment_mode_DEPLOYMENT_MODE_CAMPUS = 0,
  access_point_deployment_mode_DEPLOYMENT_MODE_REMOTE = 1
};
bool access_point_deployment_mode_IsValid(int value);
const access_point_deployment_mode access_point_deployment_mode_deployment_mode_MIN = access_point_deployment_mode_DEPLOYMENT_MODE_CAMPUS;
const access_point_deployment_mode access_point_deployment_mode_deployment_mode_MAX = access_point_deployment_mode_DEPLOYMENT_MODE_REMOTE;
const int access_point_deployment_mode_deployment_mode_ARRAYSIZE = access_point_deployment_mode_deployment_mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* access_point_deployment_mode_descriptor();
inline const ::std::string& access_point_deployment_mode_Name(access_point_deployment_mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    access_point_deployment_mode_descriptor(), value);
}
inline bool access_point_deployment_mode_Parse(
    const ::std::string& name, access_point_deployment_mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<access_point_deployment_mode>(
    access_point_deployment_mode_descriptor(), name, value);
}
enum radio_radio_mode {
  radio_radio_mode_RADIO_MODE_AP = 0,
  radio_radio_mode_RADIO_MODE_MESH_PORTAL = 1,
  radio_radio_mode_RADIO_MODE_MESH_POINT = 2,
  radio_radio_mode_RADIO_MODE_AIR_MONITOR = 3,
  radio_radio_mode_RADIO_MODE_SPECTRUM_SENSOR = 4,
  radio_radio_mode_RADIO_MODE_UNKNOWN = 5
};
bool radio_radio_mode_IsValid(int value);
const radio_radio_mode radio_radio_mode_radio_mode_MIN = radio_radio_mode_RADIO_MODE_AP;
const radio_radio_mode radio_radio_mode_radio_mode_MAX = radio_radio_mode_RADIO_MODE_UNKNOWN;
const int radio_radio_mode_radio_mode_ARRAYSIZE = radio_radio_mode_radio_mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* radio_radio_mode_descriptor();
inline const ::std::string& radio_radio_mode_Name(radio_radio_mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    radio_radio_mode_descriptor(), value);
}
inline bool radio_radio_mode_Parse(
    const ::std::string& name, radio_radio_mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<radio_radio_mode>(
    radio_radio_mode_descriptor(), name, value);
}
enum visibility_rec_ip_protocol {
  visibility_rec_ip_protocol_IP_PROTOCOL_VAL_6 = 6,
  visibility_rec_ip_protocol_IP_PROTOCOL_VAL_17 = 17
};
bool visibility_rec_ip_protocol_IsValid(int value);
const visibility_rec_ip_protocol visibility_rec_ip_protocol_ip_protocol_MIN = visibility_rec_ip_protocol_IP_PROTOCOL_VAL_6;
const visibility_rec_ip_protocol visibility_rec_ip_protocol_ip_protocol_MAX = visibility_rec_ip_protocol_IP_PROTOCOL_VAL_17;
const int visibility_rec_ip_protocol_ip_protocol_ARRAYSIZE = visibility_rec_ip_protocol_ip_protocol_MAX + 1;

const ::google::protobuf::EnumDescriptor* visibility_rec_ip_protocol_descriptor();
inline const ::std::string& visibility_rec_ip_protocol_Name(visibility_rec_ip_protocol value) {
  return ::google::protobuf::internal::NameOfEnum(
    visibility_rec_ip_protocol_descriptor(), value);
}
inline bool visibility_rec_ip_protocol_Parse(
    const ::std::string& name, visibility_rec_ip_protocol* value) {
  return ::google::protobuf::internal::ParseNamedEnum<visibility_rec_ip_protocol>(
    visibility_rec_ip_protocol_descriptor(), name, value);
}
enum visibility_rec_IapAppEnforcementStatus {
  visibility_rec_IapAppEnforcementStatus_ENF_PERMIT = 1,
  visibility_rec_IapAppEnforcementStatus_ENF_DENY = 2
};
bool visibility_rec_IapAppEnforcementStatus_IsValid(int value);
const visibility_rec_IapAppEnforcementStatus visibility_rec_IapAppEnforcementStatus_IapAppEnforcementStatus_MIN = visibility_rec_IapAppEnforcementStatus_ENF_PERMIT;
const visibility_rec_IapAppEnforcementStatus visibility_rec_IapAppEnforcementStatus_IapAppEnforcementStatus_MAX = visibility_rec_IapAppEnforcementStatus_ENF_DENY;
const int visibility_rec_IapAppEnforcementStatus_IapAppEnforcementStatus_ARRAYSIZE = visibility_rec_IapAppEnforcementStatus_IapAppEnforcementStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* visibility_rec_IapAppEnforcementStatus_descriptor();
inline const ::std::string& visibility_rec_IapAppEnforcementStatus_Name(visibility_rec_IapAppEnforcementStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    visibility_rec_IapAppEnforcementStatus_descriptor(), value);
}
inline bool visibility_rec_IapAppEnforcementStatus_Parse(
    const ::std::string& name, visibility_rec_IapAppEnforcementStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<visibility_rec_IapAppEnforcementStatus>(
    visibility_rec_IapAppEnforcementStatus_descriptor(), name, value);
}
enum geofence_notify_zone_event {
  geofence_notify_zone_event_ZONE_IN = 0,
  geofence_notify_zone_event_ZONE_OUT = 1
};
bool geofence_notify_zone_event_IsValid(int value);
const geofence_notify_zone_event geofence_notify_zone_event_zone_event_MIN = geofence_notify_zone_event_ZONE_IN;
const geofence_notify_zone_event geofence_notify_zone_event_zone_event_MAX = geofence_notify_zone_event_ZONE_OUT;
const int geofence_notify_zone_event_zone_event_ARRAYSIZE = geofence_notify_zone_event_zone_event_MAX + 1;

const ::google::protobuf::EnumDescriptor* geofence_notify_zone_event_descriptor();
inline const ::std::string& geofence_notify_zone_event_Name(geofence_notify_zone_event value) {
  return ::google::protobuf::internal::NameOfEnum(
    geofence_notify_zone_event_descriptor(), value);
}
inline bool geofence_notify_zone_event_Parse(
    const ::std::string& name, geofence_notify_zone_event* value) {
  return ::google::protobuf::internal::ParseNamedEnum<geofence_notify_zone_event>(
    geofence_notify_zone_event_descriptor(), name, value);
}
enum stats_radio_radio_mode {
  stats_radio_radio_mode_RADIO_MODE_AP = 0,
  stats_radio_radio_mode_RADIO_MODE_MESH_PORTAL = 1,
  stats_radio_radio_mode_RADIO_MODE_MESH_POINT = 2,
  stats_radio_radio_mode_RADIO_MODE_AIR_MONITOR = 3,
  stats_radio_radio_mode_RADIO_MODE_SPECTRUM_SENSOR = 4,
  stats_radio_radio_mode_RADIO_MODE_UNKNOWN = 5
};
bool stats_radio_radio_mode_IsValid(int value);
const stats_radio_radio_mode stats_radio_radio_mode_radio_mode_MIN = stats_radio_radio_mode_RADIO_MODE_AP;
const stats_radio_radio_mode stats_radio_radio_mode_radio_mode_MAX = stats_radio_radio_mode_RADIO_MODE_UNKNOWN;
const int stats_radio_radio_mode_radio_mode_ARRAYSIZE = stats_radio_radio_mode_radio_mode_MAX + 1;

const ::google::protobuf::EnumDescriptor* stats_radio_radio_mode_descriptor();
inline const ::std::string& stats_radio_radio_mode_Name(stats_radio_radio_mode value) {
  return ::google::protobuf::internal::NameOfEnum(
    stats_radio_radio_mode_descriptor(), value);
}
inline bool stats_radio_radio_mode_Parse(
    const ::std::string& name, stats_radio_radio_mode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<stats_radio_radio_mode>(
    stats_radio_radio_mode_descriptor(), name, value);
}
enum security_message_security_msg_type {
  security_message_security_msg_type_AUTH_SRVR_TIMEOUT_MSG = 0,
  security_message_security_msg_type_MACAUTH_MSG = 1,
  security_message_security_msg_type_CAPTIVE_PORTAL_MSG = 2,
  security_message_security_msg_type_WPA_KEY_HANDSHAKE_MSG = 3,
  security_message_security_msg_type_DOT1X_MSG = 4,
  security_message_security_msg_type_UNKNOWN_MSG = 5
};
bool security_message_security_msg_type_IsValid(int value);
const security_message_security_msg_type security_message_security_msg_type_security_msg_type_MIN = security_message_security_msg_type_AUTH_SRVR_TIMEOUT_MSG;
const security_message_security_msg_type security_message_security_msg_type_security_msg_type_MAX = security_message_security_msg_type_UNKNOWN_MSG;
const int security_message_security_msg_type_security_msg_type_ARRAYSIZE = security_message_security_msg_type_security_msg_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* security_message_security_msg_type_descriptor();
inline const ::std::string& security_message_security_msg_type_Name(security_message_security_msg_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    security_message_security_msg_type_descriptor(), value);
}
inline bool security_message_security_msg_type_Parse(
    const ::std::string& name, security_message_security_msg_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<security_message_security_msg_type>(
    security_message_security_msg_type_descriptor(), name, value);
}
enum info_mode_type {
  info_mode_type_CONTEXT = 0,
  info_mode_type_CONTEXT_AND_LOCATION_WITH_CALIBRATION = 1,
  info_mode_type_CONTEXT_AND_ESTIMATED_LOCATION = 2
};
bool info_mode_type_IsValid(int value);
const info_mode_type info_mode_type_mode_type_MIN = info_mode_type_CONTEXT;
const info_mode_type info_mode_type_mode_type_MAX = info_mode_type_CONTEXT_AND_ESTIMATED_LOCATION;
const int info_mode_type_mode_type_ARRAYSIZE = info_mode_type_mode_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* info_mode_type_descriptor();
inline const ::std::string& info_mode_type_Name(info_mode_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    info_mode_type_descriptor(), value);
}
inline bool info_mode_type_Parse(
    const ::std::string& name, info_mode_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<info_mode_type>(
    info_mode_type_descriptor(), name, value);
}
enum nb_event_event_operation {
  nb_event_event_operation_OP_ADD = 0,
  nb_event_event_operation_OP_UPDATE = 1,
  nb_event_event_operation_OP_DELETE = 2,
  nb_event_event_operation_OP_SYNC = 3
};
bool nb_event_event_operation_IsValid(int value);
const nb_event_event_operation nb_event_event_operation_event_operation_MIN = nb_event_event_operation_OP_ADD;
const nb_event_event_operation nb_event_event_operation_event_operation_MAX = nb_event_event_operation_OP_SYNC;
const int nb_event_event_operation_event_operation_ARRAYSIZE = nb_event_event_operation_event_operation_MAX + 1;

const ::google::protobuf::EnumDescriptor* nb_event_event_operation_descriptor();
inline const ::std::string& nb_event_event_operation_Name(nb_event_event_operation value) {
  return ::google::protobuf::internal::NameOfEnum(
    nb_event_event_operation_descriptor(), value);
}
inline bool nb_event_event_operation_Parse(
    const ::std::string& name, nb_event_event_operation* value) {
  return ::google::protobuf::internal::ParseNamedEnum<nb_event_event_operation>(
    nb_event_event_operation_descriptor(), name, value);
}
enum nb_event_license_info {
  nb_event_license_info_hb_Dhak = 10,
  nb_event_license_info_hb_LimitOk = 11,
  nb_event_license_info_hb_ThresholdXNotice = 20,
  nb_event_license_info_hb_ThresholdOkNotice = 21,
  nb_event_license_info_hb_LicenseExceeded = 31,
  nb_event_license_info_hb_EvalStarted = 41,
  nb_event_license_info_hb_NewLimitExceeded = 51,
  nb_event_license_info_hb_EvalDone = 61,
  nb_event_license_info_hb_ALSOnline = 71,
  nb_event_license_info_hb_ALSDieing = 81,
  nb_event_license_info_hb_LICENSE_BLOCKED = 91
};
bool nb_event_license_info_IsValid(int value);
const nb_event_license_info nb_event_license_info_license_info_MIN = nb_event_license_info_hb_Dhak;
const nb_event_license_info nb_event_license_info_license_info_MAX = nb_event_license_info_hb_LICENSE_BLOCKED;
const int nb_event_license_info_license_info_ARRAYSIZE = nb_event_license_info_license_info_MAX + 1;

const ::google::protobuf::EnumDescriptor* nb_event_license_info_descriptor();
inline const ::std::string& nb_event_license_info_Name(nb_event_license_info value) {
  return ::google::protobuf::internal::NameOfEnum(
    nb_event_license_info_descriptor(), value);
}
inline bool nb_event_license_info_Parse(
    const ::std::string& name, nb_event_license_info* value) {
  return ::google::protobuf::internal::ParseNamedEnum<nb_event_license_info>(
    nb_event_license_info_descriptor(), name, value);
}
enum url_detail_record_url_http_method {
  url_detail_record_url_http_method_NON_HTTP = 1,
  url_detail_record_url_http_method_HTTP_GET = 2,
  url_detail_record_url_http_method_HTTP_PUT = 3,
  url_detail_record_url_http_method_HTTP_POST = 4,
  url_detail_record_url_http_method_HTTP_HEAD = 5
};
bool url_detail_record_url_http_method_IsValid(int value);
const url_detail_record_url_http_method url_detail_record_url_http_method_url_http_method_MIN = url_detail_record_url_http_method_NON_HTTP;
const url_detail_record_url_http_method url_detail_record_url_http_method_url_http_method_MAX = url_detail_record_url_http_method_HTTP_HEAD;
const int url_detail_record_url_http_method_url_http_method_ARRAYSIZE = url_detail_record_url_http_method_url_http_method_MAX + 1;

const ::google::protobuf::EnumDescriptor* url_detail_record_url_http_method_descriptor();
inline const ::std::string& url_detail_record_url_http_method_Name(url_detail_record_url_http_method value) {
  return ::google::protobuf::internal::NameOfEnum(
    url_detail_record_url_http_method_descriptor(), value);
}
inline bool url_detail_record_url_http_method_Parse(
    const ::std::string& name, url_detail_record_url_http_method* value) {
  return ::google::protobuf::internal::ParseNamedEnum<url_detail_record_url_http_method>(
    url_detail_record_url_http_method_descriptor(), name, value);
}
enum data_prio {
  DATA_PRIO_BK = 0,
  DATA_PRIO_BE = 1,
  DATA_PRIO_VI = 2,
  DATA_PRIO_VO = 3
};
bool data_prio_IsValid(int value);
const data_prio data_prio_MIN = DATA_PRIO_BK;
const data_prio data_prio_MAX = DATA_PRIO_VO;
const int data_prio_ARRAYSIZE = data_prio_MAX + 1;

const ::google::protobuf::EnumDescriptor* data_prio_descriptor();
inline const ::std::string& data_prio_Name(data_prio value) {
  return ::google::protobuf::internal::NameOfEnum(
    data_prio_descriptor(), value);
}
inline bool data_prio_Parse(
    const ::std::string& name, data_prio* value) {
  return ::google::protobuf::internal::ParseNamedEnum<data_prio>(
    data_prio_descriptor(), name, value);
}
enum traffic_type {
  DATA_TRAFFIC_TYPE_BCAST = 0,
  DATA_TRAFFIC_TYPE_MCAST = 1,
  DATA_TRAFFIC_TYPE_UCAST = 2
};
bool traffic_type_IsValid(int value);
const traffic_type traffic_type_MIN = DATA_TRAFFIC_TYPE_BCAST;
const traffic_type traffic_type_MAX = DATA_TRAFFIC_TYPE_UCAST;
const int traffic_type_ARRAYSIZE = traffic_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* traffic_type_descriptor();
inline const ::std::string& traffic_type_Name(traffic_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    traffic_type_descriptor(), value);
}
inline bool traffic_type_Parse(
    const ::std::string& name, traffic_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<traffic_type>(
    traffic_type_descriptor(), name, value);
}
enum ht_type {
  HTT_NONE = 0,
  HTT_20MZ = 1,
  HTT_40MZ = 2,
  HTT_VHT_20MZ = 3,
  HTT_VHT_40MZ = 4,
  HTT_VHT_80MZ = 5,
  HTT_VHT_160MZ = 6,
  HTT_VHT_80PLUS80MZ = 7,
  HTT_HE_20MZ = 8,
  HTT_HE_40MZ = 9,
  HTT_HE_80MZ = 10,
  HTT_HE_160MZ = 11,
  HTT_HE_80PLUS80MZ = 12,
  HTT_INVALID = 13
};
bool ht_type_IsValid(int value);
const ht_type ht_type_MIN = HTT_NONE;
const ht_type ht_type_MAX = HTT_INVALID;
const int ht_type_ARRAYSIZE = ht_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ht_type_descriptor();
inline const ::std::string& ht_type_Name(ht_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ht_type_descriptor(), value);
}
inline bool ht_type_Parse(
    const ::std::string& name, ht_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ht_type>(
    ht_type_descriptor(), name, value);
}
enum phy_type {
  PHY_TYPE_80211B = 0,
  PHY_TYPE_80211A = 1,
  PHY_TYPE_80211G = 2,
  PHY_TYPE_80211AG = 3,
  PHY_TYPE_INVALID = 4
};
bool phy_type_IsValid(int value);
const phy_type phy_type_MIN = PHY_TYPE_80211B;
const phy_type phy_type_MAX = PHY_TYPE_INVALID;
const int phy_type_ARRAYSIZE = phy_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* phy_type_descriptor();
inline const ::std::string& phy_type_Name(phy_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    phy_type_descriptor(), value);
}
inline bool phy_type_Parse(
    const ::std::string& name, phy_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<phy_type>(
    phy_type_descriptor(), name, value);
}
enum measurement_unit {
  METERS = 0,
  FEET = 1,
  PIXELS = 2
};
bool measurement_unit_IsValid(int value);
const measurement_unit measurement_unit_MIN = METERS;
const measurement_unit measurement_unit_MAX = PIXELS;
const int measurement_unit_ARRAYSIZE = measurement_unit_MAX + 1;

const ::google::protobuf::EnumDescriptor* measurement_unit_descriptor();
inline const ::std::string& measurement_unit_Name(measurement_unit value) {
  return ::google::protobuf::internal::NameOfEnum(
    measurement_unit_descriptor(), value);
}
inline bool measurement_unit_Parse(
    const ::std::string& name, measurement_unit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<measurement_unit>(
    measurement_unit_descriptor(), name, value);
}
enum vpn_tunnel_type {
  ARUBA_CONTROLLER_TUNNEL = 1,
  VIG_TUNNEL = 2
};
bool vpn_tunnel_type_IsValid(int value);
const vpn_tunnel_type vpn_tunnel_type_MIN = ARUBA_CONTROLLER_TUNNEL;
const vpn_tunnel_type vpn_tunnel_type_MAX = VIG_TUNNEL;
const int vpn_tunnel_type_ARRAYSIZE = vpn_tunnel_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* vpn_tunnel_type_descriptor();
inline const ::std::string& vpn_tunnel_type_Name(vpn_tunnel_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    vpn_tunnel_type_descriptor(), value);
}
inline bool vpn_tunnel_type_Parse(
    const ::std::string& name, vpn_tunnel_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<vpn_tunnel_type>(
    vpn_tunnel_type_descriptor(), name, value);
}
enum target_dev_type {
  TARGET_TYPE_UNKNOWN = 0,
  TARGET_TYPE_STATION = 1,
  TARGET_TYPE_TAG = 2,
  TARGET_TYPE_UNSECURE = 3
};
bool target_dev_type_IsValid(int value);
const target_dev_type target_dev_type_MIN = TARGET_TYPE_UNKNOWN;
const target_dev_type target_dev_type_MAX = TARGET_TYPE_UNSECURE;
const int target_dev_type_ARRAYSIZE = target_dev_type_MAX + 1;

const ::google::protobuf::EnumDescriptor* target_dev_type_descriptor();
inline const ::std::string& target_dev_type_Name(target_dev_type value) {
  return ::google::protobuf::internal::NameOfEnum(
    target_dev_type_descriptor(), value);
}
inline bool target_dev_type_Parse(
    const ::std::string& name, target_dev_type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<target_dev_type>(
    target_dev_type_descriptor(), name, value);
}
enum iap_enforcement_status {
  ENF_PERMIT = 1,
  ENF_DENY = 2
};
bool iap_enforcement_status_IsValid(int value);
const iap_enforcement_status iap_enforcement_status_MIN = ENF_PERMIT;
const iap_enforcement_status iap_enforcement_status_MAX = ENF_DENY;
const int iap_enforcement_status_ARRAYSIZE = iap_enforcement_status_MAX + 1;

const ::google::protobuf::EnumDescriptor* iap_enforcement_status_descriptor();
inline const ::std::string& iap_enforcement_status_Name(iap_enforcement_status value) {
  return ::google::protobuf::internal::NameOfEnum(
    iap_enforcement_status_descriptor(), value);
}
inline bool iap_enforcement_status_Parse(
    const ::std::string& name, iap_enforcement_status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<iap_enforcement_status>(
    iap_enforcement_status_descriptor(), name, value);
}
// ===================================================================

class ip_address : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.ip_address) */ {
 public:
  ip_address();
  virtual ~ip_address();

  ip_address(const ip_address& from);

  inline ip_address& operator=(const ip_address& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ip_address(ip_address&& from) noexcept
    : ip_address() {
    *this = ::std::move(from);
  }

  inline ip_address& operator=(ip_address&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ip_address& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ip_address* internal_default_instance() {
    return reinterpret_cast<const ip_address*>(
               &_ip_address_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ip_address* other);
  friend void swap(ip_address& a, ip_address& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ip_address* New() const final {
    return CreateMaybeMessage<ip_address>(NULL);
  }

  ip_address* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ip_address>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ip_address& from);
  void MergeFrom(const ip_address& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ip_address* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ip_address_addr_family addr_family;
  static const addr_family ADDR_FAMILY_UNSPEC =
    ip_address_addr_family_ADDR_FAMILY_UNSPEC;
  static const addr_family ADDR_FAMILY_INET =
    ip_address_addr_family_ADDR_FAMILY_INET;
  static const addr_family ADDR_FAMILY_INET6 =
    ip_address_addr_family_ADDR_FAMILY_INET6;
  static inline bool addr_family_IsValid(int value) {
    return ip_address_addr_family_IsValid(value);
  }
  static const addr_family addr_family_MIN =
    ip_address_addr_family_addr_family_MIN;
  static const addr_family addr_family_MAX =
    ip_address_addr_family_addr_family_MAX;
  static const int addr_family_ARRAYSIZE =
    ip_address_addr_family_addr_family_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  addr_family_descriptor() {
    return ip_address_addr_family_descriptor();
  }
  static inline const ::std::string& addr_family_Name(addr_family value) {
    return ip_address_addr_family_Name(value);
  }
  static inline bool addr_family_Parse(const ::std::string& name,
      addr_family* value) {
    return ip_address_addr_family_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes addr = 2;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 2;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_addr(::std::string&& value);
  #endif
  void set_addr(const char* value);
  void set_addr(const void* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // required .ce.nbapi.ip_address.addr_family af = 1;
  bool has_af() const;
  void clear_af();
  static const int kAfFieldNumber = 1;
  ::ce::nbapi::ip_address_addr_family af() const;
  void set_af(::ce::nbapi::ip_address_addr_family value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.ip_address)
 private:
  void set_has_af();
  void clear_has_af();
  void set_has_addr();
  void clear_has_addr();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  int af_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class mac_address : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.mac_address) */ {
 public:
  mac_address();
  virtual ~mac_address();

  mac_address(const mac_address& from);

  inline mac_address& operator=(const mac_address& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  mac_address(mac_address&& from) noexcept
    : mac_address() {
    *this = ::std::move(from);
  }

  inline mac_address& operator=(mac_address&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mac_address& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const mac_address* internal_default_instance() {
    return reinterpret_cast<const mac_address*>(
               &_mac_address_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(mac_address* other);
  friend void swap(mac_address& a, mac_address& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline mac_address* New() const final {
    return CreateMaybeMessage<mac_address>(NULL);
  }

  mac_address* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<mac_address>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const mac_address& from);
  void MergeFrom(const mac_address& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mac_address* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes addr = 1;
  bool has_addr() const;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_addr(::std::string&& value);
  #endif
  void set_addr(const char* value);
  void set_addr(const void* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // @@protoc_insertion_point(class_scope:ce.nbapi.mac_address)
 private:
  void set_has_addr();
  void clear_has_addr();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class data_rate_stats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.data_rate_stats) */ {
 public:
  data_rate_stats();
  virtual ~data_rate_stats();

  data_rate_stats(const data_rate_stats& from);

  inline data_rate_stats& operator=(const data_rate_stats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  data_rate_stats(data_rate_stats&& from) noexcept
    : data_rate_stats() {
    *this = ::std::move(from);
  }

  inline data_rate_stats& operator=(data_rate_stats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const data_rate_stats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const data_rate_stats* internal_default_instance() {
    return reinterpret_cast<const data_rate_stats*>(
               &_data_rate_stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(data_rate_stats* other);
  friend void swap(data_rate_stats& a, data_rate_stats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline data_rate_stats* New() const final {
    return CreateMaybeMessage<data_rate_stats>(NULL);
  }

  data_rate_stats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<data_rate_stats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const data_rate_stats& from);
  void MergeFrom(const data_rate_stats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(data_rate_stats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rate = 1;
  bool has_rate() const;
  void clear_rate();
  static const int kRateFieldNumber = 1;
  ::google::protobuf::uint32 rate() const;
  void set_rate(::google::protobuf::uint32 value);

  // optional uint32 tx_frame_count = 2;
  bool has_tx_frame_count() const;
  void clear_tx_frame_count();
  static const int kTxFrameCountFieldNumber = 2;
  ::google::protobuf::uint32 tx_frame_count() const;
  void set_tx_frame_count(::google::protobuf::uint32 value);

  // optional uint32 tx_byte_count = 3;
  bool has_tx_byte_count() const;
  void clear_tx_byte_count();
  static const int kTxByteCountFieldNumber = 3;
  ::google::protobuf::uint32 tx_byte_count() const;
  void set_tx_byte_count(::google::protobuf::uint32 value);

  // optional uint32 rx_frame_count = 4;
  bool has_rx_frame_count() const;
  void clear_rx_frame_count();
  static const int kRxFrameCountFieldNumber = 4;
  ::google::protobuf::uint32 rx_frame_count() const;
  void set_rx_frame_count(::google::protobuf::uint32 value);

  // optional uint32 rx_byte_count = 5;
  bool has_rx_byte_count() const;
  void clear_rx_byte_count();
  static const int kRxByteCountFieldNumber = 5;
  ::google::protobuf::uint32 rx_byte_count() const;
  void set_rx_byte_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.data_rate_stats)
 private:
  void set_has_rate();
  void clear_has_rate();
  void set_has_tx_frame_count();
  void clear_has_tx_frame_count();
  void set_has_tx_byte_count();
  void clear_has_tx_byte_count();
  void set_has_rx_frame_count();
  void clear_has_rx_frame_count();
  void set_has_rx_byte_count();
  void clear_has_rx_byte_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 rate_;
  ::google::protobuf::uint32 tx_frame_count_;
  ::google::protobuf::uint32 tx_byte_count_;
  ::google::protobuf::uint32 rx_frame_count_;
  ::google::protobuf::uint32 rx_byte_count_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class data_prio_stats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.data_prio_stats) */ {
 public:
  data_prio_stats();
  virtual ~data_prio_stats();

  data_prio_stats(const data_prio_stats& from);

  inline data_prio_stats& operator=(const data_prio_stats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  data_prio_stats(data_prio_stats&& from) noexcept
    : data_prio_stats() {
    *this = ::std::move(from);
  }

  inline data_prio_stats& operator=(data_prio_stats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const data_prio_stats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const data_prio_stats* internal_default_instance() {
    return reinterpret_cast<const data_prio_stats*>(
               &_data_prio_stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(data_prio_stats* other);
  friend void swap(data_prio_stats& a, data_prio_stats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline data_prio_stats* New() const final {
    return CreateMaybeMessage<data_prio_stats>(NULL);
  }

  data_prio_stats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<data_prio_stats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const data_prio_stats& from);
  void MergeFrom(const data_prio_stats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(data_prio_stats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.data_prio prio = 1;
  bool has_prio() const;
  void clear_prio();
  static const int kPrioFieldNumber = 1;
  ::ce::nbapi::data_prio prio() const;
  void set_prio(::ce::nbapi::data_prio value);

  // optional uint32 tx_frame_count = 2;
  bool has_tx_frame_count() const;
  void clear_tx_frame_count();
  static const int kTxFrameCountFieldNumber = 2;
  ::google::protobuf::uint32 tx_frame_count() const;
  void set_tx_frame_count(::google::protobuf::uint32 value);

  // optional uint32 rx_frame_count = 3;
  bool has_rx_frame_count() const;
  void clear_rx_frame_count();
  static const int kRxFrameCountFieldNumber = 3;
  ::google::protobuf::uint32 rx_frame_count() const;
  void set_rx_frame_count(::google::protobuf::uint32 value);

  // optional uint32 tx_drop_count = 4;
  bool has_tx_drop_count() const;
  void clear_tx_drop_count();
  static const int kTxDropCountFieldNumber = 4;
  ::google::protobuf::uint32 tx_drop_count() const;
  void set_tx_drop_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.data_prio_stats)
 private:
  void set_has_prio();
  void clear_has_prio();
  void set_has_tx_frame_count();
  void clear_has_tx_frame_count();
  void set_has_rx_frame_count();
  void clear_has_rx_frame_count();
  void set_has_tx_drop_count();
  void clear_has_tx_drop_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int prio_;
  ::google::protobuf::uint32 tx_frame_count_;
  ::google::protobuf::uint32 rx_frame_count_;
  ::google::protobuf::uint32 tx_drop_count_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class data_traffic_type_stats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.data_traffic_type_stats) */ {
 public:
  data_traffic_type_stats();
  virtual ~data_traffic_type_stats();

  data_traffic_type_stats(const data_traffic_type_stats& from);

  inline data_traffic_type_stats& operator=(const data_traffic_type_stats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  data_traffic_type_stats(data_traffic_type_stats&& from) noexcept
    : data_traffic_type_stats() {
    *this = ::std::move(from);
  }

  inline data_traffic_type_stats& operator=(data_traffic_type_stats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const data_traffic_type_stats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const data_traffic_type_stats* internal_default_instance() {
    return reinterpret_cast<const data_traffic_type_stats*>(
               &_data_traffic_type_stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(data_traffic_type_stats* other);
  friend void swap(data_traffic_type_stats& a, data_traffic_type_stats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline data_traffic_type_stats* New() const final {
    return CreateMaybeMessage<data_traffic_type_stats>(NULL);
  }

  data_traffic_type_stats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<data_traffic_type_stats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const data_traffic_type_stats& from);
  void MergeFrom(const data_traffic_type_stats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(data_traffic_type_stats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.traffic_type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ce::nbapi::traffic_type type() const;
  void set_type(::ce::nbapi::traffic_type value);

  // optional uint32 tx_frame_count = 2;
  bool has_tx_frame_count() const;
  void clear_tx_frame_count();
  static const int kTxFrameCountFieldNumber = 2;
  ::google::protobuf::uint32 tx_frame_count() const;
  void set_tx_frame_count(::google::protobuf::uint32 value);

  // optional uint32 rx_frame_count = 3;
  bool has_rx_frame_count() const;
  void clear_rx_frame_count();
  static const int kRxFrameCountFieldNumber = 3;
  ::google::protobuf::uint32 rx_frame_count() const;
  void set_rx_frame_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.data_traffic_type_stats)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_tx_frame_count();
  void clear_has_tx_frame_count();
  void set_has_rx_frame_count();
  void clear_has_rx_frame_count();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int type_;
  ::google::protobuf::uint32 tx_frame_count_;
  ::google::protobuf::uint32 rx_frame_count_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ap_neighbor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.ap_neighbor) */ {
 public:
  ap_neighbor();
  virtual ~ap_neighbor();

  ap_neighbor(const ap_neighbor& from);

  inline ap_neighbor& operator=(const ap_neighbor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ap_neighbor(ap_neighbor&& from) noexcept
    : ap_neighbor() {
    *this = ::std::move(from);
  }

  inline ap_neighbor& operator=(ap_neighbor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ap_neighbor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ap_neighbor* internal_default_instance() {
    return reinterpret_cast<const ap_neighbor*>(
               &_ap_neighbor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ap_neighbor* other);
  friend void swap(ap_neighbor& a, ap_neighbor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ap_neighbor* New() const final {
    return CreateMaybeMessage<ap_neighbor>(NULL);
  }

  ap_neighbor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ap_neighbor>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ap_neighbor& from);
  void MergeFrom(const ap_neighbor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ap_neighbor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ap_neighbor_network_type network_type;
  static const network_type INFRASTRUCTURE =
    ap_neighbor_network_type_INFRASTRUCTURE;
  static const network_type ADHOC =
    ap_neighbor_network_type_ADHOC;
  static inline bool network_type_IsValid(int value) {
    return ap_neighbor_network_type_IsValid(value);
  }
  static const network_type network_type_MIN =
    ap_neighbor_network_type_network_type_MIN;
  static const network_type network_type_MAX =
    ap_neighbor_network_type_network_type_MAX;
  static const int network_type_ARRAYSIZE =
    ap_neighbor_network_type_network_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  network_type_descriptor() {
    return ap_neighbor_network_type_descriptor();
  }
  static inline const ::std::string& network_type_Name(network_type value) {
    return ap_neighbor_network_type_Name(value);
  }
  static inline bool network_type_Parse(const ::std::string& name,
      network_type* value) {
    return ap_neighbor_network_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string neighbor_ssid = 5;
  bool has_neighbor_ssid() const;
  void clear_neighbor_ssid();
  static const int kNeighborSsidFieldNumber = 5;
  const ::std::string& neighbor_ssid() const;
  void set_neighbor_ssid(const ::std::string& value);
  #if LANG_CXX11
  void set_neighbor_ssid(::std::string&& value);
  #endif
  void set_neighbor_ssid(const char* value);
  void set_neighbor_ssid(const char* value, size_t size);
  ::std::string* mutable_neighbor_ssid();
  ::std::string* release_neighbor_ssid();
  void set_allocated_neighbor_ssid(::std::string* neighbor_ssid);

  // optional .ce.nbapi.mac_address ap_eth_mac = 1;
  bool has_ap_eth_mac() const;
  void clear_ap_eth_mac();
  static const int kApEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_eth_mac() const;
  ::ce::nbapi::mac_address* release_ap_eth_mac();
  ::ce::nbapi::mac_address* mutable_ap_eth_mac();
  void set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac);

  // optional .ce.nbapi.mac_address bssid = 2;
  bool has_bssid() const;
  void clear_bssid();
  static const int kBssidFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_bssid() const;
  public:
  const ::ce::nbapi::mac_address& bssid() const;
  ::ce::nbapi::mac_address* release_bssid();
  ::ce::nbapi::mac_address* mutable_bssid();
  void set_allocated_bssid(::ce::nbapi::mac_address* bssid);

  // optional .ce.nbapi.mac_address neighbor_bssid = 4;
  bool has_neighbor_bssid() const;
  void clear_neighbor_bssid();
  static const int kNeighborBssidFieldNumber = 4;
  private:
  const ::ce::nbapi::mac_address& _internal_neighbor_bssid() const;
  public:
  const ::ce::nbapi::mac_address& neighbor_bssid() const;
  ::ce::nbapi::mac_address* release_neighbor_bssid();
  ::ce::nbapi::mac_address* mutable_neighbor_bssid();
  void set_allocated_neighbor_bssid(::ce::nbapi::mac_address* neighbor_bssid);

  // optional .ce.nbapi.phy_type phy = 3;
  bool has_phy() const;
  void clear_phy();
  static const int kPhyFieldNumber = 3;
  ::ce::nbapi::phy_type phy() const;
  void set_phy(::ce::nbapi::phy_type value);

  // optional .ce.nbapi.ap_neighbor.network_type neighbor_network = 6;
  bool has_neighbor_network() const;
  void clear_neighbor_network();
  static const int kNeighborNetworkFieldNumber = 6;
  ::ce::nbapi::ap_neighbor_network_type neighbor_network() const;
  void set_neighbor_network(::ce::nbapi::ap_neighbor_network_type value);

  // optional uint32 neighbor_channel = 7;
  bool has_neighbor_channel() const;
  void clear_neighbor_channel();
  static const int kNeighborChannelFieldNumber = 7;
  ::google::protobuf::uint32 neighbor_channel() const;
  void set_neighbor_channel(::google::protobuf::uint32 value);

  // optional uint32 neighbor_rssi = 10;
  bool has_neighbor_rssi() const;
  void clear_neighbor_rssi();
  static const int kNeighborRssiFieldNumber = 10;
  ::google::protobuf::uint32 neighbor_rssi() const;
  void set_neighbor_rssi(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.ap_neighbor)
 private:
  void set_has_ap_eth_mac();
  void clear_has_ap_eth_mac();
  void set_has_bssid();
  void clear_has_bssid();
  void set_has_phy();
  void clear_has_phy();
  void set_has_neighbor_bssid();
  void clear_has_neighbor_bssid();
  void set_has_neighbor_ssid();
  void clear_has_neighbor_ssid();
  void set_has_neighbor_network();
  void clear_has_neighbor_network();
  void set_has_neighbor_channel();
  void clear_has_neighbor_channel();
  void set_has_neighbor_rssi();
  void clear_has_neighbor_rssi();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr neighbor_ssid_;
  ::ce::nbapi::mac_address* ap_eth_mac_;
  ::ce::nbapi::mac_address* bssid_;
  ::ce::nbapi::mac_address* neighbor_bssid_;
  int phy_;
  int neighbor_network_;
  ::google::protobuf::uint32 neighbor_channel_;
  ::google::protobuf::uint32 neighbor_rssi_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class util_stats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.util_stats) */ {
 public:
  util_stats();
  virtual ~util_stats();

  util_stats(const util_stats& from);

  inline util_stats& operator=(const util_stats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  util_stats(util_stats&& from) noexcept
    : util_stats() {
    *this = ::std::move(from);
  }

  inline util_stats& operator=(util_stats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const util_stats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const util_stats* internal_default_instance() {
    return reinterpret_cast<const util_stats*>(
               &_util_stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(util_stats* other);
  friend void swap(util_stats& a, util_stats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline util_stats* New() const final {
    return CreateMaybeMessage<util_stats>(NULL);
  }

  util_stats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<util_stats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const util_stats& from);
  void MergeFrom(const util_stats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(util_stats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef util_stats_util_stat_type util_stat_type;
  static const util_stat_type UTIL_STAT_TYPE_CHANNEL =
    util_stats_util_stat_type_UTIL_STAT_TYPE_CHANNEL;
  static const util_stat_type UTIL_STAT_TYPE_CHANNEL_TX =
    util_stats_util_stat_type_UTIL_STAT_TYPE_CHANNEL_TX;
  static const util_stat_type UTIL_STAT_TYPE_CHANNEL_RX =
    util_stats_util_stat_type_UTIL_STAT_TYPE_CHANNEL_RX;
  static const util_stat_type UTIL_STAT_TYPE_QUEUE_SWTX =
    util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_SWTX;
  static const util_stat_type UTIL_STAT_TYPE_QUEUE_BE =
    util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_BE;
  static const util_stat_type UTIL_STAT_TYPE_QUEUE_BK =
    util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_BK;
  static const util_stat_type UTIL_STAT_TYPE_QUEUE_VI =
    util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_VI;
  static const util_stat_type UTIL_STAT_TYPE_QUEUE_VO =
    util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_VO;
  static const util_stat_type UTIL_STAT_TYPE_QUEUE_BCMC =
    util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_BCMC;
  static const util_stat_type UTIL_STAT_TYPE_QUEUE_ATIM =
    util_stats_util_stat_type_UTIL_STAT_TYPE_QUEUE_ATIM;
  static inline bool util_stat_type_IsValid(int value) {
    return util_stats_util_stat_type_IsValid(value);
  }
  static const util_stat_type util_stat_type_MIN =
    util_stats_util_stat_type_util_stat_type_MIN;
  static const util_stat_type util_stat_type_MAX =
    util_stats_util_stat_type_util_stat_type_MAX;
  static const int util_stat_type_ARRAYSIZE =
    util_stats_util_stat_type_util_stat_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  util_stat_type_descriptor() {
    return util_stats_util_stat_type_descriptor();
  }
  static inline const ::std::string& util_stat_type_Name(util_stat_type value) {
    return util_stats_util_stat_type_Name(value);
  }
  static inline bool util_stat_type_Parse(const ::std::string& name,
      util_stat_type* value) {
    return util_stats_util_stat_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.util_stats.util_stat_type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::ce::nbapi::util_stats_util_stat_type type() const;
  void set_type(::ce::nbapi::util_stats_util_stat_type value);

  // optional uint32 bucket1 = 2;
  bool has_bucket1() const;
  void clear_bucket1();
  static const int kBucket1FieldNumber = 2;
  ::google::protobuf::uint32 bucket1() const;
  void set_bucket1(::google::protobuf::uint32 value);

  // optional uint32 bucket2 = 3;
  bool has_bucket2() const;
  void clear_bucket2();
  static const int kBucket2FieldNumber = 3;
  ::google::protobuf::uint32 bucket2() const;
  void set_bucket2(::google::protobuf::uint32 value);

  // optional uint32 bucket3 = 4;
  bool has_bucket3() const;
  void clear_bucket3();
  static const int kBucket3FieldNumber = 4;
  ::google::protobuf::uint32 bucket3() const;
  void set_bucket3(::google::protobuf::uint32 value);

  // optional uint32 bucket4 = 5;
  bool has_bucket4() const;
  void clear_bucket4();
  static const int kBucket4FieldNumber = 5;
  ::google::protobuf::uint32 bucket4() const;
  void set_bucket4(::google::protobuf::uint32 value);

  // optional uint32 bucket5 = 6;
  bool has_bucket5() const;
  void clear_bucket5();
  static const int kBucket5FieldNumber = 6;
  ::google::protobuf::uint32 bucket5() const;
  void set_bucket5(::google::protobuf::uint32 value);

  // optional uint32 max = 7;
  bool has_max() const;
  void clear_max();
  static const int kMaxFieldNumber = 7;
  ::google::protobuf::uint32 max() const;
  void set_max(::google::protobuf::uint32 value);

  // optional uint32 min = 8;
  bool has_min() const;
  void clear_min();
  static const int kMinFieldNumber = 8;
  ::google::protobuf::uint32 min() const;
  void set_min(::google::protobuf::uint32 value);

  // optional uint64 stat = 10;
  bool has_stat() const;
  void clear_stat();
  static const int kStatFieldNumber = 10;
  ::google::protobuf::uint64 stat() const;
  void set_stat(::google::protobuf::uint64 value);

  // optional uint32 curr = 9;
  bool has_curr() const;
  void clear_curr();
  static const int kCurrFieldNumber = 9;
  ::google::protobuf::uint32 curr() const;
  void set_curr(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.util_stats)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_bucket1();
  void clear_has_bucket1();
  void set_has_bucket2();
  void clear_has_bucket2();
  void set_has_bucket3();
  void clear_has_bucket3();
  void set_has_bucket4();
  void clear_has_bucket4();
  void set_has_bucket5();
  void clear_has_bucket5();
  void set_has_max();
  void clear_has_max();
  void set_has_min();
  void clear_has_min();
  void set_has_curr();
  void clear_has_curr();
  void set_has_stat();
  void clear_has_stat();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int type_;
  ::google::protobuf::uint32 bucket1_;
  ::google::protobuf::uint32 bucket2_;
  ::google::protobuf::uint32 bucket3_;
  ::google::protobuf::uint32 bucket4_;
  ::google::protobuf::uint32 bucket5_;
  ::google::protobuf::uint32 max_;
  ::google::protobuf::uint32 min_;
  ::google::protobuf::uint64 stat_;
  ::google::protobuf::uint32 curr_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class location_record : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.location.record) */ {
 public:
  location_record();
  virtual ~location_record();

  location_record(const location_record& from);

  inline location_record& operator=(const location_record& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  location_record(location_record&& from) noexcept
    : location_record() {
    *this = ::std::move(from);
  }

  inline location_record& operator=(location_record&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const location_record& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const location_record* internal_default_instance() {
    return reinterpret_cast<const location_record*>(
               &_location_record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(location_record* other);
  friend void swap(location_record& a, location_record& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline location_record* New() const final {
    return CreateMaybeMessage<location_record>(NULL);
  }

  location_record* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<location_record>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const location_record& from);
  void MergeFrom(const location_record& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(location_record* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.mac_address radio_mac = 2;
  bool has_radio_mac() const;
  void clear_radio_mac();
  static const int kRadioMacFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_radio_mac() const;
  public:
  const ::ce::nbapi::mac_address& radio_mac() const;
  ::ce::nbapi::mac_address* release_radio_mac();
  ::ce::nbapi::mac_address* mutable_radio_mac();
  void set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac);

  // required uint32 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // required int32 rssi_val = 3;
  bool has_rssi_val() const;
  void clear_rssi_val();
  static const int kRssiValFieldNumber = 3;
  ::google::protobuf::int32 rssi_val() const;
  void set_rssi_val(::google::protobuf::int32 value);

  // optional uint32 channel = 4;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 4;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.location.record)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_radio_mac();
  void clear_has_radio_mac();
  void set_has_rssi_val();
  void clear_has_rssi_val();
  void set_has_channel();
  void clear_has_channel();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* radio_mac_;
  ::google::protobuf::uint32 timestamp_;
  ::google::protobuf::int32 rssi_val_;
  ::google::protobuf::uint32 channel_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class location_rtls_tag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.location.rtls_tag) */ {
 public:
  location_rtls_tag();
  virtual ~location_rtls_tag();

  location_rtls_tag(const location_rtls_tag& from);

  inline location_rtls_tag& operator=(const location_rtls_tag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  location_rtls_tag(location_rtls_tag&& from) noexcept
    : location_rtls_tag() {
    *this = ::std::move(from);
  }

  inline location_rtls_tag& operator=(location_rtls_tag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const location_rtls_tag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const location_rtls_tag* internal_default_instance() {
    return reinterpret_cast<const location_rtls_tag*>(
               &_location_rtls_tag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(location_rtls_tag* other);
  friend void swap(location_rtls_tag& a, location_rtls_tag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline location_rtls_tag* New() const final {
    return CreateMaybeMessage<location_rtls_tag>(NULL);
  }

  location_rtls_tag* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<location_rtls_tag>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const location_rtls_tag& from);
  void MergeFrom(const location_rtls_tag& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(location_rtls_tag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes payload = 5;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 5;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // optional uint32 battery = 1;
  bool has_battery() const;
  void clear_battery();
  static const int kBatteryFieldNumber = 1;
  ::google::protobuf::uint32 battery() const;
  void set_battery(::google::protobuf::uint32 value);

  // optional uint32 channel = 2;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 2;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // optional uint32 tx_power = 3;
  bool has_tx_power() const;
  void clear_tx_power();
  static const int kTxPowerFieldNumber = 3;
  ::google::protobuf::uint32 tx_power() const;
  void set_tx_power(::google::protobuf::uint32 value);

  // optional uint32 data_rate = 4;
  bool has_data_rate() const;
  void clear_data_rate();
  static const int kDataRateFieldNumber = 4;
  ::google::protobuf::uint32 data_rate() const;
  void set_data_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.location.rtls_tag)
 private:
  void set_has_battery();
  void clear_has_battery();
  void set_has_channel();
  void clear_has_channel();
  void set_has_tx_power();
  void clear_has_tx_power();
  void set_has_data_rate();
  void clear_has_data_rate();
  void set_has_payload();
  void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::google::protobuf::uint32 battery_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint32 tx_power_;
  ::google::protobuf::uint32 data_rate_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.location) */ {
 public:
  location();
  virtual ~location();

  location(const location& from);

  inline location& operator=(const location& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  location(location&& from) noexcept
    : location() {
    *this = ::std::move(from);
  }

  inline location& operator=(location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const location* internal_default_instance() {
    return reinterpret_cast<const location*>(
               &_location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(location* other);
  friend void swap(location& a, location& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline location* New() const final {
    return CreateMaybeMessage<location>(NULL);
  }

  location* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<location>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const location& from);
  void MergeFrom(const location& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef location_record record;
  typedef location_rtls_tag rtls_tag;

  typedef location_algorithm algorithm;
  static const algorithm ALGORITHM_TRIANGULATION =
    location_algorithm_ALGORITHM_TRIANGULATION;
  static const algorithm ALGORITHM_AP_PLACEMENT =
    location_algorithm_ALGORITHM_AP_PLACEMENT;
  static const algorithm ALGORITHM_CALIBRATION =
    location_algorithm_ALGORITHM_CALIBRATION;
  static const algorithm ALGORITHM_ESTIMATION =
    location_algorithm_ALGORITHM_ESTIMATION;
  static const algorithm ALGORITHM_LOW_DENSITY =
    location_algorithm_ALGORITHM_LOW_DENSITY;
  static inline bool algorithm_IsValid(int value) {
    return location_algorithm_IsValid(value);
  }
  static const algorithm algorithm_MIN =
    location_algorithm_algorithm_MIN;
  static const algorithm algorithm_MAX =
    location_algorithm_algorithm_MAX;
  static const int algorithm_ARRAYSIZE =
    location_algorithm_algorithm_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  algorithm_descriptor() {
    return location_algorithm_descriptor();
  }
  static inline const ::std::string& algorithm_Name(algorithm value) {
    return location_algorithm_Name(value);
  }
  static inline bool algorithm_Parse(const ::std::string& name,
      algorithm* value) {
    return location_algorithm_Parse(name, value);
  }

  typedef location_error_code error_code;
  static const error_code ERROR_CODE_NO_ERROR =
    location_error_code_ERROR_CODE_NO_ERROR;
  static const error_code ERROR_CODE_0_RSSI =
    location_error_code_ERROR_CODE_0_RSSI;
  static const error_code ERROR_CODE_ONLY_1_RSSI =
    location_error_code_ERROR_CODE_ONLY_1_RSSI;
  static const error_code ERROR_CODE_ONLY_2_RSSI =
    location_error_code_ERROR_CODE_ONLY_2_RSSI;
  static const error_code ERROR_CODE_RSSI_QUALITY =
    location_error_code_ERROR_CODE_RSSI_QUALITY;
  static const error_code ERROR_CODE_RSSI_OLD_TIMESTAMP =
    location_error_code_ERROR_CODE_RSSI_OLD_TIMESTAMP;
  static const error_code ERROR_CODE_RSSI_CLOSE_TIMESTAMP =
    location_error_code_ERROR_CODE_RSSI_CLOSE_TIMESTAMP;
  static const error_code ERROR_CODE_LEGACY =
    location_error_code_ERROR_CODE_LEGACY;
  static inline bool error_code_IsValid(int value) {
    return location_error_code_IsValid(value);
  }
  static const error_code error_code_MIN =
    location_error_code_error_code_MIN;
  static const error_code error_code_MAX =
    location_error_code_error_code_MAX;
  static const int error_code_ARRAYSIZE =
    location_error_code_error_code_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  error_code_descriptor() {
    return location_error_code_descriptor();
  }
  static inline const ::std::string& error_code_Name(error_code value) {
    return location_error_code_Name(value);
  }
  static inline bool error_code_Parse(const ::std::string& name,
      error_code* value) {
    return location_error_code_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated bytes geofence_ids = 13;
  int geofence_ids_size() const;
  void clear_geofence_ids();
  static const int kGeofenceIdsFieldNumber = 13;
  const ::std::string& geofence_ids(int index) const;
  ::std::string* mutable_geofence_ids(int index);
  void set_geofence_ids(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_geofence_ids(int index, ::std::string&& value);
  #endif
  void set_geofence_ids(int index, const char* value);
  void set_geofence_ids(int index, const void* value, size_t size);
  ::std::string* add_geofence_ids();
  void add_geofence_ids(const ::std::string& value);
  #if LANG_CXX11
  void add_geofence_ids(::std::string&& value);
  #endif
  void add_geofence_ids(const char* value);
  void add_geofence_ids(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& geofence_ids() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_geofence_ids();

  // repeated .ce.nbapi.location.record records = 22;
  int records_size() const;
  void clear_records();
  static const int kRecordsFieldNumber = 22;
  ::ce::nbapi::location_record* mutable_records(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::location_record >*
      mutable_records();
  const ::ce::nbapi::location_record& records(int index) const;
  ::ce::nbapi::location_record* add_records();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::location_record >&
      records() const;

  // repeated string geofence_names = 23;
  int geofence_names_size() const;
  void clear_geofence_names();
  static const int kGeofenceNamesFieldNumber = 23;
  const ::std::string& geofence_names(int index) const;
  ::std::string* mutable_geofence_names(int index);
  void set_geofence_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_geofence_names(int index, ::std::string&& value);
  #endif
  void set_geofence_names(int index, const char* value);
  void set_geofence_names(int index, const char* value, size_t size);
  ::std::string* add_geofence_names();
  void add_geofence_names(const ::std::string& value);
  #if LANG_CXX11
  void add_geofence_names(::std::string&& value);
  #endif
  void add_geofence_names(const char* value);
  void add_geofence_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& geofence_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_geofence_names();

  // repeated .ce.nbapi.location.rtls_tag rtls_tag_info = 24;
  int rtls_tag_info_size() const;
  void clear_rtls_tag_info();
  static const int kRtlsTagInfoFieldNumber = 24;
  ::ce::nbapi::location_rtls_tag* mutable_rtls_tag_info(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::location_rtls_tag >*
      mutable_rtls_tag_info();
  const ::ce::nbapi::location_rtls_tag& rtls_tag_info(int index) const;
  ::ce::nbapi::location_rtls_tag* add_rtls_tag_info();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::location_rtls_tag >&
      rtls_tag_info() const;

  // optional bytes campus_id = 9;
  bool has_campus_id() const;
  void clear_campus_id();
  static const int kCampusIdFieldNumber = 9;
  const ::std::string& campus_id() const;
  void set_campus_id(const ::std::string& value);
  #if LANG_CXX11
  void set_campus_id(::std::string&& value);
  #endif
  void set_campus_id(const char* value);
  void set_campus_id(const void* value, size_t size);
  ::std::string* mutable_campus_id();
  ::std::string* release_campus_id();
  void set_allocated_campus_id(::std::string* campus_id);

  // optional bytes building_id = 10;
  bool has_building_id() const;
  void clear_building_id();
  static const int kBuildingIdFieldNumber = 10;
  const ::std::string& building_id() const;
  void set_building_id(const ::std::string& value);
  #if LANG_CXX11
  void set_building_id(::std::string&& value);
  #endif
  void set_building_id(const char* value);
  void set_building_id(const void* value, size_t size);
  ::std::string* mutable_building_id();
  ::std::string* release_building_id();
  void set_allocated_building_id(::std::string* building_id);

  // optional bytes floor_id = 11;
  bool has_floor_id() const;
  void clear_floor_id();
  static const int kFloorIdFieldNumber = 11;
  const ::std::string& floor_id() const;
  void set_floor_id(const ::std::string& value);
  #if LANG_CXX11
  void set_floor_id(::std::string&& value);
  #endif
  void set_floor_id(const char* value);
  void set_floor_id(const void* value, size_t size);
  ::std::string* mutable_floor_id();
  ::std::string* release_floor_id();
  void set_allocated_floor_id(::std::string* floor_id);

  // optional bytes hashed_sta_eth_mac = 12;
  bool has_hashed_sta_eth_mac() const;
  void clear_hashed_sta_eth_mac();
  static const int kHashedStaEthMacFieldNumber = 12;
  const ::std::string& hashed_sta_eth_mac() const;
  void set_hashed_sta_eth_mac(const ::std::string& value);
  #if LANG_CXX11
  void set_hashed_sta_eth_mac(::std::string&& value);
  #endif
  void set_hashed_sta_eth_mac(const char* value);
  void set_hashed_sta_eth_mac(const void* value, size_t size);
  ::std::string* mutable_hashed_sta_eth_mac();
  ::std::string* release_hashed_sta_eth_mac();
  void set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac);

  // optional .ce.nbapi.mac_address sta_eth_mac = 1;
  bool has_sta_eth_mac() const;
  void clear_sta_eth_mac();
  static const int kStaEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_sta_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& sta_eth_mac() const;
  ::ce::nbapi::mac_address* release_sta_eth_mac();
  ::ce::nbapi::mac_address* mutable_sta_eth_mac();
  void set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac);

  // optional float sta_location_x = 2;
  bool has_sta_location_x() const;
  void clear_sta_location_x();
  static const int kStaLocationXFieldNumber = 2;
  float sta_location_x() const;
  void set_sta_location_x(float value);

  // optional float sta_location_y = 3;
  bool has_sta_location_y() const;
  void clear_sta_location_y();
  static const int kStaLocationYFieldNumber = 3;
  float sta_location_y() const;
  void set_sta_location_y(float value);

  // optional uint32 error_level = 7;
  bool has_error_level() const;
  void clear_error_level();
  static const int kErrorLevelFieldNumber = 7;
  ::google::protobuf::uint32 error_level() const;
  void set_error_level(::google::protobuf::uint32 value);

  // optional .ce.nbapi.location.algorithm loc_algorithm = 14;
  bool has_loc_algorithm() const;
  void clear_loc_algorithm();
  static const int kLocAlgorithmFieldNumber = 14;
  ::ce::nbapi::location_algorithm loc_algorithm() const;
  void set_loc_algorithm(::ce::nbapi::location_algorithm value);

  // optional double longitude = 16;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 16;
  double longitude() const;
  void set_longitude(double value);

  // optional uint32 rssi_val = 15;
  bool has_rssi_val() const;
  void clear_rssi_val();
  static const int kRssiValFieldNumber = 15;
  ::google::protobuf::uint32 rssi_val() const;
  void set_rssi_val(::google::protobuf::uint32 value);

  // optional bool associated = 8;
  bool has_associated() const;
  void clear_associated();
  static const int kAssociatedFieldNumber = 8;
  bool associated() const;
  void set_associated(bool value);

  // optional bool associated_to_valid_bssid = 26;
  bool has_associated_to_valid_bssid() const;
  void clear_associated_to_valid_bssid();
  static const int kAssociatedToValidBssidFieldNumber = 26;
  bool associated_to_valid_bssid() const;
  void set_associated_to_valid_bssid(bool value);

  // optional double latitude = 17;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 17;
  double latitude() const;
  void set_latitude(double value);

  // optional double altitude = 18;
  bool has_altitude() const;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 18;
  double altitude() const;
  void set_altitude(double value);

  // optional .ce.nbapi.measurement_unit unit = 19;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 19;
  ::ce::nbapi::measurement_unit unit() const;
  void set_unit(::ce::nbapi::measurement_unit value);

  // optional .ce.nbapi.location.error_code err_code = 21;
  bool has_err_code() const;
  void clear_err_code();
  static const int kErrCodeFieldNumber = 21;
  ::ce::nbapi::location_error_code err_code() const;
  void set_err_code(::ce::nbapi::location_error_code value);

  // optional uint32 location_compute_timestamp = 25;
  bool has_location_compute_timestamp() const;
  void clear_location_compute_timestamp();
  static const int kLocationComputeTimestampFieldNumber = 25;
  ::google::protobuf::uint32 location_compute_timestamp() const;
  void set_location_compute_timestamp(::google::protobuf::uint32 value);

  // optional .ce.nbapi.target_dev_type target_type = 20 [default = TARGET_TYPE_STATION];
  bool has_target_type() const;
  void clear_target_type();
  static const int kTargetTypeFieldNumber = 20;
  ::ce::nbapi::target_dev_type target_type() const;
  void set_target_type(::ce::nbapi::target_dev_type value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.location)
 private:
  void set_has_sta_eth_mac();
  void clear_has_sta_eth_mac();
  void set_has_sta_location_x();
  void clear_has_sta_location_x();
  void set_has_sta_location_y();
  void clear_has_sta_location_y();
  void set_has_error_level();
  void clear_has_error_level();
  void set_has_associated();
  void clear_has_associated();
  void set_has_campus_id();
  void clear_has_campus_id();
  void set_has_building_id();
  void clear_has_building_id();
  void set_has_floor_id();
  void clear_has_floor_id();
  void set_has_hashed_sta_eth_mac();
  void clear_has_hashed_sta_eth_mac();
  void set_has_loc_algorithm();
  void clear_has_loc_algorithm();
  void set_has_rssi_val();
  void clear_has_rssi_val();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_altitude();
  void clear_has_altitude();
  void set_has_unit();
  void clear_has_unit();
  void set_has_target_type();
  void clear_has_target_type();
  void set_has_err_code();
  void clear_has_err_code();
  void set_has_location_compute_timestamp();
  void clear_has_location_compute_timestamp();
  void set_has_associated_to_valid_bssid();
  void clear_has_associated_to_valid_bssid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> geofence_ids_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::location_record > records_;
  ::google::protobuf::RepeatedPtrField< ::std::string> geofence_names_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::location_rtls_tag > rtls_tag_info_;
  ::google::protobuf::internal::ArenaStringPtr campus_id_;
  ::google::protobuf::internal::ArenaStringPtr building_id_;
  ::google::protobuf::internal::ArenaStringPtr floor_id_;
  ::google::protobuf::internal::ArenaStringPtr hashed_sta_eth_mac_;
  ::ce::nbapi::mac_address* sta_eth_mac_;
  float sta_location_x_;
  float sta_location_y_;
  ::google::protobuf::uint32 error_level_;
  int loc_algorithm_;
  double longitude_;
  ::google::protobuf::uint32 rssi_val_;
  bool associated_;
  bool associated_to_valid_bssid_;
  double latitude_;
  double altitude_;
  int unit_;
  int err_code_;
  ::google::protobuf::uint32 location_compute_timestamp_;
  int target_type_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class presence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.presence) */ {
 public:
  presence();
  virtual ~presence();

  presence(const presence& from);

  inline presence& operator=(const presence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  presence(presence&& from) noexcept
    : presence() {
    *this = ::std::move(from);
  }

  inline presence& operator=(presence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const presence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const presence* internal_default_instance() {
    return reinterpret_cast<const presence*>(
               &_presence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(presence* other);
  friend void swap(presence& a, presence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline presence* New() const final {
    return CreateMaybeMessage<presence>(NULL);
  }

  presence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<presence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const presence& from);
  void MergeFrom(const presence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(presence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes hashed_sta_eth_mac = 3;
  bool has_hashed_sta_eth_mac() const;
  void clear_hashed_sta_eth_mac();
  static const int kHashedStaEthMacFieldNumber = 3;
  const ::std::string& hashed_sta_eth_mac() const;
  void set_hashed_sta_eth_mac(const ::std::string& value);
  #if LANG_CXX11
  void set_hashed_sta_eth_mac(::std::string&& value);
  #endif
  void set_hashed_sta_eth_mac(const char* value);
  void set_hashed_sta_eth_mac(const void* value, size_t size);
  ::std::string* mutable_hashed_sta_eth_mac();
  ::std::string* release_hashed_sta_eth_mac();
  void set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac);

  // optional string ap_name = 4;
  bool has_ap_name() const;
  void clear_ap_name();
  static const int kApNameFieldNumber = 4;
  const ::std::string& ap_name() const;
  void set_ap_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ap_name(::std::string&& value);
  #endif
  void set_ap_name(const char* value);
  void set_ap_name(const char* value, size_t size);
  ::std::string* mutable_ap_name();
  ::std::string* release_ap_name();
  void set_allocated_ap_name(::std::string* ap_name);

  // optional .ce.nbapi.mac_address sta_eth_mac = 1;
  bool has_sta_eth_mac() const;
  void clear_sta_eth_mac();
  static const int kStaEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_sta_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& sta_eth_mac() const;
  ::ce::nbapi::mac_address* release_sta_eth_mac();
  ::ce::nbapi::mac_address* mutable_sta_eth_mac();
  void set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac);

  // optional .ce.nbapi.mac_address radio_mac = 5;
  bool has_radio_mac() const;
  void clear_radio_mac();
  static const int kRadioMacFieldNumber = 5;
  private:
  const ::ce::nbapi::mac_address& _internal_radio_mac() const;
  public:
  const ::ce::nbapi::mac_address& radio_mac() const;
  ::ce::nbapi::mac_address* release_radio_mac();
  ::ce::nbapi::mac_address* mutable_radio_mac();
  void set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac);

  // optional bool associated = 2;
  bool has_associated() const;
  void clear_associated();
  static const int kAssociatedFieldNumber = 2;
  bool associated() const;
  void set_associated(bool value);

  // optional .ce.nbapi.target_dev_type target_type = 6 [default = TARGET_TYPE_STATION];
  bool has_target_type() const;
  void clear_target_type();
  static const int kTargetTypeFieldNumber = 6;
  ::ce::nbapi::target_dev_type target_type() const;
  void set_target_type(::ce::nbapi::target_dev_type value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.presence)
 private:
  void set_has_sta_eth_mac();
  void clear_has_sta_eth_mac();
  void set_has_associated();
  void clear_has_associated();
  void set_has_hashed_sta_eth_mac();
  void clear_has_hashed_sta_eth_mac();
  void set_has_ap_name();
  void clear_has_ap_name();
  void set_has_radio_mac();
  void clear_has_radio_mac();
  void set_has_target_type();
  void clear_has_target_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hashed_sta_eth_mac_;
  ::google::protobuf::internal::ArenaStringPtr ap_name_;
  ::ce::nbapi::mac_address* sta_eth_mac_;
  ::ce::nbapi::mac_address* radio_mac_;
  bool associated_;
  int target_type_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class rssi : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.rssi) */ {
 public:
  rssi();
  virtual ~rssi();

  rssi(const rssi& from);

  inline rssi& operator=(const rssi& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  rssi(rssi&& from) noexcept
    : rssi() {
    *this = ::std::move(from);
  }

  inline rssi& operator=(rssi&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rssi& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const rssi* internal_default_instance() {
    return reinterpret_cast<const rssi*>(
               &_rssi_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(rssi* other);
  friend void swap(rssi& a, rssi& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline rssi* New() const final {
    return CreateMaybeMessage<rssi>(NULL);
  }

  rssi* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<rssi>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const rssi& from);
  void MergeFrom(const rssi& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rssi* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes hashed_sta_eth_mac = 5;
  bool has_hashed_sta_eth_mac() const;
  void clear_hashed_sta_eth_mac();
  static const int kHashedStaEthMacFieldNumber = 5;
  const ::std::string& hashed_sta_eth_mac() const;
  void set_hashed_sta_eth_mac(const ::std::string& value);
  #if LANG_CXX11
  void set_hashed_sta_eth_mac(::std::string&& value);
  #endif
  void set_hashed_sta_eth_mac(const char* value);
  void set_hashed_sta_eth_mac(const void* value, size_t size);
  ::std::string* mutable_hashed_sta_eth_mac();
  ::std::string* release_hashed_sta_eth_mac();
  void set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac);

  // optional .ce.nbapi.mac_address sta_eth_mac = 1;
  bool has_sta_eth_mac() const;
  void clear_sta_eth_mac();
  static const int kStaEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_sta_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& sta_eth_mac() const;
  ::ce::nbapi::mac_address* release_sta_eth_mac();
  ::ce::nbapi::mac_address* mutable_sta_eth_mac();
  void set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac);

  // optional .ce.nbapi.mac_address radio_mac = 2;
  bool has_radio_mac() const;
  void clear_radio_mac();
  static const int kRadioMacFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_radio_mac() const;
  public:
  const ::ce::nbapi::mac_address& radio_mac() const;
  ::ce::nbapi::mac_address* release_radio_mac();
  ::ce::nbapi::mac_address* mutable_radio_mac();
  void set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac);

  // optional uint32 rssi_val = 3;
  bool has_rssi_val() const;
  void clear_rssi_val();
  static const int kRssiValFieldNumber = 3;
  ::google::protobuf::uint32 rssi_val() const;
  void set_rssi_val(::google::protobuf::uint32 value);

  // optional bool associated = 4;
  bool has_associated() const;
  void clear_associated();
  static const int kAssociatedFieldNumber = 4;
  bool associated() const;
  void set_associated(bool value);

  // optional bool is_ap = 7;
  bool has_is_ap() const;
  void clear_is_ap();
  static const int kIsApFieldNumber = 7;
  bool is_ap() const;
  void set_is_ap(bool value);

  // optional uint32 noise_floor = 6;
  bool has_noise_floor() const;
  void clear_noise_floor();
  static const int kNoiseFloorFieldNumber = 6;
  ::google::protobuf::uint32 noise_floor() const;
  void set_noise_floor(::google::protobuf::uint32 value);

  // optional uint32 age = 8;
  bool has_age() const;
  void clear_age();
  static const int kAgeFieldNumber = 8;
  ::google::protobuf::uint32 age() const;
  void set_age(::google::protobuf::uint32 value);

  // optional uint32 classification_type = 9;
  bool has_classification_type() const;
  void clear_classification_type();
  static const int kClassificationTypeFieldNumber = 9;
  ::google::protobuf::uint32 classification_type() const;
  void set_classification_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.rssi)
 private:
  void set_has_sta_eth_mac();
  void clear_has_sta_eth_mac();
  void set_has_radio_mac();
  void clear_has_radio_mac();
  void set_has_rssi_val();
  void clear_has_rssi_val();
  void set_has_associated();
  void clear_has_associated();
  void set_has_hashed_sta_eth_mac();
  void clear_has_hashed_sta_eth_mac();
  void set_has_noise_floor();
  void clear_has_noise_floor();
  void set_has_is_ap();
  void clear_has_is_ap();
  void set_has_age();
  void clear_has_age();
  void set_has_classification_type();
  void clear_has_classification_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hashed_sta_eth_mac_;
  ::ce::nbapi::mac_address* sta_eth_mac_;
  ::ce::nbapi::mac_address* radio_mac_;
  ::google::protobuf::uint32 rssi_val_;
  bool associated_;
  bool is_ap_;
  ::google::protobuf::uint32 noise_floor_;
  ::google::protobuf::uint32 age_;
  ::google::protobuf::uint32 classification_type_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class sta_rssi : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.sta_rssi) */ {
 public:
  sta_rssi();
  virtual ~sta_rssi();

  sta_rssi(const sta_rssi& from);

  inline sta_rssi& operator=(const sta_rssi& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  sta_rssi(sta_rssi&& from) noexcept
    : sta_rssi() {
    *this = ::std::move(from);
  }

  inline sta_rssi& operator=(sta_rssi&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const sta_rssi& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const sta_rssi* internal_default_instance() {
    return reinterpret_cast<const sta_rssi*>(
               &_sta_rssi_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(sta_rssi* other);
  friend void swap(sta_rssi& a, sta_rssi& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline sta_rssi* New() const final {
    return CreateMaybeMessage<sta_rssi>(NULL);
  }

  sta_rssi* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<sta_rssi>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const sta_rssi& from);
  void MergeFrom(const sta_rssi& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(sta_rssi* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address sta_eth_mac = 1;
  bool has_sta_eth_mac() const;
  void clear_sta_eth_mac();
  static const int kStaEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_sta_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& sta_eth_mac() const;
  ::ce::nbapi::mac_address* release_sta_eth_mac();
  ::ce::nbapi::mac_address* mutable_sta_eth_mac();
  void set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac);

  // optional .ce.nbapi.mac_address radio_mac = 2;
  bool has_radio_mac() const;
  void clear_radio_mac();
  static const int kRadioMacFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_radio_mac() const;
  public:
  const ::ce::nbapi::mac_address& radio_mac() const;
  ::ce::nbapi::mac_address* release_radio_mac();
  ::ce::nbapi::mac_address* mutable_radio_mac();
  void set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac);

  // optional .ce.nbapi.mac_address assoc_bssid = 7;
  bool has_assoc_bssid() const;
  void clear_assoc_bssid();
  static const int kAssocBssidFieldNumber = 7;
  private:
  const ::ce::nbapi::mac_address& _internal_assoc_bssid() const;
  public:
  const ::ce::nbapi::mac_address& assoc_bssid() const;
  ::ce::nbapi::mac_address* release_assoc_bssid();
  ::ce::nbapi::mac_address* mutable_assoc_bssid();
  void set_allocated_assoc_bssid(::ce::nbapi::mac_address* assoc_bssid);

  // optional sint32 rssi_val = 3;
  bool has_rssi_val() const;
  void clear_rssi_val();
  static const int kRssiValFieldNumber = 3;
  ::google::protobuf::int32 rssi_val() const;
  void set_rssi_val(::google::protobuf::int32 value);

  // optional int32 age = 5;
  bool has_age() const;
  void clear_age();
  static const int kAgeFieldNumber = 5;
  ::google::protobuf::int32 age() const;
  void set_age(::google::protobuf::int32 value);

  // optional int32 noise_floor = 6;
  bool has_noise_floor() const;
  void clear_noise_floor();
  static const int kNoiseFloorFieldNumber = 6;
  ::google::protobuf::int32 noise_floor() const;
  void set_noise_floor(::google::protobuf::int32 value);

  // optional bool associated = 4;
  bool has_associated() const;
  void clear_associated();
  static const int kAssociatedFieldNumber = 4;
  bool associated() const;
  void set_associated(bool value);

  // optional bool associated_to_valid_bssid = 9;
  bool has_associated_to_valid_bssid() const;
  void clear_associated_to_valid_bssid();
  static const int kAssociatedToValidBssidFieldNumber = 9;
  bool associated_to_valid_bssid() const;
  void set_associated_to_valid_bssid(bool value);

  // optional uint32 classification_type = 8;
  bool has_classification_type() const;
  void clear_classification_type();
  static const int kClassificationTypeFieldNumber = 8;
  ::google::protobuf::uint32 classification_type() const;
  void set_classification_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.sta_rssi)
 private:
  void set_has_sta_eth_mac();
  void clear_has_sta_eth_mac();
  void set_has_radio_mac();
  void clear_has_radio_mac();
  void set_has_rssi_val();
  void clear_has_rssi_val();
  void set_has_associated();
  void clear_has_associated();
  void set_has_age();
  void clear_has_age();
  void set_has_noise_floor();
  void clear_has_noise_floor();
  void set_has_assoc_bssid();
  void clear_has_assoc_bssid();
  void set_has_classification_type();
  void clear_has_classification_type();
  void set_has_associated_to_valid_bssid();
  void clear_has_associated_to_valid_bssid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* sta_eth_mac_;
  ::ce::nbapi::mac_address* radio_mac_;
  ::ce::nbapi::mac_address* assoc_bssid_;
  ::google::protobuf::int32 rssi_val_;
  ::google::protobuf::int32 age_;
  ::google::protobuf::int32 noise_floor_;
  bool associated_;
  bool associated_to_valid_bssid_;
  ::google::protobuf::uint32 classification_type_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class tag_rssi : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.tag_rssi) */ {
 public:
  tag_rssi();
  virtual ~tag_rssi();

  tag_rssi(const tag_rssi& from);

  inline tag_rssi& operator=(const tag_rssi& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  tag_rssi(tag_rssi&& from) noexcept
    : tag_rssi() {
    *this = ::std::move(from);
  }

  inline tag_rssi& operator=(tag_rssi&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tag_rssi& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const tag_rssi* internal_default_instance() {
    return reinterpret_cast<const tag_rssi*>(
               &_tag_rssi_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(tag_rssi* other);
  friend void swap(tag_rssi& a, tag_rssi& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline tag_rssi* New() const final {
    return CreateMaybeMessage<tag_rssi>(NULL);
  }

  tag_rssi* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<tag_rssi>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const tag_rssi& from);
  void MergeFrom(const tag_rssi& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(tag_rssi* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes payload = 9;
  bool has_payload() const;
  void clear_payload();
  static const int kPayloadFieldNumber = 9;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // optional .ce.nbapi.mac_address tag_mac = 1;
  bool has_tag_mac() const;
  void clear_tag_mac();
  static const int kTagMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_tag_mac() const;
  public:
  const ::ce::nbapi::mac_address& tag_mac() const;
  ::ce::nbapi::mac_address* release_tag_mac();
  ::ce::nbapi::mac_address* mutable_tag_mac();
  void set_allocated_tag_mac(::ce::nbapi::mac_address* tag_mac);

  // optional .ce.nbapi.mac_address radio_mac = 2;
  bool has_radio_mac() const;
  void clear_radio_mac();
  static const int kRadioMacFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_radio_mac() const;
  public:
  const ::ce::nbapi::mac_address& radio_mac() const;
  ::ce::nbapi::mac_address* release_radio_mac();
  ::ce::nbapi::mac_address* mutable_radio_mac();
  void set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac);

  // optional sint32 rssi_val = 3;
  bool has_rssi_val() const;
  void clear_rssi_val();
  static const int kRssiValFieldNumber = 3;
  ::google::protobuf::int32 rssi_val() const;
  void set_rssi_val(::google::protobuf::int32 value);

  // optional int32 noise_floor = 4;
  bool has_noise_floor() const;
  void clear_noise_floor();
  static const int kNoiseFloorFieldNumber = 4;
  ::google::protobuf::int32 noise_floor() const;
  void set_noise_floor(::google::protobuf::int32 value);

  // optional uint32 battery = 5;
  bool has_battery() const;
  void clear_battery();
  static const int kBatteryFieldNumber = 5;
  ::google::protobuf::uint32 battery() const;
  void set_battery(::google::protobuf::uint32 value);

  // optional uint32 channel = 6;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 6;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // optional uint32 tx_power = 7;
  bool has_tx_power() const;
  void clear_tx_power();
  static const int kTxPowerFieldNumber = 7;
  ::google::protobuf::uint32 tx_power() const;
  void set_tx_power(::google::protobuf::uint32 value);

  // optional uint32 data_rate = 8;
  bool has_data_rate() const;
  void clear_data_rate();
  static const int kDataRateFieldNumber = 8;
  ::google::protobuf::uint32 data_rate() const;
  void set_data_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.tag_rssi)
 private:
  void set_has_tag_mac();
  void clear_has_tag_mac();
  void set_has_radio_mac();
  void clear_has_radio_mac();
  void set_has_rssi_val();
  void clear_has_rssi_val();
  void set_has_noise_floor();
  void clear_has_noise_floor();
  void set_has_battery();
  void clear_has_battery();
  void set_has_channel();
  void clear_has_channel();
  void set_has_tx_power();
  void clear_has_tx_power();
  void set_has_data_rate();
  void clear_has_data_rate();
  void set_has_payload();
  void clear_has_payload();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  ::ce::nbapi::mac_address* tag_mac_;
  ::ce::nbapi::mac_address* radio_mac_;
  ::google::protobuf::int32 rssi_val_;
  ::google::protobuf::int32 noise_floor_;
  ::google::protobuf::uint32 battery_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::uint32 tx_power_;
  ::google::protobuf::uint32 data_rate_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ap_rssi : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.ap_rssi) */ {
 public:
  ap_rssi();
  virtual ~ap_rssi();

  ap_rssi(const ap_rssi& from);

  inline ap_rssi& operator=(const ap_rssi& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ap_rssi(ap_rssi&& from) noexcept
    : ap_rssi() {
    *this = ::std::move(from);
  }

  inline ap_rssi& operator=(ap_rssi&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ap_rssi& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ap_rssi* internal_default_instance() {
    return reinterpret_cast<const ap_rssi*>(
               &_ap_rssi_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ap_rssi* other);
  friend void swap(ap_rssi& a, ap_rssi& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ap_rssi* New() const final {
    return CreateMaybeMessage<ap_rssi>(NULL);
  }

  ap_rssi* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ap_rssi>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ap_rssi& from);
  void MergeFrom(const ap_rssi& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ap_rssi* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ssid = 3;
  bool has_ssid() const;
  void clear_ssid();
  static const int kSsidFieldNumber = 3;
  const ::std::string& ssid() const;
  void set_ssid(const ::std::string& value);
  #if LANG_CXX11
  void set_ssid(::std::string&& value);
  #endif
  void set_ssid(const char* value);
  void set_ssid(const char* value, size_t size);
  ::std::string* mutable_ssid();
  ::std::string* release_ssid();
  void set_allocated_ssid(::std::string* ssid);

  // optional .ce.nbapi.mac_address ap_eth_mac = 1;
  bool has_ap_eth_mac() const;
  void clear_ap_eth_mac();
  static const int kApEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_eth_mac() const;
  ::ce::nbapi::mac_address* release_ap_eth_mac();
  ::ce::nbapi::mac_address* mutable_ap_eth_mac();
  void set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac);

  // optional .ce.nbapi.mac_address neighbor_bssid = 2;
  bool has_neighbor_bssid() const;
  void clear_neighbor_bssid();
  static const int kNeighborBssidFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_neighbor_bssid() const;
  public:
  const ::ce::nbapi::mac_address& neighbor_bssid() const;
  ::ce::nbapi::mac_address* release_neighbor_bssid();
  ::ce::nbapi::mac_address* mutable_neighbor_bssid();
  void set_allocated_neighbor_bssid(::ce::nbapi::mac_address* neighbor_bssid);

  // optional .ce.nbapi.mac_address bssid = 10;
  bool has_bssid() const;
  void clear_bssid();
  static const int kBssidFieldNumber = 10;
  private:
  const ::ce::nbapi::mac_address& _internal_bssid() const;
  public:
  const ::ce::nbapi::mac_address& bssid() const;
  ::ce::nbapi::mac_address* release_bssid();
  ::ce::nbapi::mac_address* mutable_bssid();
  void set_allocated_bssid(::ce::nbapi::mac_address* bssid);

  // optional sint32 rssi_val = 4;
  bool has_rssi_val() const;
  void clear_rssi_val();
  static const int kRssiValFieldNumber = 4;
  ::google::protobuf::int32 rssi_val() const;
  void set_rssi_val(::google::protobuf::int32 value);

  // optional uint32 phy_type = 5;
  bool has_phy_type() const;
  void clear_phy_type();
  static const int kPhyTypeFieldNumber = 5;
  ::google::protobuf::uint32 phy_type() const;
  void set_phy_type(::google::protobuf::uint32 value);

  // optional uint32 ht_mode = 6;
  bool has_ht_mode() const;
  void clear_ht_mode();
  static const int kHtModeFieldNumber = 6;
  ::google::protobuf::uint32 ht_mode() const;
  void set_ht_mode(::google::protobuf::uint32 value);

  // optional uint32 channel = 7;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 7;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // optional int64 bw_rate = 9;
  bool has_bw_rate() const;
  void clear_bw_rate();
  static const int kBwRateFieldNumber = 9;
  ::google::protobuf::int64 bw_rate() const;
  void set_bw_rate(::google::protobuf::int64 value);

  // optional uint32 tx_power = 8;
  bool has_tx_power() const;
  void clear_tx_power();
  static const int kTxPowerFieldNumber = 8;
  ::google::protobuf::uint32 tx_power() const;
  void set_tx_power(::google::protobuf::uint32 value);

  // optional uint32 classification_type = 11;
  bool has_classification_type() const;
  void clear_classification_type();
  static const int kClassificationTypeFieldNumber = 11;
  ::google::protobuf::uint32 classification_type() const;
  void set_classification_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.ap_rssi)
 private:
  void set_has_ap_eth_mac();
  void clear_has_ap_eth_mac();
  void set_has_neighbor_bssid();
  void clear_has_neighbor_bssid();
  void set_has_ssid();
  void clear_has_ssid();
  void set_has_rssi_val();
  void clear_has_rssi_val();
  void set_has_phy_type();
  void clear_has_phy_type();
  void set_has_ht_mode();
  void clear_has_ht_mode();
  void set_has_channel();
  void clear_has_channel();
  void set_has_tx_power();
  void clear_has_tx_power();
  void set_has_bw_rate();
  void clear_has_bw_rate();
  void set_has_bssid();
  void clear_has_bssid();
  void set_has_classification_type();
  void clear_has_classification_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ssid_;
  ::ce::nbapi::mac_address* ap_eth_mac_;
  ::ce::nbapi::mac_address* neighbor_bssid_;
  ::ce::nbapi::mac_address* bssid_;
  ::google::protobuf::int32 rssi_val_;
  ::google::protobuf::uint32 phy_type_;
  ::google::protobuf::uint32 ht_mode_;
  ::google::protobuf::uint32 channel_;
  ::google::protobuf::int64 bw_rate_;
  ::google::protobuf::uint32 tx_power_;
  ::google::protobuf::uint32 classification_type_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class station : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.station) */ {
 public:
  station();
  virtual ~station();

  station(const station& from);

  inline station& operator=(const station& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  station(station&& from) noexcept
    : station() {
    *this = ::std::move(from);
  }

  inline station& operator=(station&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const station& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const station* internal_default_instance() {
    return reinterpret_cast<const station*>(
               &_station_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(station* other);
  friend void swap(station& a, station& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline station* New() const final {
    return CreateMaybeMessage<station>(NULL);
  }

  station* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<station>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const station& from);
  void MergeFrom(const station& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(station* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 2;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string role = 3;
  bool has_role() const;
  void clear_role();
  static const int kRoleFieldNumber = 3;
  const ::std::string& role() const;
  void set_role(const ::std::string& value);
  #if LANG_CXX11
  void set_role(::std::string&& value);
  #endif
  void set_role(const char* value);
  void set_role(const char* value, size_t size);
  ::std::string* mutable_role();
  ::std::string* release_role();
  void set_allocated_role(::std::string* role);

  // optional string device_type = 5;
  bool has_device_type() const;
  void clear_device_type();
  static const int kDeviceTypeFieldNumber = 5;
  const ::std::string& device_type() const;
  void set_device_type(const ::std::string& value);
  #if LANG_CXX11
  void set_device_type(::std::string&& value);
  #endif
  void set_device_type(const char* value);
  void set_device_type(const char* value, size_t size);
  ::std::string* mutable_device_type();
  ::std::string* release_device_type();
  void set_allocated_device_type(::std::string* device_type);

  // optional bytes hashed_sta_eth_mac = 7;
  bool has_hashed_sta_eth_mac() const;
  void clear_hashed_sta_eth_mac();
  static const int kHashedStaEthMacFieldNumber = 7;
  const ::std::string& hashed_sta_eth_mac() const;
  void set_hashed_sta_eth_mac(const ::std::string& value);
  #if LANG_CXX11
  void set_hashed_sta_eth_mac(::std::string&& value);
  #endif
  void set_hashed_sta_eth_mac(const char* value);
  void set_hashed_sta_eth_mac(const void* value, size_t size);
  ::std::string* mutable_hashed_sta_eth_mac();
  ::std::string* release_hashed_sta_eth_mac();
  void set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac);

  // optional bytes hashed_sta_ip_address = 8;
  bool has_hashed_sta_ip_address() const;
  void clear_hashed_sta_ip_address();
  static const int kHashedStaIpAddressFieldNumber = 8;
  const ::std::string& hashed_sta_ip_address() const;
  void set_hashed_sta_ip_address(const ::std::string& value);
  #if LANG_CXX11
  void set_hashed_sta_ip_address(::std::string&& value);
  #endif
  void set_hashed_sta_ip_address(const char* value);
  void set_hashed_sta_ip_address(const void* value, size_t size);
  ::std::string* mutable_hashed_sta_ip_address();
  ::std::string* release_hashed_sta_ip_address();
  void set_allocated_hashed_sta_ip_address(::std::string* hashed_sta_ip_address);

  // optional string ap_name = 11;
  bool has_ap_name() const;
  void clear_ap_name();
  static const int kApNameFieldNumber = 11;
  const ::std::string& ap_name() const;
  void set_ap_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ap_name(::std::string&& value);
  #endif
  void set_ap_name(const char* value);
  void set_ap_name(const char* value, size_t size);
  ::std::string* mutable_ap_name();
  ::std::string* release_ap_name();
  void set_allocated_ap_name(::std::string* ap_name);

  // optional .ce.nbapi.mac_address sta_eth_mac = 1;
  bool has_sta_eth_mac() const;
  void clear_sta_eth_mac();
  static const int kStaEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_sta_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& sta_eth_mac() const;
  ::ce::nbapi::mac_address* release_sta_eth_mac();
  ::ce::nbapi::mac_address* mutable_sta_eth_mac();
  void set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac);

  // optional .ce.nbapi.mac_address bssid = 4;
  bool has_bssid() const;
  void clear_bssid();
  static const int kBssidFieldNumber = 4;
  private:
  const ::ce::nbapi::mac_address& _internal_bssid() const;
  public:
  const ::ce::nbapi::mac_address& bssid() const;
  ::ce::nbapi::mac_address* release_bssid();
  ::ce::nbapi::mac_address* mutable_bssid();
  void set_allocated_bssid(::ce::nbapi::mac_address* bssid);

  // optional .ce.nbapi.ip_address sta_ip_address = 6;
  bool has_sta_ip_address() const;
  void clear_sta_ip_address();
  static const int kStaIpAddressFieldNumber = 6;
  private:
  const ::ce::nbapi::ip_address& _internal_sta_ip_address() const;
  public:
  const ::ce::nbapi::ip_address& sta_ip_address() const;
  ::ce::nbapi::ip_address* release_sta_ip_address();
  ::ce::nbapi::ip_address* mutable_sta_ip_address();
  void set_allocated_sta_ip_address(::ce::nbapi::ip_address* sta_ip_address);

  // optional uint32 vlan = 9;
  bool has_vlan() const;
  void clear_vlan();
  static const int kVlanFieldNumber = 9;
  ::google::protobuf::uint32 vlan() const;
  void set_vlan(::google::protobuf::uint32 value);

  // optional .ce.nbapi.ht_type ht = 10;
  bool has_ht() const;
  void clear_ht();
  static const int kHtFieldNumber = 10;
  ::ce::nbapi::ht_type ht() const;
  void set_ht(::ce::nbapi::ht_type value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.station)
 private:
  void set_has_sta_eth_mac();
  void clear_has_sta_eth_mac();
  void set_has_username();
  void clear_has_username();
  void set_has_role();
  void clear_has_role();
  void set_has_bssid();
  void clear_has_bssid();
  void set_has_device_type();
  void clear_has_device_type();
  void set_has_sta_ip_address();
  void clear_has_sta_ip_address();
  void set_has_hashed_sta_eth_mac();
  void clear_has_hashed_sta_eth_mac();
  void set_has_hashed_sta_ip_address();
  void clear_has_hashed_sta_ip_address();
  void set_has_vlan();
  void clear_has_vlan();
  void set_has_ht();
  void clear_has_ht();
  void set_has_ap_name();
  void clear_has_ap_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr role_;
  ::google::protobuf::internal::ArenaStringPtr device_type_;
  ::google::protobuf::internal::ArenaStringPtr hashed_sta_eth_mac_;
  ::google::protobuf::internal::ArenaStringPtr hashed_sta_ip_address_;
  ::google::protobuf::internal::ArenaStringPtr ap_name_;
  ::ce::nbapi::mac_address* sta_eth_mac_;
  ::ce::nbapi::mac_address* bssid_;
  ::ce::nbapi::ip_address* sta_ip_address_;
  ::google::protobuf::uint32 vlan_;
  int ht_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class access_point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.access_point) */ {
 public:
  access_point();
  virtual ~access_point();

  access_point(const access_point& from);

  inline access_point& operator=(const access_point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  access_point(access_point&& from) noexcept
    : access_point() {
    *this = ::std::move(from);
  }

  inline access_point& operator=(access_point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const access_point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const access_point* internal_default_instance() {
    return reinterpret_cast<const access_point*>(
               &_access_point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(access_point* other);
  friend void swap(access_point& a, access_point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline access_point* New() const final {
    return CreateMaybeMessage<access_point>(NULL);
  }

  access_point* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<access_point>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const access_point& from);
  void MergeFrom(const access_point& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(access_point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef access_point_deployment_mode deployment_mode;
  static const deployment_mode DEPLOYMENT_MODE_CAMPUS =
    access_point_deployment_mode_DEPLOYMENT_MODE_CAMPUS;
  static const deployment_mode DEPLOYMENT_MODE_REMOTE =
    access_point_deployment_mode_DEPLOYMENT_MODE_REMOTE;
  static inline bool deployment_mode_IsValid(int value) {
    return access_point_deployment_mode_IsValid(value);
  }
  static const deployment_mode deployment_mode_MIN =
    access_point_deployment_mode_deployment_mode_MIN;
  static const deployment_mode deployment_mode_MAX =
    access_point_deployment_mode_deployment_mode_MAX;
  static const int deployment_mode_ARRAYSIZE =
    access_point_deployment_mode_deployment_mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  deployment_mode_descriptor() {
    return access_point_deployment_mode_descriptor();
  }
  static inline const ::std::string& deployment_mode_Name(deployment_mode value) {
    return access_point_deployment_mode_Name(value);
  }
  static inline bool deployment_mode_Parse(const ::std::string& name,
      deployment_mode* value) {
    return access_point_deployment_mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .ce.nbapi.radio radios = 11;
  int radios_size() const;
  void clear_radios();
  static const int kRadiosFieldNumber = 11;
  ::ce::nbapi::radio* mutable_radios(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::radio >*
      mutable_radios();
  const ::ce::nbapi::radio& radios(int index) const;
  ::ce::nbapi::radio* add_radios();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::radio >&
      radios() const;

  // optional string ap_name = 2;
  bool has_ap_name() const;
  void clear_ap_name();
  static const int kApNameFieldNumber = 2;
  const ::std::string& ap_name() const;
  void set_ap_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ap_name(::std::string&& value);
  #endif
  void set_ap_name(const char* value);
  void set_ap_name(const char* value, size_t size);
  ::std::string* mutable_ap_name();
  ::std::string* release_ap_name();
  void set_allocated_ap_name(::std::string* ap_name);

  // optional string ap_group = 3;
  bool has_ap_group() const;
  void clear_ap_group();
  static const int kApGroupFieldNumber = 3;
  const ::std::string& ap_group() const;
  void set_ap_group(const ::std::string& value);
  #if LANG_CXX11
  void set_ap_group(::std::string&& value);
  #endif
  void set_ap_group(const char* value);
  void set_ap_group(const char* value, size_t size);
  ::std::string* mutable_ap_group();
  ::std::string* release_ap_group();
  void set_allocated_ap_group(::std::string* ap_group);

  // optional string ap_model = 4;
  bool has_ap_model() const;
  void clear_ap_model();
  static const int kApModelFieldNumber = 4;
  const ::std::string& ap_model() const;
  void set_ap_model(const ::std::string& value);
  #if LANG_CXX11
  void set_ap_model(::std::string&& value);
  #endif
  void set_ap_model(const char* value);
  void set_ap_model(const char* value, size_t size);
  ::std::string* mutable_ap_model();
  ::std::string* release_ap_model();
  void set_allocated_ap_model(::std::string* ap_model);

  // optional string managed_by_key = 10;
  bool has_managed_by_key() const;
  void clear_managed_by_key();
  static const int kManagedByKeyFieldNumber = 10;
  const ::std::string& managed_by_key() const;
  void set_managed_by_key(const ::std::string& value);
  #if LANG_CXX11
  void set_managed_by_key(::std::string&& value);
  #endif
  void set_managed_by_key(const char* value);
  void set_managed_by_key(const char* value, size_t size);
  ::std::string* mutable_managed_by_key();
  ::std::string* release_managed_by_key();
  void set_allocated_managed_by_key(::std::string* managed_by_key);

  // optional string reboot_reason = 13;
  bool has_reboot_reason() const;
  void clear_reboot_reason();
  static const int kRebootReasonFieldNumber = 13;
  const ::std::string& reboot_reason() const;
  void set_reboot_reason(const ::std::string& value);
  #if LANG_CXX11
  void set_reboot_reason(::std::string&& value);
  #endif
  void set_reboot_reason(const char* value);
  void set_reboot_reason(const char* value, size_t size);
  ::std::string* mutable_reboot_reason();
  ::std::string* release_reboot_reason();
  void set_allocated_reboot_reason(::std::string* reboot_reason);

  // required .ce.nbapi.mac_address ap_eth_mac = 1;
  bool has_ap_eth_mac() const;
  void clear_ap_eth_mac();
  static const int kApEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_eth_mac() const;
  ::ce::nbapi::mac_address* release_ap_eth_mac();
  ::ce::nbapi::mac_address* mutable_ap_eth_mac();
  void set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac);

  // optional .ce.nbapi.ip_address ap_ip_address = 6;
  bool has_ap_ip_address() const;
  void clear_ap_ip_address();
  static const int kApIpAddressFieldNumber = 6;
  private:
  const ::ce::nbapi::ip_address& _internal_ap_ip_address() const;
  public:
  const ::ce::nbapi::ip_address& ap_ip_address() const;
  ::ce::nbapi::ip_address* release_ap_ip_address();
  ::ce::nbapi::ip_address* mutable_ap_ip_address();
  void set_allocated_ap_ip_address(::ce::nbapi::ip_address* ap_ip_address);

  // optional .ce.nbapi.ip_address managed_by = 9;
  bool has_managed_by() const;
  void clear_managed_by();
  static const int kManagedByFieldNumber = 9;
  private:
  const ::ce::nbapi::ip_address& _internal_managed_by() const;
  public:
  const ::ce::nbapi::ip_address& managed_by() const;
  ::ce::nbapi::ip_address* release_managed_by();
  ::ce::nbapi::ip_address* mutable_managed_by();
  void set_allocated_managed_by(::ce::nbapi::ip_address* managed_by);

  // optional .ce.nbapi.ap_location ap_location = 14;
  bool has_ap_location() const;
  void clear_ap_location();
  static const int kApLocationFieldNumber = 14;
  private:
  const ::ce::nbapi::ap_location& _internal_ap_location() const;
  public:
  const ::ce::nbapi::ap_location& ap_location() const;
  ::ce::nbapi::ap_location* release_ap_location();
  ::ce::nbapi::ap_location* mutable_ap_location();
  void set_allocated_ap_location(::ce::nbapi::ap_location* ap_location);

  // optional .ce.nbapi.access_point.deployment_mode depl_mode = 5;
  bool has_depl_mode() const;
  void clear_depl_mode();
  static const int kDeplModeFieldNumber = 5;
  ::ce::nbapi::access_point_deployment_mode depl_mode() const;
  void set_depl_mode(::ce::nbapi::access_point_deployment_mode value);

  // optional uint32 reboots = 7;
  bool has_reboots() const;
  void clear_reboots();
  static const int kRebootsFieldNumber = 7;
  ::google::protobuf::uint32 reboots() const;
  void set_reboots(::google::protobuf::uint32 value);

  // optional uint32 rebootstraps = 8;
  bool has_rebootstraps() const;
  void clear_rebootstraps();
  static const int kRebootstrapsFieldNumber = 8;
  ::google::protobuf::uint32 rebootstraps() const;
  void set_rebootstraps(::google::protobuf::uint32 value);

  // optional bool is_master = 12 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_is_master() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_is_master();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kIsMasterFieldNumber = 12;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool is_master() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_is_master(bool value);

  // optional bool is_conductor = 15;
  bool has_is_conductor() const;
  void clear_is_conductor();
  static const int kIsConductorFieldNumber = 15;
  bool is_conductor() const;
  void set_is_conductor(bool value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.access_point)
 private:
  void set_has_ap_eth_mac();
  void clear_has_ap_eth_mac();
  void set_has_ap_name();
  void clear_has_ap_name();
  void set_has_ap_group();
  void clear_has_ap_group();
  void set_has_ap_model();
  void clear_has_ap_model();
  void set_has_depl_mode();
  void clear_has_depl_mode();
  void set_has_ap_ip_address();
  void clear_has_ap_ip_address();
  void set_has_reboots();
  void clear_has_reboots();
  void set_has_rebootstraps();
  void clear_has_rebootstraps();
  void set_has_managed_by();
  void clear_has_managed_by();
  void set_has_managed_by_key();
  void clear_has_managed_by_key();
  void set_has_is_master();
  void clear_has_is_master();
  void set_has_reboot_reason();
  void clear_has_reboot_reason();
  void set_has_ap_location();
  void clear_has_ap_location();
  void set_has_is_conductor();
  void clear_has_is_conductor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::radio > radios_;
  ::google::protobuf::internal::ArenaStringPtr ap_name_;
  ::google::protobuf::internal::ArenaStringPtr ap_group_;
  ::google::protobuf::internal::ArenaStringPtr ap_model_;
  ::google::protobuf::internal::ArenaStringPtr managed_by_key_;
  ::google::protobuf::internal::ArenaStringPtr reboot_reason_;
  ::ce::nbapi::mac_address* ap_eth_mac_;
  ::ce::nbapi::ip_address* ap_ip_address_;
  ::ce::nbapi::ip_address* managed_by_;
  ::ce::nbapi::ap_location* ap_location_;
  int depl_mode_;
  ::google::protobuf::uint32 reboots_;
  ::google::protobuf::uint32 rebootstraps_;
  bool is_master_;
  bool is_conductor_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class state_access_point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.state_access_point) */ {
 public:
  state_access_point();
  virtual ~state_access_point();

  state_access_point(const state_access_point& from);

  inline state_access_point& operator=(const state_access_point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  state_access_point(state_access_point&& from) noexcept
    : state_access_point() {
    *this = ::std::move(from);
  }

  inline state_access_point& operator=(state_access_point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const state_access_point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const state_access_point* internal_default_instance() {
    return reinterpret_cast<const state_access_point*>(
               &_state_access_point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(state_access_point* other);
  friend void swap(state_access_point& a, state_access_point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline state_access_point* New() const final {
    return CreateMaybeMessage<state_access_point>(NULL);
  }

  state_access_point* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<state_access_point>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const state_access_point& from);
  void MergeFrom(const state_access_point& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(state_access_point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string serial_number = 2;
  bool has_serial_number() const;
  void clear_serial_number();
  static const int kSerialNumberFieldNumber = 2;
  const ::std::string& serial_number() const;
  void set_serial_number(const ::std::string& value);
  #if LANG_CXX11
  void set_serial_number(::std::string&& value);
  #endif
  void set_serial_number(const char* value);
  void set_serial_number(const char* value, size_t size);
  ::std::string* mutable_serial_number();
  ::std::string* release_serial_number();
  void set_allocated_serial_number(::std::string* serial_number);

  // optional string ap_name = 3;
  bool has_ap_name() const;
  void clear_ap_name();
  static const int kApNameFieldNumber = 3;
  const ::std::string& ap_name() const;
  void set_ap_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ap_name(::std::string&& value);
  #endif
  void set_ap_name(const char* value);
  void set_ap_name(const char* value, size_t size);
  ::std::string* mutable_ap_name();
  ::std::string* release_ap_name();
  void set_allocated_ap_name(::std::string* ap_name);

  // optional string model = 4;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 4;
  const ::std::string& model() const;
  void set_model(const ::std::string& value);
  #if LANG_CXX11
  void set_model(::std::string&& value);
  #endif
  void set_model(const char* value);
  void set_model(const char* value, size_t size);
  ::std::string* mutable_model();
  ::std::string* release_model();
  void set_allocated_model(::std::string* model);

  // optional string mode = 5;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 5;
  const ::std::string& mode() const;
  void set_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_mode(::std::string&& value);
  #endif
  void set_mode(const char* value);
  void set_mode(const char* value, size_t size);
  ::std::string* mutable_mode();
  ::std::string* release_mode();
  void set_allocated_mode(::std::string* mode);

  // optional string service_tag = 17;
  bool has_service_tag() const;
  void clear_service_tag();
  static const int kServiceTagFieldNumber = 17;
  const ::std::string& service_tag() const;
  void set_service_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_service_tag(::std::string&& value);
  #endif
  void set_service_tag(const char* value);
  void set_service_tag(const char* value, size_t size);
  ::std::string* mutable_service_tag();
  ::std::string* release_service_tag();
  void set_allocated_service_tag(::std::string* service_tag);

  // optional .ce.nbapi.mac_address ap_mac = 1;
  bool has_ap_mac() const;
  void clear_ap_mac();
  static const int kApMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_mac() const;
  ::ce::nbapi::mac_address* release_ap_mac();
  ::ce::nbapi::mac_address* mutable_ap_mac();
  void set_allocated_ap_mac(::ce::nbapi::mac_address* ap_mac);

  // optional .ce.nbapi.ip_address ap_ip = 6;
  bool has_ap_ip() const;
  void clear_ap_ip();
  static const int kApIpFieldNumber = 6;
  private:
  const ::ce::nbapi::ip_address& _internal_ap_ip() const;
  public:
  const ::ce::nbapi::ip_address& ap_ip() const;
  ::ce::nbapi::ip_address* release_ap_ip();
  ::ce::nbapi::ip_address* mutable_ap_ip();
  void set_allocated_ap_ip(::ce::nbapi::ip_address* ap_ip);

  // optional uint32 cpu_usage = 7;
  bool has_cpu_usage() const;
  void clear_cpu_usage();
  static const int kCpuUsageFieldNumber = 7;
  ::google::protobuf::uint32 cpu_usage() const;
  void set_cpu_usage(::google::protobuf::uint32 value);

  // optional uint32 memory_total = 8;
  bool has_memory_total() const;
  void clear_memory_total();
  static const int kMemoryTotalFieldNumber = 8;
  ::google::protobuf::uint32 memory_total() const;
  void set_memory_total(::google::protobuf::uint32 value);

  // optional uint32 memory_free = 9;
  bool has_memory_free() const;
  void clear_memory_free();
  static const int kMemoryFreeFieldNumber = 9;
  ::google::protobuf::uint32 memory_free() const;
  void set_memory_free(::google::protobuf::uint32 value);

  // optional uint32 is_master = 10 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR bool has_is_master() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_is_master();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kIsMasterFieldNumber = 10;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::uint32 is_master() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void set_is_master(::google::protobuf::uint32 value);

  // optional uint32 uptime = 11;
  bool has_uptime() const;
  void clear_uptime();
  static const int kUptimeFieldNumber = 11;
  ::google::protobuf::uint32 uptime() const;
  void set_uptime(::google::protobuf::uint32 value);

  // optional uint32 mesh_mode = 12;
  bool has_mesh_mode() const;
  void clear_mesh_mode();
  static const int kMeshModeFieldNumber = 12;
  ::google::protobuf::uint32 mesh_mode() const;
  void set_mesh_mode(::google::protobuf::uint32 value);

  // optional uint32 led_status = 13;
  bool has_led_status() const;
  void clear_led_status();
  static const int kLedStatusFieldNumber = 13;
  ::google::protobuf::uint32 led_status() const;
  void set_led_status(::google::protobuf::uint32 value);

  // optional uint32 ext_ssid_state = 16;
  bool has_ext_ssid_state() const;
  void clear_ext_ssid_state();
  static const int kExtSsidStateFieldNumber = 16;
  ::google::protobuf::uint32 ext_ssid_state() const;
  void set_ext_ssid_state(::google::protobuf::uint32 value);

  // optional uint32 modem_status = 18;
  bool has_modem_status() const;
  void clear_modem_status();
  static const int kModemStatusFieldNumber = 18;
  ::google::protobuf::uint32 modem_status() const;
  void set_modem_status(::google::protobuf::uint32 value);

  // optional uint32 modem_simpin_status = 19;
  bool has_modem_simpin_status() const;
  void clear_modem_simpin_status();
  static const int kModemSimpinStatusFieldNumber = 19;
  ::google::protobuf::uint32 modem_simpin_status() const;
  void set_modem_simpin_status(::google::protobuf::uint32 value);

  // optional uint32 current_uplink_inuse = 20;
  bool has_current_uplink_inuse() const;
  void clear_current_uplink_inuse();
  static const int kCurrentUplinkInuseFieldNumber = 20;
  ::google::protobuf::uint32 current_uplink_inuse() const;
  void set_current_uplink_inuse(::google::protobuf::uint32 value);

  // optional uint32 is_conductor = 21;
  bool has_is_conductor() const;
  void clear_is_conductor();
  static const int kIsConductorFieldNumber = 21;
  ::google::protobuf::uint32 is_conductor() const;
  void set_is_conductor(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.state_access_point)
 private:
  void set_has_ap_mac();
  void clear_has_ap_mac();
  void set_has_serial_number();
  void clear_has_serial_number();
  void set_has_ap_name();
  void clear_has_ap_name();
  void set_has_model();
  void clear_has_model();
  void set_has_mode();
  void clear_has_mode();
  void set_has_ap_ip();
  void clear_has_ap_ip();
  void set_has_cpu_usage();
  void clear_has_cpu_usage();
  void set_has_memory_total();
  void clear_has_memory_total();
  void set_has_memory_free();
  void clear_has_memory_free();
  void set_has_is_master();
  void clear_has_is_master();
  void set_has_uptime();
  void clear_has_uptime();
  void set_has_mesh_mode();
  void clear_has_mesh_mode();
  void set_has_led_status();
  void clear_has_led_status();
  void set_has_ext_ssid_state();
  void clear_has_ext_ssid_state();
  void set_has_service_tag();
  void clear_has_service_tag();
  void set_has_modem_status();
  void clear_has_modem_status();
  void set_has_modem_simpin_status();
  void clear_has_modem_simpin_status();
  void set_has_current_uplink_inuse();
  void clear_has_current_uplink_inuse();
  void set_has_is_conductor();
  void clear_has_is_conductor();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr serial_number_;
  ::google::protobuf::internal::ArenaStringPtr ap_name_;
  ::google::protobuf::internal::ArenaStringPtr model_;
  ::google::protobuf::internal::ArenaStringPtr mode_;
  ::google::protobuf::internal::ArenaStringPtr service_tag_;
  ::ce::nbapi::mac_address* ap_mac_;
  ::ce::nbapi::ip_address* ap_ip_;
  ::google::protobuf::uint32 cpu_usage_;
  ::google::protobuf::uint32 memory_total_;
  ::google::protobuf::uint32 memory_free_;
  ::google::protobuf::uint32 is_master_;
  ::google::protobuf::uint32 uptime_;
  ::google::protobuf::uint32 mesh_mode_;
  ::google::protobuf::uint32 led_status_;
  ::google::protobuf::uint32 ext_ssid_state_;
  ::google::protobuf::uint32 modem_status_;
  ::google::protobuf::uint32 modem_simpin_status_;
  ::google::protobuf::uint32 current_uplink_inuse_;
  ::google::protobuf::uint32 is_conductor_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class stats_modem : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.stats_modem) */ {
 public:
  stats_modem();
  virtual ~stats_modem();

  stats_modem(const stats_modem& from);

  inline stats_modem& operator=(const stats_modem& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  stats_modem(stats_modem&& from) noexcept
    : stats_modem() {
    *this = ::std::move(from);
  }

  inline stats_modem& operator=(stats_modem&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stats_modem& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const stats_modem* internal_default_instance() {
    return reinterpret_cast<const stats_modem*>(
               &_stats_modem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(stats_modem* other);
  friend void swap(stats_modem& a, stats_modem& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline stats_modem* New() const final {
    return CreateMaybeMessage<stats_modem>(NULL);
  }

  stats_modem* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<stats_modem>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const stats_modem& from);
  void MergeFrom(const stats_modem& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(stats_modem* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address iap_mac = 1;
  bool has_iap_mac() const;
  void clear_iap_mac();
  static const int kIapMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_iap_mac() const;
  public:
  const ::ce::nbapi::mac_address& iap_mac() const;
  ::ce::nbapi::mac_address* release_iap_mac();
  ::ce::nbapi::mac_address* mutable_iap_mac();
  void set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac);

  // optional uint64 tx_data_bytes = 2;
  bool has_tx_data_bytes() const;
  void clear_tx_data_bytes();
  static const int kTxDataBytesFieldNumber = 2;
  ::google::protobuf::uint64 tx_data_bytes() const;
  void set_tx_data_bytes(::google::protobuf::uint64 value);

  // optional uint64 rx_data_bytes = 3;
  bool has_rx_data_bytes() const;
  void clear_rx_data_bytes();
  static const int kRxDataBytesFieldNumber = 3;
  ::google::protobuf::uint64 rx_data_bytes() const;
  void set_rx_data_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.stats_modem)
 private:
  void set_has_iap_mac();
  void clear_has_iap_mac();
  void set_has_tx_data_bytes();
  void clear_has_tx_data_bytes();
  void set_has_rx_data_bytes();
  void clear_has_rx_data_bytes();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* iap_mac_;
  ::google::protobuf::uint64 tx_data_bytes_;
  ::google::protobuf::uint64 rx_data_bytes_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class radio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.radio) */ {
 public:
  radio();
  virtual ~radio();

  radio(const radio& from);

  inline radio& operator=(const radio& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  radio(radio&& from) noexcept
    : radio() {
    *this = ::std::move(from);
  }

  inline radio& operator=(radio&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const radio& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const radio* internal_default_instance() {
    return reinterpret_cast<const radio*>(
               &_radio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(radio* other);
  friend void swap(radio& a, radio& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline radio* New() const final {
    return CreateMaybeMessage<radio>(NULL);
  }

  radio* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<radio>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const radio& from);
  void MergeFrom(const radio& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(radio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef radio_radio_mode radio_mode;
  static const radio_mode RADIO_MODE_AP =
    radio_radio_mode_RADIO_MODE_AP;
  static const radio_mode RADIO_MODE_MESH_PORTAL =
    radio_radio_mode_RADIO_MODE_MESH_PORTAL;
  static const radio_mode RADIO_MODE_MESH_POINT =
    radio_radio_mode_RADIO_MODE_MESH_POINT;
  static const radio_mode RADIO_MODE_AIR_MONITOR =
    radio_radio_mode_RADIO_MODE_AIR_MONITOR;
  static const radio_mode RADIO_MODE_SPECTRUM_SENSOR =
    radio_radio_mode_RADIO_MODE_SPECTRUM_SENSOR;
  static const radio_mode RADIO_MODE_UNKNOWN =
    radio_radio_mode_RADIO_MODE_UNKNOWN;
  static inline bool radio_mode_IsValid(int value) {
    return radio_radio_mode_IsValid(value);
  }
  static const radio_mode radio_mode_MIN =
    radio_radio_mode_radio_mode_MIN;
  static const radio_mode radio_mode_MAX =
    radio_radio_mode_radio_mode_MAX;
  static const int radio_mode_ARRAYSIZE =
    radio_radio_mode_radio_mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  radio_mode_descriptor() {
    return radio_radio_mode_descriptor();
  }
  static inline const ::std::string& radio_mode_Name(radio_mode value) {
    return radio_radio_mode_Name(value);
  }
  static inline bool radio_mode_Parse(const ::std::string& name,
      radio_mode* value) {
    return radio_radio_mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .ce.nbapi.virtual_access_point virtual_access_points = 7;
  int virtual_access_points_size() const;
  void clear_virtual_access_points();
  static const int kVirtualAccessPointsFieldNumber = 7;
  ::ce::nbapi::virtual_access_point* mutable_virtual_access_points(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::virtual_access_point >*
      mutable_virtual_access_points();
  const ::ce::nbapi::virtual_access_point& virtual_access_points(int index) const;
  ::ce::nbapi::virtual_access_point* add_virtual_access_points();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::virtual_access_point >&
      virtual_access_points() const;

  // optional .ce.nbapi.mac_address ap_eth_mac = 1;
  bool has_ap_eth_mac() const;
  void clear_ap_eth_mac();
  static const int kApEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_eth_mac() const;
  ::ce::nbapi::mac_address* release_ap_eth_mac();
  ::ce::nbapi::mac_address* mutable_ap_eth_mac();
  void set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac);

  // required .ce.nbapi.mac_address radio_bssid = 2;
  bool has_radio_bssid() const;
  void clear_radio_bssid();
  static const int kRadioBssidFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_radio_bssid() const;
  public:
  const ::ce::nbapi::mac_address& radio_bssid() const;
  ::ce::nbapi::mac_address* release_radio_bssid();
  ::ce::nbapi::mac_address* mutable_radio_bssid();
  void set_allocated_radio_bssid(::ce::nbapi::mac_address* radio_bssid);

  // optional .ce.nbapi.radio.radio_mode mode = 4;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 4;
  ::ce::nbapi::radio_radio_mode mode() const;
  void set_mode(::ce::nbapi::radio_radio_mode value);

  // optional .ce.nbapi.phy_type phy = 5;
  bool has_phy() const;
  void clear_phy();
  static const int kPhyFieldNumber = 5;
  ::ce::nbapi::phy_type phy() const;
  void set_phy(::ce::nbapi::phy_type value);

  // optional .ce.nbapi.ht_type ht = 6;
  bool has_ht() const;
  void clear_ht();
  static const int kHtFieldNumber = 6;
  ::ce::nbapi::ht_type ht() const;
  void set_ht(::ce::nbapi::ht_type value);

  // optional uint32 radio_num = 8;
  bool has_radio_num() const;
  void clear_radio_num();
  static const int kRadioNumFieldNumber = 8;
  ::google::protobuf::uint32 radio_num() const;
  void set_radio_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.radio)
 private:
  void set_has_ap_eth_mac();
  void clear_has_ap_eth_mac();
  void set_has_radio_bssid();
  void clear_has_radio_bssid();
  void set_has_mode();
  void clear_has_mode();
  void set_has_phy();
  void clear_has_phy();
  void set_has_ht();
  void clear_has_ht();
  void set_has_radio_num();
  void clear_has_radio_num();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::virtual_access_point > virtual_access_points_;
  ::ce::nbapi::mac_address* ap_eth_mac_;
  ::ce::nbapi::mac_address* radio_bssid_;
  int mode_;
  int phy_;
  int ht_;
  ::google::protobuf::uint32 radio_num_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class virtual_access_point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.virtual_access_point) */ {
 public:
  virtual_access_point();
  virtual ~virtual_access_point();

  virtual_access_point(const virtual_access_point& from);

  inline virtual_access_point& operator=(const virtual_access_point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  virtual_access_point(virtual_access_point&& from) noexcept
    : virtual_access_point() {
    *this = ::std::move(from);
  }

  inline virtual_access_point& operator=(virtual_access_point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const virtual_access_point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const virtual_access_point* internal_default_instance() {
    return reinterpret_cast<const virtual_access_point*>(
               &_virtual_access_point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(virtual_access_point* other);
  friend void swap(virtual_access_point& a, virtual_access_point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline virtual_access_point* New() const final {
    return CreateMaybeMessage<virtual_access_point>(NULL);
  }

  virtual_access_point* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<virtual_access_point>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const virtual_access_point& from);
  void MergeFrom(const virtual_access_point& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(virtual_access_point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ssid = 2;
  bool has_ssid() const;
  void clear_ssid();
  static const int kSsidFieldNumber = 2;
  const ::std::string& ssid() const;
  void set_ssid(const ::std::string& value);
  #if LANG_CXX11
  void set_ssid(::std::string&& value);
  #endif
  void set_ssid(const char* value);
  void set_ssid(const char* value, size_t size);
  ::std::string* mutable_ssid();
  ::std::string* release_ssid();
  void set_allocated_ssid(::std::string* ssid);

  // required .ce.nbapi.mac_address bssid = 1;
  bool has_bssid() const;
  void clear_bssid();
  static const int kBssidFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_bssid() const;
  public:
  const ::ce::nbapi::mac_address& bssid() const;
  ::ce::nbapi::mac_address* release_bssid();
  ::ce::nbapi::mac_address* mutable_bssid();
  void set_allocated_bssid(::ce::nbapi::mac_address* bssid);

  // optional .ce.nbapi.mac_address radio_bssid = 3;
  bool has_radio_bssid() const;
  void clear_radio_bssid();
  static const int kRadioBssidFieldNumber = 3;
  private:
  const ::ce::nbapi::mac_address& _internal_radio_bssid() const;
  public:
  const ::ce::nbapi::mac_address& radio_bssid() const;
  ::ce::nbapi::mac_address* release_radio_bssid();
  ::ce::nbapi::mac_address* mutable_radio_bssid();
  void set_allocated_radio_bssid(::ce::nbapi::mac_address* radio_bssid);

  // @@protoc_insertion_point(class_scope:ce.nbapi.virtual_access_point)
 private:
  void set_has_bssid();
  void clear_has_bssid();
  void set_has_ssid();
  void clear_has_ssid();
  void set_has_radio_bssid();
  void clear_has_radio_bssid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ssid_;
  ::ce::nbapi::mac_address* bssid_;
  ::ce::nbapi::mac_address* radio_bssid_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class destination : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.destination) */ {
 public:
  destination();
  virtual ~destination();

  destination(const destination& from);

  inline destination& operator=(const destination& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  destination(destination&& from) noexcept
    : destination() {
    *this = ::std::move(from);
  }

  inline destination& operator=(destination&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const destination& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const destination* internal_default_instance() {
    return reinterpret_cast<const destination*>(
               &_destination_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(destination* other);
  friend void swap(destination& a, destination& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline destination* New() const final {
    return CreateMaybeMessage<destination>(NULL);
  }

  destination* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<destination>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const destination& from);
  void MergeFrom(const destination& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(destination* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dest_name = 2;
  bool has_dest_name() const;
  void clear_dest_name();
  static const int kDestNameFieldNumber = 2;
  const ::std::string& dest_name() const;
  void set_dest_name(const ::std::string& value);
  #if LANG_CXX11
  void set_dest_name(::std::string&& value);
  #endif
  void set_dest_name(const char* value);
  void set_dest_name(const char* value, size_t size);
  ::std::string* mutable_dest_name();
  ::std::string* release_dest_name();
  void set_allocated_dest_name(::std::string* dest_name);

  // optional string dest_alias_name = 3;
  bool has_dest_alias_name() const;
  void clear_dest_alias_name();
  static const int kDestAliasNameFieldNumber = 3;
  const ::std::string& dest_alias_name() const;
  void set_dest_alias_name(const ::std::string& value);
  #if LANG_CXX11
  void set_dest_alias_name(::std::string&& value);
  #endif
  void set_dest_alias_name(const char* value);
  void set_dest_alias_name(const char* value, size_t size);
  ::std::string* mutable_dest_alias_name();
  ::std::string* release_dest_alias_name();
  void set_allocated_dest_alias_name(::std::string* dest_alias_name);

  // optional .ce.nbapi.ip_address dest_ip = 1;
  bool has_dest_ip() const;
  void clear_dest_ip();
  static const int kDestIpFieldNumber = 1;
  private:
  const ::ce::nbapi::ip_address& _internal_dest_ip() const;
  public:
  const ::ce::nbapi::ip_address& dest_ip() const;
  ::ce::nbapi::ip_address* release_dest_ip();
  ::ce::nbapi::ip_address* mutable_dest_ip();
  void set_allocated_dest_ip(::ce::nbapi::ip_address* dest_ip);

  // @@protoc_insertion_point(class_scope:ce.nbapi.destination)
 private:
  void set_has_dest_ip();
  void clear_has_dest_ip();
  void set_has_dest_name();
  void clear_has_dest_name();
  void set_has_dest_alias_name();
  void clear_has_dest_alias_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr dest_name_;
  ::google::protobuf::internal::ArenaStringPtr dest_alias_name_;
  ::ce::nbapi::ip_address* dest_ip_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class application : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.application) */ {
 public:
  application();
  virtual ~application();

  application(const application& from);

  inline application& operator=(const application& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  application(application&& from) noexcept
    : application() {
    *this = ::std::move(from);
  }

  inline application& operator=(application&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const application& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const application* internal_default_instance() {
    return reinterpret_cast<const application*>(
               &_application_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(application* other);
  friend void swap(application& a, application& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline application* New() const final {
    return CreateMaybeMessage<application>(NULL);
  }

  application* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<application>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const application& from);
  void MergeFrom(const application& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(application* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string app_name = 2;
  bool has_app_name() const;
  void clear_app_name();
  static const int kAppNameFieldNumber = 2;
  const ::std::string& app_name() const;
  void set_app_name(const ::std::string& value);
  #if LANG_CXX11
  void set_app_name(::std::string&& value);
  #endif
  void set_app_name(const char* value);
  void set_app_name(const char* value, size_t size);
  ::std::string* mutable_app_name();
  ::std::string* release_app_name();
  void set_allocated_app_name(::std::string* app_name);

  // optional string app_family = 3;
  bool has_app_family() const;
  void clear_app_family();
  static const int kAppFamilyFieldNumber = 3;
  const ::std::string& app_family() const;
  void set_app_family(const ::std::string& value);
  #if LANG_CXX11
  void set_app_family(::std::string&& value);
  #endif
  void set_app_family(const char* value);
  void set_app_family(const char* value, size_t size);
  ::std::string* mutable_app_family();
  ::std::string* release_app_family();
  void set_allocated_app_family(::std::string* app_family);

  // optional string app_long_name = 4;
  bool has_app_long_name() const;
  void clear_app_long_name();
  static const int kAppLongNameFieldNumber = 4;
  const ::std::string& app_long_name() const;
  void set_app_long_name(const ::std::string& value);
  #if LANG_CXX11
  void set_app_long_name(::std::string&& value);
  #endif
  void set_app_long_name(const char* value);
  void set_app_long_name(const char* value, size_t size);
  ::std::string* mutable_app_long_name();
  ::std::string* release_app_long_name();
  void set_allocated_app_long_name(::std::string* app_long_name);

  // optional uint32 app_id = 1;
  bool has_app_id() const;
  void clear_app_id();
  static const int kAppIdFieldNumber = 1;
  ::google::protobuf::uint32 app_id() const;
  void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.application)
 private:
  void set_has_app_id();
  void clear_has_app_id();
  void set_has_app_name();
  void clear_has_app_name();
  void set_has_app_family();
  void clear_has_app_family();
  void set_has_app_long_name();
  void clear_has_app_long_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr app_name_;
  ::google::protobuf::internal::ArenaStringPtr app_family_;
  ::google::protobuf::internal::ArenaStringPtr app_long_name_;
  ::google::protobuf::uint32 app_id_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class webcc_category : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.webcc_category) */ {
 public:
  webcc_category();
  virtual ~webcc_category();

  webcc_category(const webcc_category& from);

  inline webcc_category& operator=(const webcc_category& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  webcc_category(webcc_category&& from) noexcept
    : webcc_category() {
    *this = ::std::move(from);
  }

  inline webcc_category& operator=(webcc_category&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const webcc_category& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const webcc_category* internal_default_instance() {
    return reinterpret_cast<const webcc_category*>(
               &_webcc_category_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(webcc_category* other);
  friend void swap(webcc_category& a, webcc_category& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline webcc_category* New() const final {
    return CreateMaybeMessage<webcc_category>(NULL);
  }

  webcc_category* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<webcc_category>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const webcc_category& from);
  void MergeFrom(const webcc_category& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(webcc_category* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string category = 2;
  bool has_category() const;
  void clear_category();
  static const int kCategoryFieldNumber = 2;
  const ::std::string& category() const;
  void set_category(const ::std::string& value);
  #if LANG_CXX11
  void set_category(::std::string&& value);
  #endif
  void set_category(const char* value);
  void set_category(const char* value, size_t size);
  ::std::string* mutable_category();
  ::std::string* release_category();
  void set_allocated_category(::std::string* category);

  // optional uint32 cat_id = 1;
  bool has_cat_id() const;
  void clear_cat_id();
  static const int kCatIdFieldNumber = 1;
  ::google::protobuf::uint32 cat_id() const;
  void set_cat_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.webcc_category)
 private:
  void set_has_cat_id();
  void clear_has_cat_id();
  void set_has_category();
  void clear_has_category();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr category_;
  ::google::protobuf::uint32 cat_id_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class webcc_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.webcc_info) */ {
 public:
  webcc_info();
  virtual ~webcc_info();

  webcc_info(const webcc_info& from);

  inline webcc_info& operator=(const webcc_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  webcc_info(webcc_info&& from) noexcept
    : webcc_info() {
    *this = ::std::move(from);
  }

  inline webcc_info& operator=(webcc_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const webcc_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const webcc_info* internal_default_instance() {
    return reinterpret_cast<const webcc_info*>(
               &_webcc_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(webcc_info* other);
  friend void swap(webcc_info& a, webcc_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline webcc_info* New() const final {
    return CreateMaybeMessage<webcc_info>(NULL);
  }

  webcc_info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<webcc_info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const webcc_info& from);
  void MergeFrom(const webcc_info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(webcc_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes webcc_md5 = 1;
  bool has_webcc_md5() const;
  void clear_webcc_md5();
  static const int kWebccMd5FieldNumber = 1;
  const ::std::string& webcc_md5() const;
  void set_webcc_md5(const ::std::string& value);
  #if LANG_CXX11
  void set_webcc_md5(::std::string&& value);
  #endif
  void set_webcc_md5(const char* value);
  void set_webcc_md5(const void* value, size_t size);
  ::std::string* mutable_webcc_md5();
  ::std::string* release_webcc_md5();
  void set_allocated_webcc_md5(::std::string* webcc_md5);

  // optional string webcc_url_prefix = 4;
  bool has_webcc_url_prefix() const;
  void clear_webcc_url_prefix();
  static const int kWebccUrlPrefixFieldNumber = 4;
  const ::std::string& webcc_url_prefix() const;
  void set_webcc_url_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_webcc_url_prefix(::std::string&& value);
  #endif
  void set_webcc_url_prefix(const char* value);
  void set_webcc_url_prefix(const char* value, size_t size);
  ::std::string* mutable_webcc_url_prefix();
  ::std::string* release_webcc_url_prefix();
  void set_allocated_webcc_url_prefix(::std::string* webcc_url_prefix);

  // optional uint32 webcc_cat_id = 2;
  bool has_webcc_cat_id() const;
  void clear_webcc_cat_id();
  static const int kWebccCatIdFieldNumber = 2;
  ::google::protobuf::uint32 webcc_cat_id() const;
  void set_webcc_cat_id(::google::protobuf::uint32 value);

  // optional uint32 webcc_rep_score = 3;
  bool has_webcc_rep_score() const;
  void clear_webcc_rep_score();
  static const int kWebccRepScoreFieldNumber = 3;
  ::google::protobuf::uint32 webcc_rep_score() const;
  void set_webcc_rep_score(::google::protobuf::uint32 value);

  // optional bool webcc_not_supported = 5;
  bool has_webcc_not_supported() const;
  void clear_webcc_not_supported();
  static const int kWebccNotSupportedFieldNumber = 5;
  bool webcc_not_supported() const;
  void set_webcc_not_supported(bool value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.webcc_info)
 private:
  void set_has_webcc_md5();
  void clear_has_webcc_md5();
  void set_has_webcc_cat_id();
  void clear_has_webcc_cat_id();
  void set_has_webcc_rep_score();
  void clear_has_webcc_rep_score();
  void set_has_webcc_url_prefix();
  void clear_has_webcc_url_prefix();
  void set_has_webcc_not_supported();
  void clear_has_webcc_not_supported();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr webcc_md5_;
  ::google::protobuf::internal::ArenaStringPtr webcc_url_prefix_;
  ::google::protobuf::uint32 webcc_cat_id_;
  ::google::protobuf::uint32 webcc_rep_score_;
  bool webcc_not_supported_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class visibility_rec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.visibility_rec) */ {
 public:
  visibility_rec();
  virtual ~visibility_rec();

  visibility_rec(const visibility_rec& from);

  inline visibility_rec& operator=(const visibility_rec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  visibility_rec(visibility_rec&& from) noexcept
    : visibility_rec() {
    *this = ::std::move(from);
  }

  inline visibility_rec& operator=(visibility_rec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const visibility_rec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const visibility_rec* internal_default_instance() {
    return reinterpret_cast<const visibility_rec*>(
               &_visibility_rec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(visibility_rec* other);
  friend void swap(visibility_rec& a, visibility_rec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline visibility_rec* New() const final {
    return CreateMaybeMessage<visibility_rec>(NULL);
  }

  visibility_rec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<visibility_rec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const visibility_rec& from);
  void MergeFrom(const visibility_rec& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(visibility_rec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef visibility_rec_ip_protocol ip_protocol;
  static const ip_protocol IP_PROTOCOL_VAL_6 =
    visibility_rec_ip_protocol_IP_PROTOCOL_VAL_6;
  static const ip_protocol IP_PROTOCOL_VAL_17 =
    visibility_rec_ip_protocol_IP_PROTOCOL_VAL_17;
  static inline bool ip_protocol_IsValid(int value) {
    return visibility_rec_ip_protocol_IsValid(value);
  }
  static const ip_protocol ip_protocol_MIN =
    visibility_rec_ip_protocol_ip_protocol_MIN;
  static const ip_protocol ip_protocol_MAX =
    visibility_rec_ip_protocol_ip_protocol_MAX;
  static const int ip_protocol_ARRAYSIZE =
    visibility_rec_ip_protocol_ip_protocol_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ip_protocol_descriptor() {
    return visibility_rec_ip_protocol_descriptor();
  }
  static inline const ::std::string& ip_protocol_Name(ip_protocol value) {
    return visibility_rec_ip_protocol_Name(value);
  }
  static inline bool ip_protocol_Parse(const ::std::string& name,
      ip_protocol* value) {
    return visibility_rec_ip_protocol_Parse(name, value);
  }

  typedef visibility_rec_IapAppEnforcementStatus IapAppEnforcementStatus;
  static const IapAppEnforcementStatus ENF_PERMIT =
    visibility_rec_IapAppEnforcementStatus_ENF_PERMIT;
  static const IapAppEnforcementStatus ENF_DENY =
    visibility_rec_IapAppEnforcementStatus_ENF_DENY;
  static inline bool IapAppEnforcementStatus_IsValid(int value) {
    return visibility_rec_IapAppEnforcementStatus_IsValid(value);
  }
  static const IapAppEnforcementStatus IapAppEnforcementStatus_MIN =
    visibility_rec_IapAppEnforcementStatus_IapAppEnforcementStatus_MIN;
  static const IapAppEnforcementStatus IapAppEnforcementStatus_MAX =
    visibility_rec_IapAppEnforcementStatus_IapAppEnforcementStatus_MAX;
  static const int IapAppEnforcementStatus_ARRAYSIZE =
    visibility_rec_IapAppEnforcementStatus_IapAppEnforcementStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IapAppEnforcementStatus_descriptor() {
    return visibility_rec_IapAppEnforcementStatus_descriptor();
  }
  static inline const ::std::string& IapAppEnforcementStatus_Name(IapAppEnforcementStatus value) {
    return visibility_rec_IapAppEnforcementStatus_Name(value);
  }
  static inline bool IapAppEnforcementStatus_Parse(const ::std::string& name,
      IapAppEnforcementStatus* value) {
    return visibility_rec_IapAppEnforcementStatus_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes hashed_client_ip = 9;
  bool has_hashed_client_ip() const;
  void clear_hashed_client_ip();
  static const int kHashedClientIpFieldNumber = 9;
  const ::std::string& hashed_client_ip() const;
  void set_hashed_client_ip(const ::std::string& value);
  #if LANG_CXX11
  void set_hashed_client_ip(::std::string&& value);
  #endif
  void set_hashed_client_ip(const char* value);
  void set_hashed_client_ip(const void* value, size_t size);
  ::std::string* mutable_hashed_client_ip();
  ::std::string* release_hashed_client_ip();
  void set_allocated_hashed_client_ip(::std::string* hashed_client_ip);

  // optional bytes hashed_device_mac = 11;
  bool has_hashed_device_mac() const;
  void clear_hashed_device_mac();
  static const int kHashedDeviceMacFieldNumber = 11;
  const ::std::string& hashed_device_mac() const;
  void set_hashed_device_mac(const ::std::string& value);
  #if LANG_CXX11
  void set_hashed_device_mac(::std::string&& value);
  #endif
  void set_hashed_device_mac(const char* value);
  void set_hashed_device_mac(const void* value, size_t size);
  ::std::string* mutable_hashed_device_mac();
  ::std::string* release_hashed_device_mac();
  void set_allocated_hashed_device_mac(::std::string* hashed_device_mac);

  // optional string app_name = 12;
  bool has_app_name() const;
  void clear_app_name();
  static const int kAppNameFieldNumber = 12;
  const ::std::string& app_name() const;
  void set_app_name(const ::std::string& value);
  #if LANG_CXX11
  void set_app_name(::std::string&& value);
  #endif
  void set_app_name(const char* value);
  void set_app_name(const char* value, size_t size);
  ::std::string* mutable_app_name();
  ::std::string* release_app_name();
  void set_allocated_app_name(::std::string* app_name);

  // optional string cc_url_prefix = 15;
  bool has_cc_url_prefix() const;
  void clear_cc_url_prefix();
  static const int kCcUrlPrefixFieldNumber = 15;
  const ::std::string& cc_url_prefix() const;
  void set_cc_url_prefix(const ::std::string& value);
  #if LANG_CXX11
  void set_cc_url_prefix(::std::string&& value);
  #endif
  void set_cc_url_prefix(const char* value);
  void set_cc_url_prefix(const char* value, size_t size);
  ::std::string* mutable_cc_url_prefix();
  ::std::string* release_cc_url_prefix();
  void set_allocated_cc_url_prefix(::std::string* cc_url_prefix);

  // optional bytes cc_md5 = 16;
  bool has_cc_md5() const;
  void clear_cc_md5();
  static const int kCcMd5FieldNumber = 16;
  const ::std::string& cc_md5() const;
  void set_cc_md5(const ::std::string& value);
  #if LANG_CXX11
  void set_cc_md5(::std::string&& value);
  #endif
  void set_cc_md5(const char* value);
  void set_cc_md5(const void* value, size_t size);
  ::std::string* mutable_cc_md5();
  ::std::string* release_cc_md5();
  void set_allocated_cc_md5(::std::string* cc_md5);

  // optional .ce.nbapi.ip_address client_ip = 1;
  bool has_client_ip() const;
  void clear_client_ip();
  static const int kClientIpFieldNumber = 1;
  private:
  const ::ce::nbapi::ip_address& _internal_client_ip() const;
  public:
  const ::ce::nbapi::ip_address& client_ip() const;
  ::ce::nbapi::ip_address* release_client_ip();
  ::ce::nbapi::ip_address* mutable_client_ip();
  void set_allocated_client_ip(::ce::nbapi::ip_address* client_ip);

  // optional .ce.nbapi.ip_address dest_ip = 2;
  bool has_dest_ip() const;
  void clear_dest_ip();
  static const int kDestIpFieldNumber = 2;
  private:
  const ::ce::nbapi::ip_address& _internal_dest_ip() const;
  public:
  const ::ce::nbapi::ip_address& dest_ip() const;
  ::ce::nbapi::ip_address* release_dest_ip();
  ::ce::nbapi::ip_address* mutable_dest_ip();
  void set_allocated_dest_ip(::ce::nbapi::ip_address* dest_ip);

  // optional .ce.nbapi.mac_address device_mac = 10;
  bool has_device_mac() const;
  void clear_device_mac();
  static const int kDeviceMacFieldNumber = 10;
  private:
  const ::ce::nbapi::mac_address& _internal_device_mac() const;
  public:
  const ::ce::nbapi::mac_address& device_mac() const;
  ::ce::nbapi::mac_address* release_device_mac();
  ::ce::nbapi::mac_address* mutable_device_mac();
  void set_allocated_device_mac(::ce::nbapi::mac_address* device_mac);

  // optional .ce.nbapi.mac_address ap_mac = 17;
  bool has_ap_mac() const;
  void clear_ap_mac();
  static const int kApMacFieldNumber = 17;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_mac() const;
  ::ce::nbapi::mac_address* release_ap_mac();
  ::ce::nbapi::mac_address* mutable_ap_mac();
  void set_allocated_ap_mac(::ce::nbapi::mac_address* ap_mac);

  // optional uint64 tx_pkts = 5;
  bool has_tx_pkts() const;
  void clear_tx_pkts();
  static const int kTxPktsFieldNumber = 5;
  ::google::protobuf::uint64 tx_pkts() const;
  void set_tx_pkts(::google::protobuf::uint64 value);

  // optional uint64 tx_bytes = 6;
  bool has_tx_bytes() const;
  void clear_tx_bytes();
  static const int kTxBytesFieldNumber = 6;
  ::google::protobuf::uint64 tx_bytes() const;
  void set_tx_bytes(::google::protobuf::uint64 value);

  // optional uint64 rx_pkts = 7;
  bool has_rx_pkts() const;
  void clear_rx_pkts();
  static const int kRxPktsFieldNumber = 7;
  ::google::protobuf::uint64 rx_pkts() const;
  void set_rx_pkts(::google::protobuf::uint64 value);

  // optional uint64 rx_bytes = 8;
  bool has_rx_bytes() const;
  void clear_rx_bytes();
  static const int kRxBytesFieldNumber = 8;
  ::google::protobuf::uint64 rx_bytes() const;
  void set_rx_bytes(::google::protobuf::uint64 value);

  // optional uint32 app_id = 4;
  bool has_app_id() const;
  void clear_app_id();
  static const int kAppIdFieldNumber = 4;
  ::google::protobuf::uint32 app_id() const;
  void set_app_id(::google::protobuf::uint32 value);

  // optional uint32 cc_cat_id = 13;
  bool has_cc_cat_id() const;
  void clear_cc_cat_id();
  static const int kCcCatIdFieldNumber = 13;
  ::google::protobuf::uint32 cc_cat_id() const;
  void set_cc_cat_id(::google::protobuf::uint32 value);

  // optional uint32 cc_rep_score = 14;
  bool has_cc_rep_score() const;
  void clear_cc_rep_score();
  static const int kCcRepScoreFieldNumber = 14;
  ::google::protobuf::uint32 cc_rep_score() const;
  void set_cc_rep_score(::google::protobuf::uint32 value);

  // optional .ce.nbapi.visibility_rec.ip_protocol ip_proto = 3;
  bool has_ip_proto() const;
  void clear_ip_proto();
  static const int kIpProtoFieldNumber = 3;
  ::ce::nbapi::visibility_rec_ip_protocol ip_proto() const;
  void set_ip_proto(::ce::nbapi::visibility_rec_ip_protocol value);

  // optional .ce.nbapi.visibility_rec.IapAppEnforcementStatus session_flags = 18;
  bool has_session_flags() const;
  void clear_session_flags();
  static const int kSessionFlagsFieldNumber = 18;
  ::ce::nbapi::visibility_rec_IapAppEnforcementStatus session_flags() const;
  void set_session_flags(::ce::nbapi::visibility_rec_IapAppEnforcementStatus value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.visibility_rec)
 private:
  void set_has_client_ip();
  void clear_has_client_ip();
  void set_has_dest_ip();
  void clear_has_dest_ip();
  void set_has_ip_proto();
  void clear_has_ip_proto();
  void set_has_app_id();
  void clear_has_app_id();
  void set_has_tx_pkts();
  void clear_has_tx_pkts();
  void set_has_tx_bytes();
  void clear_has_tx_bytes();
  void set_has_rx_pkts();
  void clear_has_rx_pkts();
  void set_has_rx_bytes();
  void clear_has_rx_bytes();
  void set_has_hashed_client_ip();
  void clear_has_hashed_client_ip();
  void set_has_device_mac();
  void clear_has_device_mac();
  void set_has_hashed_device_mac();
  void clear_has_hashed_device_mac();
  void set_has_app_name();
  void clear_has_app_name();
  void set_has_cc_cat_id();
  void clear_has_cc_cat_id();
  void set_has_cc_rep_score();
  void clear_has_cc_rep_score();
  void set_has_cc_url_prefix();
  void clear_has_cc_url_prefix();
  void set_has_cc_md5();
  void clear_has_cc_md5();
  void set_has_ap_mac();
  void clear_has_ap_mac();
  void set_has_session_flags();
  void clear_has_session_flags();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hashed_client_ip_;
  ::google::protobuf::internal::ArenaStringPtr hashed_device_mac_;
  ::google::protobuf::internal::ArenaStringPtr app_name_;
  ::google::protobuf::internal::ArenaStringPtr cc_url_prefix_;
  ::google::protobuf::internal::ArenaStringPtr cc_md5_;
  ::ce::nbapi::ip_address* client_ip_;
  ::ce::nbapi::ip_address* dest_ip_;
  ::ce::nbapi::mac_address* device_mac_;
  ::ce::nbapi::mac_address* ap_mac_;
  ::google::protobuf::uint64 tx_pkts_;
  ::google::protobuf::uint64 tx_bytes_;
  ::google::protobuf::uint64 rx_pkts_;
  ::google::protobuf::uint64 rx_bytes_;
  ::google::protobuf::uint32 app_id_;
  ::google::protobuf::uint32 cc_cat_id_;
  ::google::protobuf::uint32 cc_rep_score_;
  int ip_proto_;
  int session_flags_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class campus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.campus) */ {
 public:
  campus();
  virtual ~campus();

  campus(const campus& from);

  inline campus& operator=(const campus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  campus(campus&& from) noexcept
    : campus() {
    *this = ::std::move(from);
  }

  inline campus& operator=(campus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const campus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const campus* internal_default_instance() {
    return reinterpret_cast<const campus*>(
               &_campus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(campus* other);
  friend void swap(campus& a, campus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline campus* New() const final {
    return CreateMaybeMessage<campus>(NULL);
  }

  campus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<campus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const campus& from);
  void MergeFrom(const campus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(campus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes campus_id = 1;
  bool has_campus_id() const;
  void clear_campus_id();
  static const int kCampusIdFieldNumber = 1;
  const ::std::string& campus_id() const;
  void set_campus_id(const ::std::string& value);
  #if LANG_CXX11
  void set_campus_id(::std::string&& value);
  #endif
  void set_campus_id(const char* value);
  void set_campus_id(const void* value, size_t size);
  ::std::string* mutable_campus_id();
  ::std::string* release_campus_id();
  void set_allocated_campus_id(::std::string* campus_id);

  // optional string campus_name = 2;
  bool has_campus_name() const;
  void clear_campus_name();
  static const int kCampusNameFieldNumber = 2;
  const ::std::string& campus_name() const;
  void set_campus_name(const ::std::string& value);
  #if LANG_CXX11
  void set_campus_name(::std::string&& value);
  #endif
  void set_campus_name(const char* value);
  void set_campus_name(const char* value, size_t size);
  ::std::string* mutable_campus_name();
  ::std::string* release_campus_name();
  void set_allocated_campus_name(::std::string* campus_name);

  // @@protoc_insertion_point(class_scope:ce.nbapi.campus)
 private:
  void set_has_campus_id();
  void clear_has_campus_id();
  void set_has_campus_name();
  void clear_has_campus_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr campus_id_;
  ::google::protobuf::internal::ArenaStringPtr campus_name_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class building : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.building) */ {
 public:
  building();
  virtual ~building();

  building(const building& from);

  inline building& operator=(const building& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  building(building&& from) noexcept
    : building() {
    *this = ::std::move(from);
  }

  inline building& operator=(building&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const building& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const building* internal_default_instance() {
    return reinterpret_cast<const building*>(
               &_building_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(building* other);
  friend void swap(building& a, building& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline building* New() const final {
    return CreateMaybeMessage<building>(NULL);
  }

  building* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<building>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const building& from);
  void MergeFrom(const building& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(building* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes building_id = 1;
  bool has_building_id() const;
  void clear_building_id();
  static const int kBuildingIdFieldNumber = 1;
  const ::std::string& building_id() const;
  void set_building_id(const ::std::string& value);
  #if LANG_CXX11
  void set_building_id(::std::string&& value);
  #endif
  void set_building_id(const char* value);
  void set_building_id(const void* value, size_t size);
  ::std::string* mutable_building_id();
  ::std::string* release_building_id();
  void set_allocated_building_id(::std::string* building_id);

  // optional string building_name = 2;
  bool has_building_name() const;
  void clear_building_name();
  static const int kBuildingNameFieldNumber = 2;
  const ::std::string& building_name() const;
  void set_building_name(const ::std::string& value);
  #if LANG_CXX11
  void set_building_name(::std::string&& value);
  #endif
  void set_building_name(const char* value);
  void set_building_name(const char* value, size_t size);
  ::std::string* mutable_building_name();
  ::std::string* release_building_name();
  void set_allocated_building_name(::std::string* building_name);

  // optional bytes campus_id = 3;
  bool has_campus_id() const;
  void clear_campus_id();
  static const int kCampusIdFieldNumber = 3;
  const ::std::string& campus_id() const;
  void set_campus_id(const ::std::string& value);
  #if LANG_CXX11
  void set_campus_id(::std::string&& value);
  #endif
  void set_campus_id(const char* value);
  void set_campus_id(const void* value, size_t size);
  ::std::string* mutable_campus_id();
  ::std::string* release_campus_id();
  void set_allocated_campus_id(::std::string* campus_id);

  // @@protoc_insertion_point(class_scope:ce.nbapi.building)
 private:
  void set_has_building_id();
  void clear_has_building_id();
  void set_has_building_name();
  void clear_has_building_name();
  void set_has_campus_id();
  void clear_has_campus_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr building_id_;
  ::google::protobuf::internal::ArenaStringPtr building_name_;
  ::google::protobuf::internal::ArenaStringPtr campus_id_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class floor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.floor) */ {
 public:
  floor();
  virtual ~floor();

  floor(const floor& from);

  inline floor& operator=(const floor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  floor(floor&& from) noexcept
    : floor() {
    *this = ::std::move(from);
  }

  inline floor& operator=(floor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const floor& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const floor* internal_default_instance() {
    return reinterpret_cast<const floor*>(
               &_floor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(floor* other);
  friend void swap(floor& a, floor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline floor* New() const final {
    return CreateMaybeMessage<floor>(NULL);
  }

  floor* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<floor>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const floor& from);
  void MergeFrom(const floor& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(floor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes floor_id = 1;
  bool has_floor_id() const;
  void clear_floor_id();
  static const int kFloorIdFieldNumber = 1;
  const ::std::string& floor_id() const;
  void set_floor_id(const ::std::string& value);
  #if LANG_CXX11
  void set_floor_id(::std::string&& value);
  #endif
  void set_floor_id(const char* value);
  void set_floor_id(const void* value, size_t size);
  ::std::string* mutable_floor_id();
  ::std::string* release_floor_id();
  void set_allocated_floor_id(::std::string* floor_id);

  // optional string floor_name = 2;
  bool has_floor_name() const;
  void clear_floor_name();
  static const int kFloorNameFieldNumber = 2;
  const ::std::string& floor_name() const;
  void set_floor_name(const ::std::string& value);
  #if LANG_CXX11
  void set_floor_name(::std::string&& value);
  #endif
  void set_floor_name(const char* value);
  void set_floor_name(const char* value, size_t size);
  ::std::string* mutable_floor_name();
  ::std::string* release_floor_name();
  void set_allocated_floor_name(::std::string* floor_name);

  // optional string floor_img_path = 5;
  bool has_floor_img_path() const;
  void clear_floor_img_path();
  static const int kFloorImgPathFieldNumber = 5;
  const ::std::string& floor_img_path() const;
  void set_floor_img_path(const ::std::string& value);
  #if LANG_CXX11
  void set_floor_img_path(::std::string&& value);
  #endif
  void set_floor_img_path(const char* value);
  void set_floor_img_path(const char* value, size_t size);
  ::std::string* mutable_floor_img_path();
  ::std::string* release_floor_img_path();
  void set_allocated_floor_img_path(::std::string* floor_img_path);

  // optional bytes building_id = 8;
  bool has_building_id() const;
  void clear_building_id();
  static const int kBuildingIdFieldNumber = 8;
  const ::std::string& building_id() const;
  void set_building_id(const ::std::string& value);
  #if LANG_CXX11
  void set_building_id(::std::string&& value);
  #endif
  void set_building_id(const char* value);
  void set_building_id(const void* value, size_t size);
  ::std::string* mutable_building_id();
  ::std::string* release_building_id();
  void set_allocated_building_id(::std::string* building_id);

  // optional string units = 10;
  bool has_units() const;
  void clear_units();
  static const int kUnitsFieldNumber = 10;
  const ::std::string& units() const;
  void set_units(const ::std::string& value);
  #if LANG_CXX11
  void set_units(::std::string&& value);
  #endif
  void set_units(const char* value);
  void set_units(const char* value, size_t size);
  ::std::string* mutable_units();
  ::std::string* release_units();
  void set_allocated_units(::std::string* units);

  // optional float floor_latitude = 3;
  bool has_floor_latitude() const;
  void clear_floor_latitude();
  static const int kFloorLatitudeFieldNumber = 3;
  float floor_latitude() const;
  void set_floor_latitude(float value);

  // optional float floor_longitude = 4;
  bool has_floor_longitude() const;
  void clear_floor_longitude();
  static const int kFloorLongitudeFieldNumber = 4;
  float floor_longitude() const;
  void set_floor_longitude(float value);

  // optional float floor_img_width = 6;
  bool has_floor_img_width() const;
  void clear_floor_img_width();
  static const int kFloorImgWidthFieldNumber = 6;
  float floor_img_width() const;
  void set_floor_img_width(float value);

  // optional float floor_img_length = 7;
  bool has_floor_img_length() const;
  void clear_floor_img_length();
  static const int kFloorImgLengthFieldNumber = 7;
  float floor_img_length() const;
  void set_floor_img_length(float value);

  // optional float floor_level = 9;
  bool has_floor_level() const;
  void clear_floor_level();
  static const int kFloorLevelFieldNumber = 9;
  float floor_level() const;
  void set_floor_level(float value);

  // optional float grid_size = 11;
  bool has_grid_size() const;
  void clear_grid_size();
  static const int kGridSizeFieldNumber = 11;
  float grid_size() const;
  void set_grid_size(float value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.floor)
 private:
  void set_has_floor_id();
  void clear_has_floor_id();
  void set_has_floor_name();
  void clear_has_floor_name();
  void set_has_floor_latitude();
  void clear_has_floor_latitude();
  void set_has_floor_longitude();
  void clear_has_floor_longitude();
  void set_has_floor_img_path();
  void clear_has_floor_img_path();
  void set_has_floor_img_width();
  void clear_has_floor_img_width();
  void set_has_floor_img_length();
  void clear_has_floor_img_length();
  void set_has_building_id();
  void clear_has_building_id();
  void set_has_floor_level();
  void clear_has_floor_level();
  void set_has_units();
  void clear_has_units();
  void set_has_grid_size();
  void clear_has_grid_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr floor_id_;
  ::google::protobuf::internal::ArenaStringPtr floor_name_;
  ::google::protobuf::internal::ArenaStringPtr floor_img_path_;
  ::google::protobuf::internal::ArenaStringPtr building_id_;
  ::google::protobuf::internal::ArenaStringPtr units_;
  float floor_latitude_;
  float floor_longitude_;
  float floor_img_width_;
  float floor_img_length_;
  float floor_level_;
  float grid_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.point) */ {
 public:
  point();
  virtual ~point();

  point(const point& from);

  inline point& operator=(const point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  point(point&& from) noexcept
    : point() {
    *this = ::std::move(from);
  }

  inline point& operator=(point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const point* internal_default_instance() {
    return reinterpret_cast<const point*>(
               &_point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(point* other);
  friend void swap(point& a, point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline point* New() const final {
    return CreateMaybeMessage<point>(NULL);
  }

  point* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<point>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const point& from);
  void MergeFrom(const point& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.point)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class geofence : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.geofence) */ {
 public:
  geofence();
  virtual ~geofence();

  geofence(const geofence& from);

  inline geofence& operator=(const geofence& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  geofence(geofence&& from) noexcept
    : geofence() {
    *this = ::std::move(from);
  }

  inline geofence& operator=(geofence&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const geofence& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const geofence* internal_default_instance() {
    return reinterpret_cast<const geofence*>(
               &_geofence_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(geofence* other);
  friend void swap(geofence& a, geofence& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline geofence* New() const final {
    return CreateMaybeMessage<geofence>(NULL);
  }

  geofence* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<geofence>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const geofence& from);
  void MergeFrom(const geofence& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(geofence* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ce.nbapi.point point_list = 5;
  int point_list_size() const;
  void clear_point_list();
  static const int kPointListFieldNumber = 5;
  ::ce::nbapi::point* mutable_point_list(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::point >*
      mutable_point_list();
  const ::ce::nbapi::point& point_list(int index) const;
  ::ce::nbapi::point* add_point_list();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::point >&
      point_list() const;

  // optional bytes floor_id = 1;
  bool has_floor_id() const;
  void clear_floor_id();
  static const int kFloorIdFieldNumber = 1;
  const ::std::string& floor_id() const;
  void set_floor_id(const ::std::string& value);
  #if LANG_CXX11
  void set_floor_id(::std::string&& value);
  #endif
  void set_floor_id(const char* value);
  void set_floor_id(const void* value, size_t size);
  ::std::string* mutable_floor_id();
  ::std::string* release_floor_id();
  void set_allocated_floor_id(::std::string* floor_id);

  // optional bytes geofence_id = 2;
  bool has_geofence_id() const;
  void clear_geofence_id();
  static const int kGeofenceIdFieldNumber = 2;
  const ::std::string& geofence_id() const;
  void set_geofence_id(const ::std::string& value);
  #if LANG_CXX11
  void set_geofence_id(::std::string&& value);
  #endif
  void set_geofence_id(const char* value);
  void set_geofence_id(const void* value, size_t size);
  ::std::string* mutable_geofence_id();
  ::std::string* release_geofence_id();
  void set_allocated_geofence_id(::std::string* geofence_id);

  // optional string geofence_name = 3;
  bool has_geofence_name() const;
  void clear_geofence_name();
  static const int kGeofenceNameFieldNumber = 3;
  const ::std::string& geofence_name() const;
  void set_geofence_name(const ::std::string& value);
  #if LANG_CXX11
  void set_geofence_name(::std::string&& value);
  #endif
  void set_geofence_name(const char* value);
  void set_geofence_name(const char* value, size_t size);
  ::std::string* mutable_geofence_name();
  ::std::string* release_geofence_name();
  void set_allocated_geofence_name(::std::string* geofence_name);

  // optional string type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  #if LANG_CXX11
  void set_type(::std::string&& value);
  #endif
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // @@protoc_insertion_point(class_scope:ce.nbapi.geofence)
 private:
  void set_has_floor_id();
  void clear_has_floor_id();
  void set_has_geofence_id();
  void clear_has_geofence_id();
  void set_has_geofence_name();
  void clear_has_geofence_name();
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::point > point_list_;
  ::google::protobuf::internal::ArenaStringPtr floor_id_;
  ::google::protobuf::internal::ArenaStringPtr geofence_id_;
  ::google::protobuf::internal::ArenaStringPtr geofence_name_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class geofence_notify_Access_point_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.geofence_notify.Access_point_info) */ {
 public:
  geofence_notify_Access_point_info();
  virtual ~geofence_notify_Access_point_info();

  geofence_notify_Access_point_info(const geofence_notify_Access_point_info& from);

  inline geofence_notify_Access_point_info& operator=(const geofence_notify_Access_point_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  geofence_notify_Access_point_info(geofence_notify_Access_point_info&& from) noexcept
    : geofence_notify_Access_point_info() {
    *this = ::std::move(from);
  }

  inline geofence_notify_Access_point_info& operator=(geofence_notify_Access_point_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const geofence_notify_Access_point_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const geofence_notify_Access_point_info* internal_default_instance() {
    return reinterpret_cast<const geofence_notify_Access_point_info*>(
               &_geofence_notify_Access_point_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(geofence_notify_Access_point_info* other);
  friend void swap(geofence_notify_Access_point_info& a, geofence_notify_Access_point_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline geofence_notify_Access_point_info* New() const final {
    return CreateMaybeMessage<geofence_notify_Access_point_info>(NULL);
  }

  geofence_notify_Access_point_info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<geofence_notify_Access_point_info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const geofence_notify_Access_point_info& from);
  void MergeFrom(const geofence_notify_Access_point_info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(geofence_notify_Access_point_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ap_name = 9;
  bool has_ap_name() const;
  void clear_ap_name();
  static const int kApNameFieldNumber = 9;
  const ::std::string& ap_name() const;
  void set_ap_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ap_name(::std::string&& value);
  #endif
  void set_ap_name(const char* value);
  void set_ap_name(const char* value, size_t size);
  ::std::string* mutable_ap_name();
  ::std::string* release_ap_name();
  void set_allocated_ap_name(::std::string* ap_name);

  // optional .ce.nbapi.mac_address ap_mac = 8;
  bool has_ap_mac() const;
  void clear_ap_mac();
  static const int kApMacFieldNumber = 8;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_mac() const;
  ::ce::nbapi::mac_address* release_ap_mac();
  ::ce::nbapi::mac_address* mutable_ap_mac();
  void set_allocated_ap_mac(::ce::nbapi::mac_address* ap_mac);

  // optional .ce.nbapi.mac_address radio_bssid = 10;
  bool has_radio_bssid() const;
  void clear_radio_bssid();
  static const int kRadioBssidFieldNumber = 10;
  private:
  const ::ce::nbapi::mac_address& _internal_radio_bssid() const;
  public:
  const ::ce::nbapi::mac_address& radio_bssid() const;
  ::ce::nbapi::mac_address* release_radio_bssid();
  ::ce::nbapi::mac_address* mutable_radio_bssid();
  void set_allocated_radio_bssid(::ce::nbapi::mac_address* radio_bssid);

  // optional uint32 rssi_val = 11;
  bool has_rssi_val() const;
  void clear_rssi_val();
  static const int kRssiValFieldNumber = 11;
  ::google::protobuf::uint32 rssi_val() const;
  void set_rssi_val(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.geofence_notify.Access_point_info)
 private:
  void set_has_ap_mac();
  void clear_has_ap_mac();
  void set_has_ap_name();
  void clear_has_ap_name();
  void set_has_radio_bssid();
  void clear_has_radio_bssid();
  void set_has_rssi_val();
  void clear_has_rssi_val();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ap_name_;
  ::ce::nbapi::mac_address* ap_mac_;
  ::ce::nbapi::mac_address* radio_bssid_;
  ::google::protobuf::uint32 rssi_val_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class geofence_notify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.geofence_notify) */ {
 public:
  geofence_notify();
  virtual ~geofence_notify();

  geofence_notify(const geofence_notify& from);

  inline geofence_notify& operator=(const geofence_notify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  geofence_notify(geofence_notify&& from) noexcept
    : geofence_notify() {
    *this = ::std::move(from);
  }

  inline geofence_notify& operator=(geofence_notify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const geofence_notify& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const geofence_notify* internal_default_instance() {
    return reinterpret_cast<const geofence_notify*>(
               &_geofence_notify_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(geofence_notify* other);
  friend void swap(geofence_notify& a, geofence_notify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline geofence_notify* New() const final {
    return CreateMaybeMessage<geofence_notify>(NULL);
  }

  geofence_notify* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<geofence_notify>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const geofence_notify& from);
  void MergeFrom(const geofence_notify& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(geofence_notify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef geofence_notify_Access_point_info Access_point_info;

  typedef geofence_notify_zone_event zone_event;
  static const zone_event ZONE_IN =
    geofence_notify_zone_event_ZONE_IN;
  static const zone_event ZONE_OUT =
    geofence_notify_zone_event_ZONE_OUT;
  static inline bool zone_event_IsValid(int value) {
    return geofence_notify_zone_event_IsValid(value);
  }
  static const zone_event zone_event_MIN =
    geofence_notify_zone_event_zone_event_MIN;
  static const zone_event zone_event_MAX =
    geofence_notify_zone_event_zone_event_MAX;
  static const int zone_event_ARRAYSIZE =
    geofence_notify_zone_event_zone_event_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  zone_event_descriptor() {
    return geofence_notify_zone_event_descriptor();
  }
  static inline const ::std::string& zone_event_Name(zone_event value) {
    return geofence_notify_zone_event_Name(value);
  }
  static inline bool zone_event_Parse(const ::std::string& name,
      zone_event* value) {
    return geofence_notify_zone_event_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated group Access_point_info = 7 { ... };
  int access_point_info_size() const;
  void clear_access_point_info();
  static const int kAccessPointInfoFieldNumber = 7;
  ::ce::nbapi::geofence_notify_Access_point_info* mutable_access_point_info(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::geofence_notify_Access_point_info >*
      mutable_access_point_info();
  const ::ce::nbapi::geofence_notify_Access_point_info& access_point_info(int index) const;
  ::ce::nbapi::geofence_notify_Access_point_info* add_access_point_info();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::geofence_notify_Access_point_info >&
      access_point_info() const;

  // optional bytes geofence_id = 2;
  bool has_geofence_id() const;
  void clear_geofence_id();
  static const int kGeofenceIdFieldNumber = 2;
  const ::std::string& geofence_id() const;
  void set_geofence_id(const ::std::string& value);
  #if LANG_CXX11
  void set_geofence_id(::std::string&& value);
  #endif
  void set_geofence_id(const char* value);
  void set_geofence_id(const void* value, size_t size);
  ::std::string* mutable_geofence_id();
  ::std::string* release_geofence_id();
  void set_allocated_geofence_id(::std::string* geofence_id);

  // optional string geofence_name = 3;
  bool has_geofence_name() const;
  void clear_geofence_name();
  static const int kGeofenceNameFieldNumber = 3;
  const ::std::string& geofence_name() const;
  void set_geofence_name(const ::std::string& value);
  #if LANG_CXX11
  void set_geofence_name(::std::string&& value);
  #endif
  void set_geofence_name(const char* value);
  void set_geofence_name(const char* value, size_t size);
  ::std::string* mutable_geofence_name();
  ::std::string* release_geofence_name();
  void set_allocated_geofence_name(::std::string* geofence_name);

  // optional bytes hashed_sta_mac = 30;
  bool has_hashed_sta_mac() const;
  void clear_hashed_sta_mac();
  static const int kHashedStaMacFieldNumber = 30;
  const ::std::string& hashed_sta_mac() const;
  void set_hashed_sta_mac(const ::std::string& value);
  #if LANG_CXX11
  void set_hashed_sta_mac(::std::string&& value);
  #endif
  void set_hashed_sta_mac(const char* value);
  void set_hashed_sta_mac(const void* value, size_t size);
  ::std::string* mutable_hashed_sta_mac();
  ::std::string* release_hashed_sta_mac();
  void set_allocated_hashed_sta_mac(::std::string* hashed_sta_mac);

  // optional .ce.nbapi.mac_address sta_mac = 4;
  bool has_sta_mac() const;
  void clear_sta_mac();
  static const int kStaMacFieldNumber = 4;
  private:
  const ::ce::nbapi::mac_address& _internal_sta_mac() const;
  public:
  const ::ce::nbapi::mac_address& sta_mac() const;
  ::ce::nbapi::mac_address* release_sta_mac();
  ::ce::nbapi::mac_address* mutable_sta_mac();
  void set_allocated_sta_mac(::ce::nbapi::mac_address* sta_mac);

  // optional .ce.nbapi.geofence_notify.zone_event geofence_event = 1;
  bool has_geofence_event() const;
  void clear_geofence_event();
  static const int kGeofenceEventFieldNumber = 1;
  ::ce::nbapi::geofence_notify_zone_event geofence_event() const;
  void set_geofence_event(::ce::nbapi::geofence_notify_zone_event value);

  // optional bool associated = 5;
  bool has_associated() const;
  void clear_associated();
  static const int kAssociatedFieldNumber = 5;
  bool associated() const;
  void set_associated(bool value);

  // optional uint32 dwell_time = 6 [default = 0];
  bool has_dwell_time() const;
  void clear_dwell_time();
  static const int kDwellTimeFieldNumber = 6;
  ::google::protobuf::uint32 dwell_time() const;
  void set_dwell_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.geofence_notify)
 private:
  void set_has_geofence_event();
  void clear_has_geofence_event();
  void set_has_geofence_id();
  void clear_has_geofence_id();
  void set_has_geofence_name();
  void clear_has_geofence_name();
  void set_has_sta_mac();
  void clear_has_sta_mac();
  void set_has_associated();
  void clear_has_associated();
  void set_has_dwell_time();
  void clear_has_dwell_time();
  void set_has_hashed_sta_mac();
  void clear_has_hashed_sta_mac();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::geofence_notify_Access_point_info > access_point_info_;
  ::google::protobuf::internal::ArenaStringPtr geofence_id_;
  ::google::protobuf::internal::ArenaStringPtr geofence_name_;
  ::google::protobuf::internal::ArenaStringPtr hashed_sta_mac_;
  ::ce::nbapi::mac_address* sta_mac_;
  int geofence_event_;
  bool associated_;
  ::google::protobuf::uint32 dwell_time_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class stats_radio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.stats_radio) */ {
 public:
  stats_radio();
  virtual ~stats_radio();

  stats_radio(const stats_radio& from);

  inline stats_radio& operator=(const stats_radio& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  stats_radio(stats_radio&& from) noexcept
    : stats_radio() {
    *this = ::std::move(from);
  }

  inline stats_radio& operator=(stats_radio&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stats_radio& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const stats_radio* internal_default_instance() {
    return reinterpret_cast<const stats_radio*>(
               &_stats_radio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(stats_radio* other);
  friend void swap(stats_radio& a, stats_radio& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline stats_radio* New() const final {
    return CreateMaybeMessage<stats_radio>(NULL);
  }

  stats_radio* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<stats_radio>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const stats_radio& from);
  void MergeFrom(const stats_radio& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(stats_radio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef stats_radio_radio_mode radio_mode;
  static const radio_mode RADIO_MODE_AP =
    stats_radio_radio_mode_RADIO_MODE_AP;
  static const radio_mode RADIO_MODE_MESH_PORTAL =
    stats_radio_radio_mode_RADIO_MODE_MESH_PORTAL;
  static const radio_mode RADIO_MODE_MESH_POINT =
    stats_radio_radio_mode_RADIO_MODE_MESH_POINT;
  static const radio_mode RADIO_MODE_AIR_MONITOR =
    stats_radio_radio_mode_RADIO_MODE_AIR_MONITOR;
  static const radio_mode RADIO_MODE_SPECTRUM_SENSOR =
    stats_radio_radio_mode_RADIO_MODE_SPECTRUM_SENSOR;
  static const radio_mode RADIO_MODE_UNKNOWN =
    stats_radio_radio_mode_RADIO_MODE_UNKNOWN;
  static inline bool radio_mode_IsValid(int value) {
    return stats_radio_radio_mode_IsValid(value);
  }
  static const radio_mode radio_mode_MIN =
    stats_radio_radio_mode_radio_mode_MIN;
  static const radio_mode radio_mode_MAX =
    stats_radio_radio_mode_radio_mode_MAX;
  static const int radio_mode_ARRAYSIZE =
    stats_radio_radio_mode_radio_mode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  radio_mode_descriptor() {
    return stats_radio_radio_mode_descriptor();
  }
  static inline const ::std::string& radio_mode_Name(radio_mode value) {
    return stats_radio_radio_mode_Name(value);
  }
  static inline bool radio_mode_Parse(const ::std::string& name,
      radio_mode* value) {
    return stats_radio_radio_mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .ce.nbapi.data_traffic_type_stats traffic_stats = 23;
  int traffic_stats_size() const;
  void clear_traffic_stats();
  static const int kTrafficStatsFieldNumber = 23;
  ::ce::nbapi::data_traffic_type_stats* mutable_traffic_stats(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_traffic_type_stats >*
      mutable_traffic_stats();
  const ::ce::nbapi::data_traffic_type_stats& traffic_stats(int index) const;
  ::ce::nbapi::data_traffic_type_stats* add_traffic_stats();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_traffic_type_stats >&
      traffic_stats() const;

  // repeated .ce.nbapi.data_prio_stats prio_stats = 24;
  int prio_stats_size() const;
  void clear_prio_stats();
  static const int kPrioStatsFieldNumber = 24;
  ::ce::nbapi::data_prio_stats* mutable_prio_stats(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats >*
      mutable_prio_stats();
  const ::ce::nbapi::data_prio_stats& prio_stats(int index) const;
  ::ce::nbapi::data_prio_stats* add_prio_stats();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats >&
      prio_stats() const;

  // repeated .ce.nbapi.data_rate_stats rate_stats = 25;
  int rate_stats_size() const;
  void clear_rate_stats();
  static const int kRateStatsFieldNumber = 25;
  ::ce::nbapi::data_rate_stats* mutable_rate_stats(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats >*
      mutable_rate_stats();
  const ::ce::nbapi::data_rate_stats& rate_stats(int index) const;
  ::ce::nbapi::data_rate_stats* add_rate_stats();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats >&
      rate_stats() const;

  // optional .ce.nbapi.mac_address ap_eth_mac = 1;
  bool has_ap_eth_mac() const;
  void clear_ap_eth_mac();
  static const int kApEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_eth_mac() const;
  ::ce::nbapi::mac_address* release_ap_eth_mac();
  ::ce::nbapi::mac_address* mutable_ap_eth_mac();
  void set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac);

  // optional .ce.nbapi.mac_address radio_mac = 27;
  bool has_radio_mac() const;
  void clear_radio_mac();
  static const int kRadioMacFieldNumber = 27;
  private:
  const ::ce::nbapi::mac_address& _internal_radio_mac() const;
  public:
  const ::ce::nbapi::mac_address& radio_mac() const;
  ::ce::nbapi::mac_address* release_radio_mac();
  ::ce::nbapi::mac_address* mutable_radio_mac();
  void set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac);

  // optional uint32 radio_number = 2;
  bool has_radio_number() const;
  void clear_radio_number();
  static const int kRadioNumberFieldNumber = 2;
  ::google::protobuf::uint32 radio_number() const;
  void set_radio_number(::google::protobuf::uint32 value);

  // optional uint32 channel = 3;
  bool has_channel() const;
  void clear_channel();
  static const int kChannelFieldNumber = 3;
  ::google::protobuf::uint32 channel() const;
  void set_channel(::google::protobuf::uint32 value);

  // optional .ce.nbapi.phy_type phy = 4;
  bool has_phy() const;
  void clear_phy();
  static const int kPhyFieldNumber = 4;
  ::ce::nbapi::phy_type phy() const;
  void set_phy(::ce::nbapi::phy_type value);

  // optional .ce.nbapi.stats_radio.radio_mode mode = 5;
  bool has_mode() const;
  void clear_mode();
  static const int kModeFieldNumber = 5;
  ::ce::nbapi::stats_radio_radio_mode mode() const;
  void set_mode(::ce::nbapi::stats_radio_radio_mode value);

  // optional uint32 noise_floor = 7;
  bool has_noise_floor() const;
  void clear_noise_floor();
  static const int kNoiseFloorFieldNumber = 7;
  ::google::protobuf::uint32 noise_floor() const;
  void set_noise_floor(::google::protobuf::uint32 value);

  // optional uint32 tx_power = 8;
  bool has_tx_power() const;
  void clear_tx_power();
  static const int kTxPowerFieldNumber = 8;
  ::google::protobuf::uint32 tx_power() const;
  void set_tx_power(::google::protobuf::uint32 value);

  // optional uint32 channel_utilization = 9;
  bool has_channel_utilization() const;
  void clear_channel_utilization();
  static const int kChannelUtilizationFieldNumber = 9;
  ::google::protobuf::uint32 channel_utilization() const;
  void set_channel_utilization(::google::protobuf::uint32 value);

  // optional uint32 rx_channel_utilization = 10;
  bool has_rx_channel_utilization() const;
  void clear_rx_channel_utilization();
  static const int kRxChannelUtilizationFieldNumber = 10;
  ::google::protobuf::uint32 rx_channel_utilization() const;
  void set_rx_channel_utilization(::google::protobuf::uint32 value);

  // optional uint32 tx_channel_utilization = 11;
  bool has_tx_channel_utilization() const;
  void clear_tx_channel_utilization();
  static const int kTxChannelUtilizationFieldNumber = 11;
  ::google::protobuf::uint32 tx_channel_utilization() const;
  void set_tx_channel_utilization(::google::protobuf::uint32 value);

  // optional uint32 tx_received = 12;
  bool has_tx_received() const;
  void clear_tx_received();
  static const int kTxReceivedFieldNumber = 12;
  ::google::protobuf::uint32 tx_received() const;
  void set_tx_received(::google::protobuf::uint32 value);

  // optional uint32 tx_transmitted = 13;
  bool has_tx_transmitted() const;
  void clear_tx_transmitted();
  static const int kTxTransmittedFieldNumber = 13;
  ::google::protobuf::uint32 tx_transmitted() const;
  void set_tx_transmitted(::google::protobuf::uint32 value);

  // optional uint32 tx_dropped = 14;
  bool has_tx_dropped() const;
  void clear_tx_dropped();
  static const int kTxDroppedFieldNumber = 14;
  ::google::protobuf::uint32 tx_dropped() const;
  void set_tx_dropped(::google::protobuf::uint32 value);

  // optional uint32 tx_data_received = 15;
  bool has_tx_data_received() const;
  void clear_tx_data_received();
  static const int kTxDataReceivedFieldNumber = 15;
  ::google::protobuf::uint32 tx_data_received() const;
  void set_tx_data_received(::google::protobuf::uint32 value);

  // optional uint32 tx_data_transmitted = 16;
  bool has_tx_data_transmitted() const;
  void clear_tx_data_transmitted();
  static const int kTxDataTransmittedFieldNumber = 16;
  ::google::protobuf::uint32 tx_data_transmitted() const;
  void set_tx_data_transmitted(::google::protobuf::uint32 value);

  // optional uint32 tx_data_retried = 17;
  bool has_tx_data_retried() const;
  void clear_tx_data_retried();
  static const int kTxDataRetriedFieldNumber = 17;
  ::google::protobuf::uint32 tx_data_retried() const;
  void set_tx_data_retried(::google::protobuf::uint32 value);

  // optional uint32 rx_frames = 18;
  bool has_rx_frames() const;
  void clear_rx_frames();
  static const int kRxFramesFieldNumber = 18;
  ::google::protobuf::uint32 rx_frames() const;
  void set_rx_frames(::google::protobuf::uint32 value);

  // optional uint32 rx_retried = 19;
  bool has_rx_retried() const;
  void clear_rx_retried();
  static const int kRxRetriedFieldNumber = 19;
  ::google::protobuf::uint32 rx_retried() const;
  void set_rx_retried(::google::protobuf::uint32 value);

  // optional uint32 rx_data_frames = 20;
  bool has_rx_data_frames() const;
  void clear_rx_data_frames();
  static const int kRxDataFramesFieldNumber = 20;
  ::google::protobuf::uint32 rx_data_frames() const;
  void set_rx_data_frames(::google::protobuf::uint32 value);

  // optional uint32 rx_data_retried = 21;
  bool has_rx_data_retried() const;
  void clear_rx_data_retried();
  static const int kRxDataRetriedFieldNumber = 21;
  ::google::protobuf::uint32 rx_data_retried() const;
  void set_rx_data_retried(::google::protobuf::uint32 value);

  // optional uint32 rx_frame_errors = 22;
  bool has_rx_frame_errors() const;
  void clear_rx_frame_errors();
  static const int kRxFrameErrorsFieldNumber = 22;
  ::google::protobuf::uint32 rx_frame_errors() const;
  void set_rx_frame_errors(::google::protobuf::uint32 value);

  // optional uint64 tx_data_bytes = 28;
  bool has_tx_data_bytes() const;
  void clear_tx_data_bytes();
  static const int kTxDataBytesFieldNumber = 28;
  ::google::protobuf::uint64 tx_data_bytes() const;
  void set_tx_data_bytes(::google::protobuf::uint64 value);

  // optional uint32 actual_eirp = 26;
  bool has_actual_eirp() const;
  void clear_actual_eirp();
  static const int kActualEirpFieldNumber = 26;
  ::google::protobuf::uint32 actual_eirp() const;
  void set_actual_eirp(::google::protobuf::uint32 value);

  // optional uint32 radio_band = 30;
  bool has_radio_band() const;
  void clear_radio_band();
  static const int kRadioBandFieldNumber = 30;
  ::google::protobuf::uint32 radio_band() const;
  void set_radio_band(::google::protobuf::uint32 value);

  // optional uint64 rx_data_bytes = 29;
  bool has_rx_data_bytes() const;
  void clear_rx_data_bytes();
  static const int kRxDataBytesFieldNumber = 29;
  ::google::protobuf::uint64 rx_data_bytes() const;
  void set_rx_data_bytes(::google::protobuf::uint64 value);

  // optional uint32 channel_busy_64 = 31;
  bool has_channel_busy_64() const;
  void clear_channel_busy_64();
  static const int kChannelBusy64FieldNumber = 31;
  ::google::protobuf::uint32 channel_busy_64() const;
  void set_channel_busy_64(::google::protobuf::uint32 value);

  // optional uint32 sta_number = 32;
  bool has_sta_number() const;
  void clear_sta_number();
  static const int kStaNumberFieldNumber = 32;
  ::google::protobuf::uint32 sta_number() const;
  void set_sta_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.stats_radio)
 private:
  void set_has_ap_eth_mac();
  void clear_has_ap_eth_mac();
  void set_has_radio_number();
  void clear_has_radio_number();
  void set_has_channel();
  void clear_has_channel();
  void set_has_phy();
  void clear_has_phy();
  void set_has_mode();
  void clear_has_mode();
  void set_has_noise_floor();
  void clear_has_noise_floor();
  void set_has_tx_power();
  void clear_has_tx_power();
  void set_has_channel_utilization();
  void clear_has_channel_utilization();
  void set_has_rx_channel_utilization();
  void clear_has_rx_channel_utilization();
  void set_has_tx_channel_utilization();
  void clear_has_tx_channel_utilization();
  void set_has_tx_received();
  void clear_has_tx_received();
  void set_has_tx_transmitted();
  void clear_has_tx_transmitted();
  void set_has_tx_dropped();
  void clear_has_tx_dropped();
  void set_has_tx_data_received();
  void clear_has_tx_data_received();
  void set_has_tx_data_transmitted();
  void clear_has_tx_data_transmitted();
  void set_has_tx_data_retried();
  void clear_has_tx_data_retried();
  void set_has_rx_frames();
  void clear_has_rx_frames();
  void set_has_rx_retried();
  void clear_has_rx_retried();
  void set_has_rx_data_frames();
  void clear_has_rx_data_frames();
  void set_has_rx_data_retried();
  void clear_has_rx_data_retried();
  void set_has_rx_frame_errors();
  void clear_has_rx_frame_errors();
  void set_has_actual_eirp();
  void clear_has_actual_eirp();
  void set_has_radio_mac();
  void clear_has_radio_mac();
  void set_has_tx_data_bytes();
  void clear_has_tx_data_bytes();
  void set_has_rx_data_bytes();
  void clear_has_rx_data_bytes();
  void set_has_radio_band();
  void clear_has_radio_band();
  void set_has_channel_busy_64();
  void clear_has_channel_busy_64();
  void set_has_sta_number();
  void clear_has_sta_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_traffic_type_stats > traffic_stats_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats > prio_stats_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats > rate_stats_;
  ::ce::nbapi::mac_address* ap_eth_mac_;
  ::ce::nbapi::mac_address* radio_mac_;
  ::google::protobuf::uint32 radio_number_;
  ::google::protobuf::uint32 channel_;
  int phy_;
  int mode_;
  ::google::protobuf::uint32 noise_floor_;
  ::google::protobuf::uint32 tx_power_;
  ::google::protobuf::uint32 channel_utilization_;
  ::google::protobuf::uint32 rx_channel_utilization_;
  ::google::protobuf::uint32 tx_channel_utilization_;
  ::google::protobuf::uint32 tx_received_;
  ::google::protobuf::uint32 tx_transmitted_;
  ::google::protobuf::uint32 tx_dropped_;
  ::google::protobuf::uint32 tx_data_received_;
  ::google::protobuf::uint32 tx_data_transmitted_;
  ::google::protobuf::uint32 tx_data_retried_;
  ::google::protobuf::uint32 rx_frames_;
  ::google::protobuf::uint32 rx_retried_;
  ::google::protobuf::uint32 rx_data_frames_;
  ::google::protobuf::uint32 rx_data_retried_;
  ::google::protobuf::uint32 rx_frame_errors_;
  ::google::protobuf::uint64 tx_data_bytes_;
  ::google::protobuf::uint32 actual_eirp_;
  ::google::protobuf::uint32 radio_band_;
  ::google::protobuf::uint64 rx_data_bytes_;
  ::google::protobuf::uint32 channel_busy_64_;
  ::google::protobuf::uint32 sta_number_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class stats_vap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.stats_vap) */ {
 public:
  stats_vap();
  virtual ~stats_vap();

  stats_vap(const stats_vap& from);

  inline stats_vap& operator=(const stats_vap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  stats_vap(stats_vap&& from) noexcept
    : stats_vap() {
    *this = ::std::move(from);
  }

  inline stats_vap& operator=(stats_vap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stats_vap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const stats_vap* internal_default_instance() {
    return reinterpret_cast<const stats_vap*>(
               &_stats_vap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(stats_vap* other);
  friend void swap(stats_vap& a, stats_vap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline stats_vap* New() const final {
    return CreateMaybeMessage<stats_vap>(NULL);
  }

  stats_vap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<stats_vap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const stats_vap& from);
  void MergeFrom(const stats_vap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(stats_vap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ce.nbapi.data_prio_stats prio_stats = 13;
  int prio_stats_size() const;
  void clear_prio_stats();
  static const int kPrioStatsFieldNumber = 13;
  ::ce::nbapi::data_prio_stats* mutable_prio_stats(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats >*
      mutable_prio_stats();
  const ::ce::nbapi::data_prio_stats& prio_stats(int index) const;
  ::ce::nbapi::data_prio_stats* add_prio_stats();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats >&
      prio_stats() const;

  // repeated .ce.nbapi.data_rate_stats rate_stats = 14;
  int rate_stats_size() const;
  void clear_rate_stats();
  static const int kRateStatsFieldNumber = 14;
  ::ce::nbapi::data_rate_stats* mutable_rate_stats(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats >*
      mutable_rate_stats();
  const ::ce::nbapi::data_rate_stats& rate_stats(int index) const;
  ::ce::nbapi::data_rate_stats* add_rate_stats();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats >&
      rate_stats() const;

  // repeated .ce.nbapi.data_traffic_type_stats traffic_stats = 23;
  int traffic_stats_size() const;
  void clear_traffic_stats();
  static const int kTrafficStatsFieldNumber = 23;
  ::ce::nbapi::data_traffic_type_stats* mutable_traffic_stats(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_traffic_type_stats >*
      mutable_traffic_stats();
  const ::ce::nbapi::data_traffic_type_stats& traffic_stats(int index) const;
  ::ce::nbapi::data_traffic_type_stats* add_traffic_stats();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_traffic_type_stats >&
      traffic_stats() const;

  // optional .ce.nbapi.mac_address ap_eth_mac = 1;
  bool has_ap_eth_mac() const;
  void clear_ap_eth_mac();
  static const int kApEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_eth_mac() const;
  ::ce::nbapi::mac_address* release_ap_eth_mac();
  ::ce::nbapi::mac_address* mutable_ap_eth_mac();
  void set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac);

  // optional .ce.nbapi.mac_address bssid = 2;
  bool has_bssid() const;
  void clear_bssid();
  static const int kBssidFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_bssid() const;
  public:
  const ::ce::nbapi::mac_address& bssid() const;
  ::ce::nbapi::mac_address* release_bssid();
  ::ce::nbapi::mac_address* mutable_bssid();
  void set_allocated_bssid(::ce::nbapi::mac_address* bssid);

  // optional uint32 tx_received = 5;
  bool has_tx_received() const;
  void clear_tx_received();
  static const int kTxReceivedFieldNumber = 5;
  ::google::protobuf::uint32 tx_received() const;
  void set_tx_received(::google::protobuf::uint32 value);

  // optional uint32 tx_transmitted = 6;
  bool has_tx_transmitted() const;
  void clear_tx_transmitted();
  static const int kTxTransmittedFieldNumber = 6;
  ::google::protobuf::uint32 tx_transmitted() const;
  void set_tx_transmitted(::google::protobuf::uint32 value);

  // optional uint32 tx_dropped = 7;
  bool has_tx_dropped() const;
  void clear_tx_dropped();
  static const int kTxDroppedFieldNumber = 7;
  ::google::protobuf::uint32 tx_dropped() const;
  void set_tx_dropped(::google::protobuf::uint32 value);

  // optional uint32 tx_data_received = 8;
  bool has_tx_data_received() const;
  void clear_tx_data_received();
  static const int kTxDataReceivedFieldNumber = 8;
  ::google::protobuf::uint32 tx_data_received() const;
  void set_tx_data_received(::google::protobuf::uint32 value);

  // optional uint32 tx_data_transmitted = 9;
  bool has_tx_data_transmitted() const;
  void clear_tx_data_transmitted();
  static const int kTxDataTransmittedFieldNumber = 9;
  ::google::protobuf::uint32 tx_data_transmitted() const;
  void set_tx_data_transmitted(::google::protobuf::uint32 value);

  // optional uint32 tx_data_retried = 10;
  bool has_tx_data_retried() const;
  void clear_tx_data_retried();
  static const int kTxDataRetriedFieldNumber = 10;
  ::google::protobuf::uint32 tx_data_retried() const;
  void set_tx_data_retried(::google::protobuf::uint32 value);

  // optional uint32 rx_data_frames = 11;
  bool has_rx_data_frames() const;
  void clear_rx_data_frames();
  static const int kRxDataFramesFieldNumber = 11;
  ::google::protobuf::uint32 rx_data_frames() const;
  void set_rx_data_frames(::google::protobuf::uint32 value);

  // optional uint32 rx_data_retried = 12;
  bool has_rx_data_retried() const;
  void clear_rx_data_retried();
  static const int kRxDataRetriedFieldNumber = 12;
  ::google::protobuf::uint32 rx_data_retried() const;
  void set_rx_data_retried(::google::protobuf::uint32 value);

  // optional uint32 sta_number = 15;
  bool has_sta_number() const;
  void clear_sta_number();
  static const int kStaNumberFieldNumber = 15;
  ::google::protobuf::uint32 sta_number() const;
  void set_sta_number(::google::protobuf::uint32 value);

  // optional uint32 rx_frames = 18;
  bool has_rx_frames() const;
  void clear_rx_frames();
  static const int kRxFramesFieldNumber = 18;
  ::google::protobuf::uint32 rx_frames() const;
  void set_rx_frames(::google::protobuf::uint32 value);

  // optional uint32 rx_retried = 19;
  bool has_rx_retried() const;
  void clear_rx_retried();
  static const int kRxRetriedFieldNumber = 19;
  ::google::protobuf::uint32 rx_retried() const;
  void set_rx_retried(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.stats_vap)
 private:
  void set_has_ap_eth_mac();
  void clear_has_ap_eth_mac();
  void set_has_bssid();
  void clear_has_bssid();
  void set_has_tx_received();
  void clear_has_tx_received();
  void set_has_tx_transmitted();
  void clear_has_tx_transmitted();
  void set_has_tx_dropped();
  void clear_has_tx_dropped();
  void set_has_tx_data_received();
  void clear_has_tx_data_received();
  void set_has_tx_data_transmitted();
  void clear_has_tx_data_transmitted();
  void set_has_tx_data_retried();
  void clear_has_tx_data_retried();
  void set_has_rx_frames();
  void clear_has_rx_frames();
  void set_has_rx_retried();
  void clear_has_rx_retried();
  void set_has_rx_data_frames();
  void clear_has_rx_data_frames();
  void set_has_rx_data_retried();
  void clear_has_rx_data_retried();
  void set_has_sta_number();
  void clear_has_sta_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats > prio_stats_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats > rate_stats_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_traffic_type_stats > traffic_stats_;
  ::ce::nbapi::mac_address* ap_eth_mac_;
  ::ce::nbapi::mac_address* bssid_;
  ::google::protobuf::uint32 tx_received_;
  ::google::protobuf::uint32 tx_transmitted_;
  ::google::protobuf::uint32 tx_dropped_;
  ::google::protobuf::uint32 tx_data_received_;
  ::google::protobuf::uint32 tx_data_transmitted_;
  ::google::protobuf::uint32 tx_data_retried_;
  ::google::protobuf::uint32 rx_data_frames_;
  ::google::protobuf::uint32 rx_data_retried_;
  ::google::protobuf::uint32 sta_number_;
  ::google::protobuf::uint32 rx_frames_;
  ::google::protobuf::uint32 rx_retried_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class stats_station : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.stats_station) */ {
 public:
  stats_station();
  virtual ~stats_station();

  stats_station(const stats_station& from);

  inline stats_station& operator=(const stats_station& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  stats_station(stats_station&& from) noexcept
    : stats_station() {
    *this = ::std::move(from);
  }

  inline stats_station& operator=(stats_station&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stats_station& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const stats_station* internal_default_instance() {
    return reinterpret_cast<const stats_station*>(
               &_stats_station_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(stats_station* other);
  friend void swap(stats_station& a, stats_station& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline stats_station* New() const final {
    return CreateMaybeMessage<stats_station>(NULL);
  }

  stats_station* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<stats_station>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const stats_station& from);
  void MergeFrom(const stats_station& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(stats_station* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ce.nbapi.data_prio_stats prio_stats = 13;
  int prio_stats_size() const;
  void clear_prio_stats();
  static const int kPrioStatsFieldNumber = 13;
  ::ce::nbapi::data_prio_stats* mutable_prio_stats(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats >*
      mutable_prio_stats();
  const ::ce::nbapi::data_prio_stats& prio_stats(int index) const;
  ::ce::nbapi::data_prio_stats* add_prio_stats();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats >&
      prio_stats() const;

  // repeated .ce.nbapi.data_rate_stats rate_stats = 14;
  int rate_stats_size() const;
  void clear_rate_stats();
  static const int kRateStatsFieldNumber = 14;
  ::ce::nbapi::data_rate_stats* mutable_rate_stats(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats >*
      mutable_rate_stats();
  const ::ce::nbapi::data_rate_stats& rate_stats(int index) const;
  ::ce::nbapi::data_rate_stats* add_rate_stats();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats >&
      rate_stats() const;

  // optional bytes hashed_sta_eth_mac = 22;
  bool has_hashed_sta_eth_mac() const;
  void clear_hashed_sta_eth_mac();
  static const int kHashedStaEthMacFieldNumber = 22;
  const ::std::string& hashed_sta_eth_mac() const;
  void set_hashed_sta_eth_mac(const ::std::string& value);
  #if LANG_CXX11
  void set_hashed_sta_eth_mac(::std::string&& value);
  #endif
  void set_hashed_sta_eth_mac(const char* value);
  void set_hashed_sta_eth_mac(const void* value, size_t size);
  ::std::string* mutable_hashed_sta_eth_mac();
  ::std::string* release_hashed_sta_eth_mac();
  void set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac);

  // optional .ce.nbapi.mac_address sta_eth_mac = 1;
  bool has_sta_eth_mac() const;
  void clear_sta_eth_mac();
  static const int kStaEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_sta_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& sta_eth_mac() const;
  ::ce::nbapi::mac_address* release_sta_eth_mac();
  ::ce::nbapi::mac_address* mutable_sta_eth_mac();
  void set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac);

  // optional .ce.nbapi.mac_address ap_eth_mac = 2;
  bool has_ap_eth_mac() const;
  void clear_ap_eth_mac();
  static const int kApEthMacFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_eth_mac() const;
  ::ce::nbapi::mac_address* release_ap_eth_mac();
  ::ce::nbapi::mac_address* mutable_ap_eth_mac();
  void set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac);

  // optional .ce.nbapi.mac_address bssid = 3;
  bool has_bssid() const;
  void clear_bssid();
  static const int kBssidFieldNumber = 3;
  private:
  const ::ce::nbapi::mac_address& _internal_bssid() const;
  public:
  const ::ce::nbapi::mac_address& bssid() const;
  ::ce::nbapi::mac_address* release_bssid();
  ::ce::nbapi::mac_address* mutable_bssid();
  void set_allocated_bssid(::ce::nbapi::mac_address* bssid);

  // optional uint32 snr = 4;
  bool has_snr() const;
  void clear_snr();
  static const int kSnrFieldNumber = 4;
  ::google::protobuf::uint32 snr() const;
  void set_snr(::google::protobuf::uint32 value);

  // optional uint32 tx_received = 5;
  bool has_tx_received() const;
  void clear_tx_received();
  static const int kTxReceivedFieldNumber = 5;
  ::google::protobuf::uint32 tx_received() const;
  void set_tx_received(::google::protobuf::uint32 value);

  // optional uint32 tx_transmitted = 6;
  bool has_tx_transmitted() const;
  void clear_tx_transmitted();
  static const int kTxTransmittedFieldNumber = 6;
  ::google::protobuf::uint32 tx_transmitted() const;
  void set_tx_transmitted(::google::protobuf::uint32 value);

  // optional uint32 tx_dropped = 7;
  bool has_tx_dropped() const;
  void clear_tx_dropped();
  static const int kTxDroppedFieldNumber = 7;
  ::google::protobuf::uint32 tx_dropped() const;
  void set_tx_dropped(::google::protobuf::uint32 value);

  // optional uint32 tx_data_received = 8;
  bool has_tx_data_received() const;
  void clear_tx_data_received();
  static const int kTxDataReceivedFieldNumber = 8;
  ::google::protobuf::uint32 tx_data_received() const;
  void set_tx_data_received(::google::protobuf::uint32 value);

  // optional uint32 tx_data_transmitted = 9;
  bool has_tx_data_transmitted() const;
  void clear_tx_data_transmitted();
  static const int kTxDataTransmittedFieldNumber = 9;
  ::google::protobuf::uint32 tx_data_transmitted() const;
  void set_tx_data_transmitted(::google::protobuf::uint32 value);

  // optional uint32 tx_data_retried = 10;
  bool has_tx_data_retried() const;
  void clear_tx_data_retried();
  static const int kTxDataRetriedFieldNumber = 10;
  ::google::protobuf::uint32 tx_data_retried() const;
  void set_tx_data_retried(::google::protobuf::uint32 value);

  // optional uint32 rx_data_received = 11;
  bool has_rx_data_received() const;
  void clear_rx_data_received();
  static const int kRxDataReceivedFieldNumber = 11;
  ::google::protobuf::uint32 rx_data_received() const;
  void set_rx_data_received(::google::protobuf::uint32 value);

  // optional uint32 rx_data_retried = 12;
  bool has_rx_data_retried() const;
  void clear_rx_data_retried();
  static const int kRxDataRetriedFieldNumber = 12;
  ::google::protobuf::uint32 rx_data_retried() const;
  void set_rx_data_retried(::google::protobuf::uint32 value);

  // optional uint32 speed = 15;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 15;
  ::google::protobuf::uint32 speed() const;
  void set_speed(::google::protobuf::uint32 value);

  // optional uint64 rx_rate = 16;
  bool has_rx_rate() const;
  void clear_rx_rate();
  static const int kRxRateFieldNumber = 16;
  ::google::protobuf::uint64 rx_rate() const;
  void set_rx_rate(::google::protobuf::uint64 value);

  // optional uint64 tx_rate = 17;
  bool has_tx_rate() const;
  void clear_tx_rate();
  static const int kTxRateFieldNumber = 17;
  ::google::protobuf::uint64 tx_rate() const;
  void set_tx_rate(::google::protobuf::uint64 value);

  // optional uint64 rx_data_bytes = 18;
  bool has_rx_data_bytes() const;
  void clear_rx_data_bytes();
  static const int kRxDataBytesFieldNumber = 18;
  ::google::protobuf::uint64 rx_data_bytes() const;
  void set_rx_data_bytes(::google::protobuf::uint64 value);

  // optional uint64 tx_data_bytes = 19;
  bool has_tx_data_bytes() const;
  void clear_tx_data_bytes();
  static const int kTxDataBytesFieldNumber = 19;
  ::google::protobuf::uint64 tx_data_bytes() const;
  void set_tx_data_bytes(::google::protobuf::uint64 value);

  // optional uint32 ssid_up = 20;
  bool has_ssid_up() const;
  void clear_ssid_up();
  static const int kSsidUpFieldNumber = 20;
  ::google::protobuf::uint32 ssid_up() const;
  void set_ssid_up(::google::protobuf::uint32 value);

  // optional uint32 tx_time_data = 25;
  bool has_tx_time_data() const;
  void clear_tx_time_data();
  static const int kTxTimeDataFieldNumber = 25;
  ::google::protobuf::uint32 tx_time_data() const;
  void set_tx_time_data(::google::protobuf::uint32 value);

  // optional uint64 max_tx_rate = 23;
  bool has_max_tx_rate() const;
  void clear_max_tx_rate();
  static const int kMaxTxRateFieldNumber = 23;
  ::google::protobuf::uint64 max_tx_rate() const;
  void set_max_tx_rate(::google::protobuf::uint64 value);

  // optional uint64 tx_data_bytes_transmitted = 24;
  bool has_tx_data_bytes_transmitted() const;
  void clear_tx_data_bytes_transmitted();
  static const int kTxDataBytesTransmittedFieldNumber = 24;
  ::google::protobuf::uint64 tx_data_bytes_transmitted() const;
  void set_tx_data_bytes_transmitted(::google::protobuf::uint64 value);

  // optional uint32 rx_time_data = 26;
  bool has_rx_time_data() const;
  void clear_rx_time_data();
  static const int kRxTimeDataFieldNumber = 26;
  ::google::protobuf::uint32 rx_time_data() const;
  void set_rx_time_data(::google::protobuf::uint32 value);

  // optional uint32 sta_client_health = 27;
  bool has_sta_client_health() const;
  void clear_sta_client_health();
  static const int kStaClientHealthFieldNumber = 27;
  ::google::protobuf::uint32 sta_client_health() const;
  void set_sta_client_health(::google::protobuf::uint32 value);

  // optional uint32 rx_retries = 28;
  bool has_rx_retries() const;
  void clear_rx_retries();
  static const int kRxRetriesFieldNumber = 28;
  ::google::protobuf::uint32 rx_retries() const;
  void set_rx_retries(::google::protobuf::uint32 value);

  // optional uint32 tx_retries = 29;
  bool has_tx_retries() const;
  void clear_tx_retries();
  static const int kTxRetriesFieldNumber = 29;
  ::google::protobuf::uint32 tx_retries() const;
  void set_tx_retries(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.stats_station)
 private:
  void set_has_sta_eth_mac();
  void clear_has_sta_eth_mac();
  void set_has_ap_eth_mac();
  void clear_has_ap_eth_mac();
  void set_has_bssid();
  void clear_has_bssid();
  void set_has_snr();
  void clear_has_snr();
  void set_has_tx_received();
  void clear_has_tx_received();
  void set_has_tx_transmitted();
  void clear_has_tx_transmitted();
  void set_has_tx_dropped();
  void clear_has_tx_dropped();
  void set_has_tx_data_received();
  void clear_has_tx_data_received();
  void set_has_tx_data_transmitted();
  void clear_has_tx_data_transmitted();
  void set_has_tx_data_retried();
  void clear_has_tx_data_retried();
  void set_has_rx_data_received();
  void clear_has_rx_data_received();
  void set_has_rx_data_retried();
  void clear_has_rx_data_retried();
  void set_has_speed();
  void clear_has_speed();
  void set_has_rx_rate();
  void clear_has_rx_rate();
  void set_has_tx_rate();
  void clear_has_tx_rate();
  void set_has_rx_data_bytes();
  void clear_has_rx_data_bytes();
  void set_has_tx_data_bytes();
  void clear_has_tx_data_bytes();
  void set_has_ssid_up();
  void clear_has_ssid_up();
  void set_has_hashed_sta_eth_mac();
  void clear_has_hashed_sta_eth_mac();
  void set_has_max_tx_rate();
  void clear_has_max_tx_rate();
  void set_has_tx_data_bytes_transmitted();
  void clear_has_tx_data_bytes_transmitted();
  void set_has_tx_time_data();
  void clear_has_tx_time_data();
  void set_has_rx_time_data();
  void clear_has_rx_time_data();
  void set_has_sta_client_health();
  void clear_has_sta_client_health();
  void set_has_rx_retries();
  void clear_has_rx_retries();
  void set_has_tx_retries();
  void clear_has_tx_retries();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats > prio_stats_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats > rate_stats_;
  ::google::protobuf::internal::ArenaStringPtr hashed_sta_eth_mac_;
  ::ce::nbapi::mac_address* sta_eth_mac_;
  ::ce::nbapi::mac_address* ap_eth_mac_;
  ::ce::nbapi::mac_address* bssid_;
  ::google::protobuf::uint32 snr_;
  ::google::protobuf::uint32 tx_received_;
  ::google::protobuf::uint32 tx_transmitted_;
  ::google::protobuf::uint32 tx_dropped_;
  ::google::protobuf::uint32 tx_data_received_;
  ::google::protobuf::uint32 tx_data_transmitted_;
  ::google::protobuf::uint32 tx_data_retried_;
  ::google::protobuf::uint32 rx_data_received_;
  ::google::protobuf::uint32 rx_data_retried_;
  ::google::protobuf::uint32 speed_;
  ::google::protobuf::uint64 rx_rate_;
  ::google::protobuf::uint64 tx_rate_;
  ::google::protobuf::uint64 rx_data_bytes_;
  ::google::protobuf::uint64 tx_data_bytes_;
  ::google::protobuf::uint32 ssid_up_;
  ::google::protobuf::uint32 tx_time_data_;
  ::google::protobuf::uint64 max_tx_rate_;
  ::google::protobuf::uint64 tx_data_bytes_transmitted_;
  ::google::protobuf::uint32 rx_time_data_;
  ::google::protobuf::uint32 sta_client_health_;
  ::google::protobuf::uint32 rx_retries_;
  ::google::protobuf::uint32 tx_retries_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class state_station : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.state_station) */ {
 public:
  state_station();
  virtual ~state_station();

  state_station(const state_station& from);

  inline state_station& operator=(const state_station& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  state_station(state_station&& from) noexcept
    : state_station() {
    *this = ::std::move(from);
  }

  inline state_station& operator=(state_station&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const state_station& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const state_station* internal_default_instance() {
    return reinterpret_cast<const state_station*>(
               &_state_station_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(state_station* other);
  friend void swap(state_station& a, state_station& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline state_station* New() const final {
    return CreateMaybeMessage<state_station>(NULL);
  }

  state_station* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<state_station>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const state_station& from);
  void MergeFrom(const state_station& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(state_station* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes hashed_sta_eth_mac = 8;
  bool has_hashed_sta_eth_mac() const;
  void clear_hashed_sta_eth_mac();
  static const int kHashedStaEthMacFieldNumber = 8;
  const ::std::string& hashed_sta_eth_mac() const;
  void set_hashed_sta_eth_mac(const ::std::string& value);
  #if LANG_CXX11
  void set_hashed_sta_eth_mac(::std::string&& value);
  #endif
  void set_hashed_sta_eth_mac(const char* value);
  void set_hashed_sta_eth_mac(const void* value, size_t size);
  ::std::string* mutable_hashed_sta_eth_mac();
  ::std::string* release_hashed_sta_eth_mac();
  void set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac);

  // optional .ce.nbapi.mac_address sta_eth_mac = 1;
  bool has_sta_eth_mac() const;
  void clear_sta_eth_mac();
  static const int kStaEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_sta_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& sta_eth_mac() const;
  ::ce::nbapi::mac_address* release_sta_eth_mac();
  ::ce::nbapi::mac_address* mutable_sta_eth_mac();
  void set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac);

  // optional .ce.nbapi.mac_address ap_eth_mac = 2;
  bool has_ap_eth_mac() const;
  void clear_ap_eth_mac();
  static const int kApEthMacFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_eth_mac() const;
  ::ce::nbapi::mac_address* release_ap_eth_mac();
  ::ce::nbapi::mac_address* mutable_ap_eth_mac();
  void set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac);

  // optional uint32 snr = 3;
  bool has_snr() const;
  void clear_snr();
  static const int kSnrFieldNumber = 3;
  ::google::protobuf::uint32 snr() const;
  void set_snr(::google::protobuf::uint32 value);

  // optional uint32 rx_tries = 4;
  bool has_rx_tries() const;
  void clear_rx_tries();
  static const int kRxTriesFieldNumber = 4;
  ::google::protobuf::uint32 rx_tries() const;
  void set_rx_tries(::google::protobuf::uint32 value);

  // optional uint32 tx_tries = 5;
  bool has_tx_tries() const;
  void clear_tx_tries();
  static const int kTxTriesFieldNumber = 5;
  ::google::protobuf::uint32 tx_tries() const;
  void set_tx_tries(::google::protobuf::uint32 value);

  // optional .ce.nbapi.phy_type phy_type = 6;
  bool has_phy_type() const;
  void clear_phy_type();
  static const int kPhyTypeFieldNumber = 6;
  ::ce::nbapi::phy_type phy_type() const;
  void set_phy_type(::ce::nbapi::phy_type value);

  // optional uint32 security_type = 7;
  bool has_security_type() const;
  void clear_security_type();
  static const int kSecurityTypeFieldNumber = 7;
  ::google::protobuf::uint32 security_type() const;
  void set_security_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.state_station)
 private:
  void set_has_sta_eth_mac();
  void clear_has_sta_eth_mac();
  void set_has_ap_eth_mac();
  void clear_has_ap_eth_mac();
  void set_has_snr();
  void clear_has_snr();
  void set_has_rx_tries();
  void clear_has_rx_tries();
  void set_has_tx_tries();
  void clear_has_tx_tries();
  void set_has_phy_type();
  void clear_has_phy_type();
  void set_has_security_type();
  void clear_has_security_type();
  void set_has_hashed_sta_eth_mac();
  void clear_has_hashed_sta_eth_mac();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr hashed_sta_eth_mac_;
  ::ce::nbapi::mac_address* sta_eth_mac_;
  ::ce::nbapi::mac_address* ap_eth_mac_;
  ::google::protobuf::uint32 snr_;
  ::google::protobuf::uint32 rx_tries_;
  ::google::protobuf::uint32 tx_tries_;
  int phy_type_;
  ::google::protobuf::uint32 security_type_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class uplink_bandwidth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.uplink_bandwidth) */ {
 public:
  uplink_bandwidth();
  virtual ~uplink_bandwidth();

  uplink_bandwidth(const uplink_bandwidth& from);

  inline uplink_bandwidth& operator=(const uplink_bandwidth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  uplink_bandwidth(uplink_bandwidth&& from) noexcept
    : uplink_bandwidth() {
    *this = ::std::move(from);
  }

  inline uplink_bandwidth& operator=(uplink_bandwidth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const uplink_bandwidth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const uplink_bandwidth* internal_default_instance() {
    return reinterpret_cast<const uplink_bandwidth*>(
               &_uplink_bandwidth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(uplink_bandwidth* other);
  friend void swap(uplink_bandwidth& a, uplink_bandwidth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline uplink_bandwidth* New() const final {
    return CreateMaybeMessage<uplink_bandwidth>(NULL);
  }

  uplink_bandwidth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<uplink_bandwidth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const uplink_bandwidth& from);
  void MergeFrom(const uplink_bandwidth& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(uplink_bandwidth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ap_name = 6;
  bool has_ap_name() const;
  void clear_ap_name();
  static const int kApNameFieldNumber = 6;
  const ::std::string& ap_name() const;
  void set_ap_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ap_name(::std::string&& value);
  #endif
  void set_ap_name(const char* value);
  void set_ap_name(const char* value, size_t size);
  ::std::string* mutable_ap_name();
  ::std::string* release_ap_name();
  void set_allocated_ap_name(::std::string* ap_name);

  // optional string protocol = 8;
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 8;
  const ::std::string& protocol() const;
  void set_protocol(const ::std::string& value);
  #if LANG_CXX11
  void set_protocol(::std::string&& value);
  #endif
  void set_protocol(const char* value);
  void set_protocol(const char* value, size_t size);
  ::std::string* mutable_protocol();
  ::std::string* release_protocol();
  void set_allocated_protocol(::std::string* protocol);

  // optional string upstream_jitter = 18;
  bool has_upstream_jitter() const;
  void clear_upstream_jitter();
  static const int kUpstreamJitterFieldNumber = 18;
  const ::std::string& upstream_jitter() const;
  void set_upstream_jitter(const ::std::string& value);
  #if LANG_CXX11
  void set_upstream_jitter(::std::string&& value);
  #endif
  void set_upstream_jitter(const char* value);
  void set_upstream_jitter(const char* value, size_t size);
  ::std::string* mutable_upstream_jitter();
  ::std::string* release_upstream_jitter();
  void set_allocated_upstream_jitter(::std::string* upstream_jitter);

  // optional string downstream_jitter = 19;
  bool has_downstream_jitter() const;
  void clear_downstream_jitter();
  static const int kDownstreamJitterFieldNumber = 19;
  const ::std::string& downstream_jitter() const;
  void set_downstream_jitter(const ::std::string& value);
  #if LANG_CXX11
  void set_downstream_jitter(::std::string&& value);
  #endif
  void set_downstream_jitter(const char* value);
  void set_downstream_jitter(const char* value, size_t size);
  ::std::string* mutable_downstream_jitter();
  ::std::string* release_downstream_jitter();
  void set_allocated_downstream_jitter(::std::string* downstream_jitter);

  // optional bytes hashed_ap_eth_mac = 22;
  bool has_hashed_ap_eth_mac() const;
  void clear_hashed_ap_eth_mac();
  static const int kHashedApEthMacFieldNumber = 22;
  const ::std::string& hashed_ap_eth_mac() const;
  void set_hashed_ap_eth_mac(const ::std::string& value);
  #if LANG_CXX11
  void set_hashed_ap_eth_mac(::std::string&& value);
  #endif
  void set_hashed_ap_eth_mac(const char* value);
  void set_hashed_ap_eth_mac(const void* value, size_t size);
  ::std::string* mutable_hashed_ap_eth_mac();
  ::std::string* release_hashed_ap_eth_mac();
  void set_allocated_hashed_ap_eth_mac(::std::string* hashed_ap_eth_mac);

  // optional .ce.nbapi.ip_address server_ip = 1;
  bool has_server_ip() const;
  void clear_server_ip();
  static const int kServerIpFieldNumber = 1;
  private:
  const ::ce::nbapi::ip_address& _internal_server_ip() const;
  public:
  const ::ce::nbapi::ip_address& server_ip() const;
  ::ce::nbapi::ip_address* release_server_ip();
  ::ce::nbapi::ip_address* mutable_server_ip();
  void set_allocated_server_ip(::ce::nbapi::ip_address* server_ip);

  // optional .ce.nbapi.ip_address local_ip = 3;
  bool has_local_ip() const;
  void clear_local_ip();
  static const int kLocalIpFieldNumber = 3;
  private:
  const ::ce::nbapi::ip_address& _internal_local_ip() const;
  public:
  const ::ce::nbapi::ip_address& local_ip() const;
  ::ce::nbapi::ip_address* release_local_ip();
  ::ce::nbapi::ip_address* mutable_local_ip();
  void set_allocated_local_ip(::ce::nbapi::ip_address* local_ip);

  // optional .ce.nbapi.mac_address ap_mac = 5;
  bool has_ap_mac() const;
  void clear_ap_mac();
  static const int kApMacFieldNumber = 5;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_mac() const;
  ::ce::nbapi::mac_address* release_ap_mac();
  ::ce::nbapi::mac_address* mutable_ap_mac();
  void set_allocated_ap_mac(::ce::nbapi::mac_address* ap_mac);

  // optional uint32 server_port = 2;
  bool has_server_port() const;
  void clear_server_port();
  static const int kServerPortFieldNumber = 2;
  ::google::protobuf::uint32 server_port() const;
  void set_server_port(::google::protobuf::uint32 value);

  // optional uint32 local_port = 4;
  bool has_local_port() const;
  void clear_local_port();
  static const int kLocalPortFieldNumber = 4;
  ::google::protobuf::uint32 local_port() const;
  void set_local_port(::google::protobuf::uint32 value);

  // optional uint64 timestamp = 7;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 7;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional uint32 interval = 9;
  bool has_interval() const;
  void clear_interval();
  static const int kIntervalFieldNumber = 9;
  ::google::protobuf::uint32 interval() const;
  void set_interval(::google::protobuf::uint32 value);

  // optional uint32 upstream_bytes = 10;
  bool has_upstream_bytes() const;
  void clear_upstream_bytes();
  static const int kUpstreamBytesFieldNumber = 10;
  ::google::protobuf::uint32 upstream_bytes() const;
  void set_upstream_bytes(::google::protobuf::uint32 value);

  // optional uint32 upstream_bandwidth = 11;
  bool has_upstream_bandwidth() const;
  void clear_upstream_bandwidth();
  static const int kUpstreamBandwidthFieldNumber = 11;
  ::google::protobuf::uint32 upstream_bandwidth() const;
  void set_upstream_bandwidth(::google::protobuf::uint32 value);

  // optional uint32 upstream_retries = 12;
  bool has_upstream_retries() const;
  void clear_upstream_retries();
  static const int kUpstreamRetriesFieldNumber = 12;
  ::google::protobuf::uint32 upstream_retries() const;
  void set_upstream_retries(::google::protobuf::uint32 value);

  // optional uint32 downstream_bytes = 13;
  bool has_downstream_bytes() const;
  void clear_downstream_bytes();
  static const int kDownstreamBytesFieldNumber = 13;
  ::google::protobuf::uint32 downstream_bytes() const;
  void set_downstream_bytes(::google::protobuf::uint32 value);

  // optional uint32 downstream_bandwidth = 14;
  bool has_downstream_bandwidth() const;
  void clear_downstream_bandwidth();
  static const int kDownstreamBandwidthFieldNumber = 14;
  ::google::protobuf::uint32 downstream_bandwidth() const;
  void set_downstream_bandwidth(::google::protobuf::uint32 value);

  // optional uint32 downstream_retries = 15;
  bool has_downstream_retries() const;
  void clear_downstream_retries();
  static const int kDownstreamRetriesFieldNumber = 15;
  ::google::protobuf::uint32 downstream_retries() const;
  void set_downstream_retries(::google::protobuf::uint32 value);

  // optional uint32 upstream_datagrams = 16;
  bool has_upstream_datagrams() const;
  void clear_upstream_datagrams();
  static const int kUpstreamDatagramsFieldNumber = 16;
  ::google::protobuf::uint32 upstream_datagrams() const;
  void set_upstream_datagrams(::google::protobuf::uint32 value);

  // optional uint32 downstream_datagrams = 17;
  bool has_downstream_datagrams() const;
  void clear_downstream_datagrams();
  static const int kDownstreamDatagramsFieldNumber = 17;
  ::google::protobuf::uint32 downstream_datagrams() const;
  void set_downstream_datagrams(::google::protobuf::uint32 value);

  // optional uint32 upstream_lost_packets = 20;
  bool has_upstream_lost_packets() const;
  void clear_upstream_lost_packets();
  static const int kUpstreamLostPacketsFieldNumber = 20;
  ::google::protobuf::uint32 upstream_lost_packets() const;
  void set_upstream_lost_packets(::google::protobuf::uint32 value);

  // optional uint32 downstream_lost_packets = 21;
  bool has_downstream_lost_packets() const;
  void clear_downstream_lost_packets();
  static const int kDownstreamLostPacketsFieldNumber = 21;
  ::google::protobuf::uint32 downstream_lost_packets() const;
  void set_downstream_lost_packets(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.uplink_bandwidth)
 private:
  void set_has_server_ip();
  void clear_has_server_ip();
  void set_has_server_port();
  void clear_has_server_port();
  void set_has_local_ip();
  void clear_has_local_ip();
  void set_has_local_port();
  void clear_has_local_port();
  void set_has_ap_mac();
  void clear_has_ap_mac();
  void set_has_ap_name();
  void clear_has_ap_name();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_protocol();
  void clear_has_protocol();
  void set_has_interval();
  void clear_has_interval();
  void set_has_upstream_bytes();
  void clear_has_upstream_bytes();
  void set_has_upstream_bandwidth();
  void clear_has_upstream_bandwidth();
  void set_has_upstream_retries();
  void clear_has_upstream_retries();
  void set_has_downstream_bytes();
  void clear_has_downstream_bytes();
  void set_has_downstream_bandwidth();
  void clear_has_downstream_bandwidth();
  void set_has_downstream_retries();
  void clear_has_downstream_retries();
  void set_has_upstream_datagrams();
  void clear_has_upstream_datagrams();
  void set_has_downstream_datagrams();
  void clear_has_downstream_datagrams();
  void set_has_upstream_jitter();
  void clear_has_upstream_jitter();
  void set_has_downstream_jitter();
  void clear_has_downstream_jitter();
  void set_has_upstream_lost_packets();
  void clear_has_upstream_lost_packets();
  void set_has_downstream_lost_packets();
  void clear_has_downstream_lost_packets();
  void set_has_hashed_ap_eth_mac();
  void clear_has_hashed_ap_eth_mac();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ap_name_;
  ::google::protobuf::internal::ArenaStringPtr protocol_;
  ::google::protobuf::internal::ArenaStringPtr upstream_jitter_;
  ::google::protobuf::internal::ArenaStringPtr downstream_jitter_;
  ::google::protobuf::internal::ArenaStringPtr hashed_ap_eth_mac_;
  ::ce::nbapi::ip_address* server_ip_;
  ::ce::nbapi::ip_address* local_ip_;
  ::ce::nbapi::mac_address* ap_mac_;
  ::google::protobuf::uint32 server_port_;
  ::google::protobuf::uint32 local_port_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 interval_;
  ::google::protobuf::uint32 upstream_bytes_;
  ::google::protobuf::uint32 upstream_bandwidth_;
  ::google::protobuf::uint32 upstream_retries_;
  ::google::protobuf::uint32 downstream_bytes_;
  ::google::protobuf::uint32 downstream_bandwidth_;
  ::google::protobuf::uint32 downstream_retries_;
  ::google::protobuf::uint32 upstream_datagrams_;
  ::google::protobuf::uint32 downstream_datagrams_;
  ::google::protobuf::uint32 upstream_lost_packets_;
  ::google::protobuf::uint32 downstream_lost_packets_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class uplink_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.uplink_info) */ {
 public:
  uplink_info();
  virtual ~uplink_info();

  uplink_info(const uplink_info& from);

  inline uplink_info& operator=(const uplink_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  uplink_info(uplink_info&& from) noexcept
    : uplink_info() {
    *this = ::std::move(from);
  }

  inline uplink_info& operator=(uplink_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const uplink_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const uplink_info* internal_default_instance() {
    return reinterpret_cast<const uplink_info*>(
               &_uplink_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(uplink_info* other);
  friend void swap(uplink_info& a, uplink_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline uplink_info* New() const final {
    return CreateMaybeMessage<uplink_info>(NULL);
  }

  uplink_info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<uplink_info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const uplink_info& from);
  void MergeFrom(const uplink_info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(uplink_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string desc = 3;
  bool has_desc() const;
  void clear_desc();
  static const int kDescFieldNumber = 3;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // optional string port_tunnel_desc = 6;
  bool has_port_tunnel_desc() const;
  void clear_port_tunnel_desc();
  static const int kPortTunnelDescFieldNumber = 6;
  const ::std::string& port_tunnel_desc() const;
  void set_port_tunnel_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_port_tunnel_desc(::std::string&& value);
  #endif
  void set_port_tunnel_desc(const char* value);
  void set_port_tunnel_desc(const char* value, size_t size);
  ::std::string* mutable_port_tunnel_desc();
  ::std::string* release_port_tunnel_desc();
  void set_allocated_port_tunnel_desc(::std::string* port_tunnel_desc);

  // optional string tunnel_name = 14;
  bool has_tunnel_name() const;
  void clear_tunnel_name();
  static const int kTunnelNameFieldNumber = 14;
  const ::std::string& tunnel_name() const;
  void set_tunnel_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tunnel_name(::std::string&& value);
  #endif
  void set_tunnel_name(const char* value);
  void set_tunnel_name(const char* value, size_t size);
  ::std::string* mutable_tunnel_name();
  ::std::string* release_tunnel_name();
  void set_allocated_tunnel_name(::std::string* tunnel_name);

  // optional .ce.nbapi.mac_address device_mac = 1;
  bool has_device_mac() const;
  void clear_device_mac();
  static const int kDeviceMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_device_mac() const;
  public:
  const ::ce::nbapi::mac_address& device_mac() const;
  ::ce::nbapi::mac_address* release_device_mac();
  ::ce::nbapi::mac_address* mutable_device_mac();
  void set_allocated_device_mac(::ce::nbapi::mac_address* device_mac);

  // optional .ce.nbapi.ip_address peer_tunnel_ip = 12;
  bool has_peer_tunnel_ip() const;
  void clear_peer_tunnel_ip();
  static const int kPeerTunnelIpFieldNumber = 12;
  private:
  const ::ce::nbapi::ip_address& _internal_peer_tunnel_ip() const;
  public:
  const ::ce::nbapi::ip_address& peer_tunnel_ip() const;
  ::ce::nbapi::ip_address* release_peer_tunnel_ip();
  ::ce::nbapi::ip_address* mutable_peer_tunnel_ip();
  void set_allocated_peer_tunnel_ip(::ce::nbapi::ip_address* peer_tunnel_ip);

  // optional .ce.nbapi.ip_address tunnel_ip = 13;
  bool has_tunnel_ip() const;
  void clear_tunnel_ip();
  static const int kTunnelIpFieldNumber = 13;
  private:
  const ::ce::nbapi::ip_address& _internal_tunnel_ip() const;
  public:
  const ::ce::nbapi::ip_address& tunnel_ip() const;
  ::ce::nbapi::ip_address* release_tunnel_ip();
  ::ce::nbapi::ip_address* mutable_tunnel_ip();
  void set_allocated_tunnel_ip(::ce::nbapi::ip_address* tunnel_ip);

  // optional uint64 link_id = 2;
  bool has_link_id() const;
  void clear_link_id();
  static const int kLinkIdFieldNumber = 2;
  ::google::protobuf::uint64 link_id() const;
  void set_link_id(::google::protobuf::uint64 value);

  // optional uint64 vlan_id = 5;
  bool has_vlan_id() const;
  void clear_vlan_id();
  static const int kVlanIdFieldNumber = 5;
  ::google::protobuf::uint64 vlan_id() const;
  void set_vlan_id(::google::protobuf::uint64 value);

  // optional uint32 link_status = 4;
  bool has_link_status() const;
  void clear_link_status();
  static const int kLinkStatusFieldNumber = 4;
  ::google::protobuf::uint32 link_status() const;
  void set_link_status(::google::protobuf::uint32 value);

  // optional uint32 link_prio = 7;
  bool has_link_prio() const;
  void clear_link_prio();
  static const int kLinkPrioFieldNumber = 7;
  ::google::protobuf::uint32 link_prio() const;
  void set_link_prio(::google::protobuf::uint32 value);

  // optional uint32 wan_status = 8;
  bool has_wan_status() const;
  void clear_wan_status();
  static const int kWanStatusFieldNumber = 8;
  ::google::protobuf::uint32 wan_status() const;
  void set_wan_status(::google::protobuf::uint32 value);

  // optional uint32 crypto_type = 9;
  bool has_crypto_type() const;
  void clear_crypto_type();
  static const int kCryptoTypeFieldNumber = 9;
  ::google::protobuf::uint32 crypto_type() const;
  void set_crypto_type(::google::protobuf::uint32 value);

  // optional uint64 tunnel_uptime = 11;
  bool has_tunnel_uptime() const;
  void clear_tunnel_uptime();
  static const int kTunnelUptimeFieldNumber = 11;
  ::google::protobuf::uint64 tunnel_uptime() const;
  void set_tunnel_uptime(::google::protobuf::uint64 value);

  // optional uint32 tunnel_active_status = 10;
  bool has_tunnel_active_status() const;
  void clear_tunnel_active_status();
  static const int kTunnelActiveStatusFieldNumber = 10;
  ::google::protobuf::uint32 tunnel_active_status() const;
  void set_tunnel_active_status(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.uplink_info)
 private:
  void set_has_device_mac();
  void clear_has_device_mac();
  void set_has_link_id();
  void clear_has_link_id();
  void set_has_desc();
  void clear_has_desc();
  void set_has_link_status();
  void clear_has_link_status();
  void set_has_vlan_id();
  void clear_has_vlan_id();
  void set_has_port_tunnel_desc();
  void clear_has_port_tunnel_desc();
  void set_has_link_prio();
  void clear_has_link_prio();
  void set_has_wan_status();
  void clear_has_wan_status();
  void set_has_crypto_type();
  void clear_has_crypto_type();
  void set_has_tunnel_active_status();
  void clear_has_tunnel_active_status();
  void set_has_tunnel_uptime();
  void clear_has_tunnel_uptime();
  void set_has_peer_tunnel_ip();
  void clear_has_peer_tunnel_ip();
  void set_has_tunnel_ip();
  void clear_has_tunnel_ip();
  void set_has_tunnel_name();
  void clear_has_tunnel_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  ::google::protobuf::internal::ArenaStringPtr port_tunnel_desc_;
  ::google::protobuf::internal::ArenaStringPtr tunnel_name_;
  ::ce::nbapi::mac_address* device_mac_;
  ::ce::nbapi::ip_address* peer_tunnel_ip_;
  ::ce::nbapi::ip_address* tunnel_ip_;
  ::google::protobuf::uint64 link_id_;
  ::google::protobuf::uint64 vlan_id_;
  ::google::protobuf::uint32 link_status_;
  ::google::protobuf::uint32 link_prio_;
  ::google::protobuf::uint32 wan_status_;
  ::google::protobuf::uint32 crypto_type_;
  ::google::protobuf::uint64 tunnel_uptime_;
  ::google::protobuf::uint32 tunnel_active_status_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class stats_uplink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.stats_uplink) */ {
 public:
  stats_uplink();
  virtual ~stats_uplink();

  stats_uplink(const stats_uplink& from);

  inline stats_uplink& operator=(const stats_uplink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  stats_uplink(stats_uplink&& from) noexcept
    : stats_uplink() {
    *this = ::std::move(from);
  }

  inline stats_uplink& operator=(stats_uplink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stats_uplink& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const stats_uplink* internal_default_instance() {
    return reinterpret_cast<const stats_uplink*>(
               &_stats_uplink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(stats_uplink* other);
  friend void swap(stats_uplink& a, stats_uplink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline stats_uplink* New() const final {
    return CreateMaybeMessage<stats_uplink>(NULL);
  }

  stats_uplink* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<stats_uplink>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const stats_uplink& from);
  void MergeFrom(const stats_uplink& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(stats_uplink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string tunnel_name = 8;
  bool has_tunnel_name() const;
  void clear_tunnel_name();
  static const int kTunnelNameFieldNumber = 8;
  const ::std::string& tunnel_name() const;
  void set_tunnel_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tunnel_name(::std::string&& value);
  #endif
  void set_tunnel_name(const char* value);
  void set_tunnel_name(const char* value, size_t size);
  ::std::string* mutable_tunnel_name();
  ::std::string* release_tunnel_name();
  void set_allocated_tunnel_name(::std::string* tunnel_name);

  // optional .ce.nbapi.mac_address device_mac = 1;
  bool has_device_mac() const;
  void clear_device_mac();
  static const int kDeviceMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_device_mac() const;
  public:
  const ::ce::nbapi::mac_address& device_mac() const;
  ::ce::nbapi::mac_address* release_device_mac();
  ::ce::nbapi::mac_address* mutable_device_mac();
  void set_allocated_device_mac(::ce::nbapi::mac_address* device_mac);

  // optional uint64 link_id = 2;
  bool has_link_id() const;
  void clear_link_id();
  static const int kLinkIdFieldNumber = 2;
  ::google::protobuf::uint64 link_id() const;
  void set_link_id(::google::protobuf::uint64 value);

  // optional uint64 rx_pkts = 3;
  bool has_rx_pkts() const;
  void clear_rx_pkts();
  static const int kRxPktsFieldNumber = 3;
  ::google::protobuf::uint64 rx_pkts() const;
  void set_rx_pkts(::google::protobuf::uint64 value);

  // optional uint64 tx_pkts = 4;
  bool has_tx_pkts() const;
  void clear_tx_pkts();
  static const int kTxPktsFieldNumber = 4;
  ::google::protobuf::uint64 tx_pkts() const;
  void set_tx_pkts(::google::protobuf::uint64 value);

  // optional uint64 rx_bytes = 5;
  bool has_rx_bytes() const;
  void clear_rx_bytes();
  static const int kRxBytesFieldNumber = 5;
  ::google::protobuf::uint64 rx_bytes() const;
  void set_rx_bytes(::google::protobuf::uint64 value);

  // optional uint64 tx_bytes = 6;
  bool has_tx_bytes() const;
  void clear_tx_bytes();
  static const int kTxBytesFieldNumber = 6;
  ::google::protobuf::uint64 tx_bytes() const;
  void set_tx_bytes(::google::protobuf::uint64 value);

  // optional uint32 vlan_id = 7;
  bool has_vlan_id() const;
  void clear_vlan_id();
  static const int kVlanIdFieldNumber = 7;
  ::google::protobuf::uint32 vlan_id() const;
  void set_vlan_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.stats_uplink)
 private:
  void set_has_device_mac();
  void clear_has_device_mac();
  void set_has_link_id();
  void clear_has_link_id();
  void set_has_rx_pkts();
  void clear_has_rx_pkts();
  void set_has_tx_pkts();
  void clear_has_tx_pkts();
  void set_has_rx_bytes();
  void clear_has_rx_bytes();
  void set_has_tx_bytes();
  void clear_has_tx_bytes();
  void set_has_vlan_id();
  void clear_has_vlan_id();
  void set_has_tunnel_name();
  void clear_has_tunnel_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tunnel_name_;
  ::ce::nbapi::mac_address* device_mac_;
  ::google::protobuf::uint64 link_id_;
  ::google::protobuf::uint64 rx_pkts_;
  ::google::protobuf::uint64 tx_pkts_;
  ::google::protobuf::uint64 rx_bytes_;
  ::google::protobuf::uint64 tx_bytes_;
  ::google::protobuf::uint32 vlan_id_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class wan_comp_uplink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.wan_comp_uplink) */ {
 public:
  wan_comp_uplink();
  virtual ~wan_comp_uplink();

  wan_comp_uplink(const wan_comp_uplink& from);

  inline wan_comp_uplink& operator=(const wan_comp_uplink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  wan_comp_uplink(wan_comp_uplink&& from) noexcept
    : wan_comp_uplink() {
    *this = ::std::move(from);
  }

  inline wan_comp_uplink& operator=(wan_comp_uplink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const wan_comp_uplink& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const wan_comp_uplink* internal_default_instance() {
    return reinterpret_cast<const wan_comp_uplink*>(
               &_wan_comp_uplink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(wan_comp_uplink* other);
  friend void swap(wan_comp_uplink& a, wan_comp_uplink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline wan_comp_uplink* New() const final {
    return CreateMaybeMessage<wan_comp_uplink>(NULL);
  }

  wan_comp_uplink* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<wan_comp_uplink>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const wan_comp_uplink& from);
  void MergeFrom(const wan_comp_uplink& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(wan_comp_uplink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address boc_mac = 1;
  bool has_boc_mac() const;
  void clear_boc_mac();
  static const int kBocMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_boc_mac() const;
  public:
  const ::ce::nbapi::mac_address& boc_mac() const;
  ::ce::nbapi::mac_address* release_boc_mac();
  ::ce::nbapi::mac_address* mutable_boc_mac();
  void set_allocated_boc_mac(::ce::nbapi::mac_address* boc_mac);

  // optional uint64 link_id = 2;
  bool has_link_id() const;
  void clear_link_id();
  static const int kLinkIdFieldNumber = 2;
  ::google::protobuf::uint64 link_id() const;
  void set_link_id(::google::protobuf::uint64 value);

  // optional uint64 tot_comp_bytes = 3;
  bool has_tot_comp_bytes() const;
  void clear_tot_comp_bytes();
  static const int kTotCompBytesFieldNumber = 3;
  ::google::protobuf::uint64 tot_comp_bytes() const;
  void set_tot_comp_bytes(::google::protobuf::uint64 value);

  // optional uint64 tot_uncomp_bytes = 4;
  bool has_tot_uncomp_bytes() const;
  void clear_tot_uncomp_bytes();
  static const int kTotUncompBytesFieldNumber = 4;
  ::google::protobuf::uint64 tot_uncomp_bytes() const;
  void set_tot_uncomp_bytes(::google::protobuf::uint64 value);

  // optional uint64 tot_comp_savings = 5;
  bool has_tot_comp_savings() const;
  void clear_tot_comp_savings();
  static const int kTotCompSavingsFieldNumber = 5;
  ::google::protobuf::uint64 tot_comp_savings() const;
  void set_tot_comp_savings(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.wan_comp_uplink)
 private:
  void set_has_boc_mac();
  void clear_has_boc_mac();
  void set_has_link_id();
  void clear_has_link_id();
  void set_has_tot_comp_bytes();
  void clear_has_tot_comp_bytes();
  void set_has_tot_uncomp_bytes();
  void clear_has_tot_uncomp_bytes();
  void set_has_tot_comp_savings();
  void clear_has_tot_comp_savings();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* boc_mac_;
  ::google::protobuf::uint64 link_id_;
  ::google::protobuf::uint64 tot_comp_bytes_;
  ::google::protobuf::uint64 tot_uncomp_bytes_;
  ::google::protobuf::uint64 tot_comp_savings_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class stats_ip_probe_uplink : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.stats_ip_probe_uplink) */ {
 public:
  stats_ip_probe_uplink();
  virtual ~stats_ip_probe_uplink();

  stats_ip_probe_uplink(const stats_ip_probe_uplink& from);

  inline stats_ip_probe_uplink& operator=(const stats_ip_probe_uplink& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  stats_ip_probe_uplink(stats_ip_probe_uplink&& from) noexcept
    : stats_ip_probe_uplink() {
    *this = ::std::move(from);
  }

  inline stats_ip_probe_uplink& operator=(stats_ip_probe_uplink&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stats_ip_probe_uplink& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const stats_ip_probe_uplink* internal_default_instance() {
    return reinterpret_cast<const stats_ip_probe_uplink*>(
               &_stats_ip_probe_uplink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(stats_ip_probe_uplink* other);
  friend void swap(stats_ip_probe_uplink& a, stats_ip_probe_uplink& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline stats_ip_probe_uplink* New() const final {
    return CreateMaybeMessage<stats_ip_probe_uplink>(NULL);
  }

  stats_ip_probe_uplink* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<stats_ip_probe_uplink>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const stats_ip_probe_uplink& from);
  void MergeFrom(const stats_ip_probe_uplink& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(stats_ip_probe_uplink* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string tunnel_name = 14;
  bool has_tunnel_name() const;
  void clear_tunnel_name();
  static const int kTunnelNameFieldNumber = 14;
  const ::std::string& tunnel_name() const;
  void set_tunnel_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tunnel_name(::std::string&& value);
  #endif
  void set_tunnel_name(const char* value);
  void set_tunnel_name(const char* value, size_t size);
  ::std::string* mutable_tunnel_name();
  ::std::string* release_tunnel_name();
  void set_allocated_tunnel_name(::std::string* tunnel_name);

  // optional .ce.nbapi.mac_address device_mac = 1;
  bool has_device_mac() const;
  void clear_device_mac();
  static const int kDeviceMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_device_mac() const;
  public:
  const ::ce::nbapi::mac_address& device_mac() const;
  ::ce::nbapi::mac_address* release_device_mac();
  ::ce::nbapi::mac_address* mutable_device_mac();
  void set_allocated_device_mac(::ce::nbapi::mac_address* device_mac);

  // optional .ce.nbapi.ip_address probe_ip_addr = 3;
  bool has_probe_ip_addr() const;
  void clear_probe_ip_addr();
  static const int kProbeIpAddrFieldNumber = 3;
  private:
  const ::ce::nbapi::ip_address& _internal_probe_ip_addr() const;
  public:
  const ::ce::nbapi::ip_address& probe_ip_addr() const;
  ::ce::nbapi::ip_address* release_probe_ip_addr();
  ::ce::nbapi::ip_address* mutable_probe_ip_addr();
  void set_allocated_probe_ip_addr(::ce::nbapi::ip_address* probe_ip_addr);

  // optional uint64 link_id = 2;
  bool has_link_id() const;
  void clear_link_id();
  static const int kLinkIdFieldNumber = 2;
  ::google::protobuf::uint64 link_id() const;
  void set_link_id(::google::protobuf::uint64 value);

  // optional uint64 avg_rtt = 5;
  bool has_avg_rtt() const;
  void clear_avg_rtt();
  static const int kAvgRttFieldNumber = 5;
  ::google::protobuf::uint64 avg_rtt() const;
  void set_avg_rtt(::google::protobuf::uint64 value);

  // optional uint64 max_rtt = 6;
  bool has_max_rtt() const;
  void clear_max_rtt();
  static const int kMaxRttFieldNumber = 6;
  ::google::protobuf::uint64 max_rtt() const;
  void set_max_rtt(::google::protobuf::uint64 value);

  // optional uint64 min_rtt = 7;
  bool has_min_rtt() const;
  void clear_min_rtt();
  static const int kMinRttFieldNumber = 7;
  ::google::protobuf::uint64 min_rtt() const;
  void set_min_rtt(::google::protobuf::uint64 value);

  // optional uint64 avg_jitter = 8;
  bool has_avg_jitter() const;
  void clear_avg_jitter();
  static const int kAvgJitterFieldNumber = 8;
  ::google::protobuf::uint64 avg_jitter() const;
  void set_avg_jitter(::google::protobuf::uint64 value);

  // optional uint32 vlan_id = 4;
  bool has_vlan_id() const;
  void clear_vlan_id();
  static const int kVlanIdFieldNumber = 4;
  ::google::protobuf::uint32 vlan_id() const;
  void set_vlan_id(::google::protobuf::uint32 value);

  // optional uint32 probe_status = 12;
  bool has_probe_status() const;
  void clear_probe_status();
  static const int kProbeStatusFieldNumber = 12;
  ::google::protobuf::uint32 probe_status() const;
  void set_probe_status(::google::protobuf::uint32 value);

  // optional uint64 max_jitter = 9;
  bool has_max_jitter() const;
  void clear_max_jitter();
  static const int kMaxJitterFieldNumber = 9;
  ::google::protobuf::uint64 max_jitter() const;
  void set_max_jitter(::google::protobuf::uint64 value);

  // optional uint64 min_jitter = 10;
  bool has_min_jitter() const;
  void clear_min_jitter();
  static const int kMinJitterFieldNumber = 10;
  ::google::protobuf::uint64 min_jitter() const;
  void set_min_jitter(::google::protobuf::uint64 value);

  // optional uint64 mos_quality = 11;
  bool has_mos_quality() const;
  void clear_mos_quality();
  static const int kMosQualityFieldNumber = 11;
  ::google::protobuf::uint64 mos_quality() const;
  void set_mos_quality(::google::protobuf::uint64 value);

  // optional uint64 sd_avg_latency = 15;
  bool has_sd_avg_latency() const;
  void clear_sd_avg_latency();
  static const int kSdAvgLatencyFieldNumber = 15;
  ::google::protobuf::uint64 sd_avg_latency() const;
  void set_sd_avg_latency(::google::protobuf::uint64 value);

  // optional uint64 ds_avg_latency = 16;
  bool has_ds_avg_latency() const;
  void clear_ds_avg_latency();
  static const int kDsAvgLatencyFieldNumber = 16;
  ::google::protobuf::uint64 ds_avg_latency() const;
  void set_ds_avg_latency(::google::protobuf::uint64 value);

  // optional uint64 sd_avg_jitter = 17;
  bool has_sd_avg_jitter() const;
  void clear_sd_avg_jitter();
  static const int kSdAvgJitterFieldNumber = 17;
  ::google::protobuf::uint64 sd_avg_jitter() const;
  void set_sd_avg_jitter(::google::protobuf::uint64 value);

  // optional uint64 ds_avg_jitter = 18;
  bool has_ds_avg_jitter() const;
  void clear_ds_avg_jitter();
  static const int kDsAvgJitterFieldNumber = 18;
  ::google::protobuf::uint64 ds_avg_jitter() const;
  void set_ds_avg_jitter(::google::protobuf::uint64 value);

  // optional uint32 ip_probe_pkt_loss_pct = 13;
  bool has_ip_probe_pkt_loss_pct() const;
  void clear_ip_probe_pkt_loss_pct();
  static const int kIpProbePktLossPctFieldNumber = 13;
  ::google::protobuf::uint32 ip_probe_pkt_loss_pct() const;
  void set_ip_probe_pkt_loss_pct(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.stats_ip_probe_uplink)
 private:
  void set_has_device_mac();
  void clear_has_device_mac();
  void set_has_link_id();
  void clear_has_link_id();
  void set_has_probe_ip_addr();
  void clear_has_probe_ip_addr();
  void set_has_vlan_id();
  void clear_has_vlan_id();
  void set_has_avg_rtt();
  void clear_has_avg_rtt();
  void set_has_max_rtt();
  void clear_has_max_rtt();
  void set_has_min_rtt();
  void clear_has_min_rtt();
  void set_has_avg_jitter();
  void clear_has_avg_jitter();
  void set_has_max_jitter();
  void clear_has_max_jitter();
  void set_has_min_jitter();
  void clear_has_min_jitter();
  void set_has_mos_quality();
  void clear_has_mos_quality();
  void set_has_probe_status();
  void clear_has_probe_status();
  void set_has_ip_probe_pkt_loss_pct();
  void clear_has_ip_probe_pkt_loss_pct();
  void set_has_tunnel_name();
  void clear_has_tunnel_name();
  void set_has_sd_avg_latency();
  void clear_has_sd_avg_latency();
  void set_has_ds_avg_latency();
  void clear_has_ds_avg_latency();
  void set_has_sd_avg_jitter();
  void clear_has_sd_avg_jitter();
  void set_has_ds_avg_jitter();
  void clear_has_ds_avg_jitter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr tunnel_name_;
  ::ce::nbapi::mac_address* device_mac_;
  ::ce::nbapi::ip_address* probe_ip_addr_;
  ::google::protobuf::uint64 link_id_;
  ::google::protobuf::uint64 avg_rtt_;
  ::google::protobuf::uint64 max_rtt_;
  ::google::protobuf::uint64 min_rtt_;
  ::google::protobuf::uint64 avg_jitter_;
  ::google::protobuf::uint32 vlan_id_;
  ::google::protobuf::uint32 probe_status_;
  ::google::protobuf::uint64 max_jitter_;
  ::google::protobuf::uint64 min_jitter_;
  ::google::protobuf::uint64 mos_quality_;
  ::google::protobuf::uint64 sd_avg_latency_;
  ::google::protobuf::uint64 ds_avg_latency_;
  ::google::protobuf::uint64 sd_avg_jitter_;
  ::google::protobuf::uint64 ds_avg_jitter_;
  ::google::protobuf::uint32 ip_probe_pkt_loss_pct_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class stats_tunnel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.stats_tunnel) */ {
 public:
  stats_tunnel();
  virtual ~stats_tunnel();

  stats_tunnel(const stats_tunnel& from);

  inline stats_tunnel& operator=(const stats_tunnel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  stats_tunnel(stats_tunnel&& from) noexcept
    : stats_tunnel() {
    *this = ::std::move(from);
  }

  inline stats_tunnel& operator=(stats_tunnel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stats_tunnel& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const stats_tunnel* internal_default_instance() {
    return reinterpret_cast<const stats_tunnel*>(
               &_stats_tunnel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(stats_tunnel* other);
  friend void swap(stats_tunnel& a, stats_tunnel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline stats_tunnel* New() const final {
    return CreateMaybeMessage<stats_tunnel>(NULL);
  }

  stats_tunnel* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<stats_tunnel>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const stats_tunnel& from);
  void MergeFrom(const stats_tunnel& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(stats_tunnel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address iap_mac = 6;
  bool has_iap_mac() const;
  void clear_iap_mac();
  static const int kIapMacFieldNumber = 6;
  private:
  const ::ce::nbapi::mac_address& _internal_iap_mac() const;
  public:
  const ::ce::nbapi::mac_address& iap_mac() const;
  ::ce::nbapi::mac_address* release_iap_mac();
  ::ce::nbapi::mac_address* mutable_iap_mac();
  void set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac);

  // optional uint64 tx_data_pkts = 2;
  bool has_tx_data_pkts() const;
  void clear_tx_data_pkts();
  static const int kTxDataPktsFieldNumber = 2;
  ::google::protobuf::uint64 tx_data_pkts() const;
  void set_tx_data_pkts(::google::protobuf::uint64 value);

  // optional uint64 rx_data_pkts = 3;
  bool has_rx_data_pkts() const;
  void clear_rx_data_pkts();
  static const int kRxDataPktsFieldNumber = 3;
  ::google::protobuf::uint64 rx_data_pkts() const;
  void set_rx_data_pkts(::google::protobuf::uint64 value);

  // optional uint64 tx_data_bytes = 4;
  bool has_tx_data_bytes() const;
  void clear_tx_data_bytes();
  static const int kTxDataBytesFieldNumber = 4;
  ::google::protobuf::uint64 tx_data_bytes() const;
  void set_tx_data_bytes(::google::protobuf::uint64 value);

  // optional uint64 rx_data_bytes = 5;
  bool has_rx_data_bytes() const;
  void clear_rx_data_bytes();
  static const int kRxDataBytesFieldNumber = 5;
  ::google::protobuf::uint64 rx_data_bytes() const;
  void set_rx_data_bytes(::google::protobuf::uint64 value);

  // optional uint32 tunnel_index = 1;
  bool has_tunnel_index() const;
  void clear_tunnel_index();
  static const int kTunnelIndexFieldNumber = 1;
  ::google::protobuf::uint32 tunnel_index() const;
  void set_tunnel_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.stats_tunnel)
 private:
  void set_has_tunnel_index();
  void clear_has_tunnel_index();
  void set_has_tx_data_pkts();
  void clear_has_tx_data_pkts();
  void set_has_rx_data_pkts();
  void clear_has_rx_data_pkts();
  void set_has_tx_data_bytes();
  void clear_has_tx_data_bytes();
  void set_has_rx_data_bytes();
  void clear_has_rx_data_bytes();
  void set_has_iap_mac();
  void clear_has_iap_mac();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* iap_mac_;
  ::google::protobuf::uint64 tx_data_pkts_;
  ::google::protobuf::uint64 rx_data_pkts_;
  ::google::protobuf::uint64 tx_data_bytes_;
  ::google::protobuf::uint64 rx_data_bytes_;
  ::google::protobuf::uint32 tunnel_index_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class bytes_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.bytes_info) */ {
 public:
  bytes_info();
  virtual ~bytes_info();

  bytes_info(const bytes_info& from);

  inline bytes_info& operator=(const bytes_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  bytes_info(bytes_info&& from) noexcept
    : bytes_info() {
    *this = ::std::move(from);
  }

  inline bytes_info& operator=(bytes_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const bytes_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const bytes_info* internal_default_instance() {
    return reinterpret_cast<const bytes_info*>(
               &_bytes_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(bytes_info* other);
  friend void swap(bytes_info& a, bytes_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline bytes_info* New() const final {
    return CreateMaybeMessage<bytes_info>(NULL);
  }

  bytes_info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<bytes_info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const bytes_info& from);
  void MergeFrom(const bytes_info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bytes_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 tx_bytes = 1;
  bool has_tx_bytes() const;
  void clear_tx_bytes();
  static const int kTxBytesFieldNumber = 1;
  ::google::protobuf::uint64 tx_bytes() const;
  void set_tx_bytes(::google::protobuf::uint64 value);

  // optional uint64 rx_bytes = 2;
  bool has_rx_bytes() const;
  void clear_rx_bytes();
  static const int kRxBytesFieldNumber = 2;
  ::google::protobuf::uint64 rx_bytes() const;
  void set_rx_bytes(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.bytes_info)
 private:
  void set_has_tx_bytes();
  void clear_has_tx_bytes();
  void set_has_rx_bytes();
  void clear_has_rx_bytes();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 tx_bytes_;
  ::google::protobuf::uint64 rx_bytes_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class iap_bytes_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.iap_bytes_info) */ {
 public:
  iap_bytes_info();
  virtual ~iap_bytes_info();

  iap_bytes_info(const iap_bytes_info& from);

  inline iap_bytes_info& operator=(const iap_bytes_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  iap_bytes_info(iap_bytes_info&& from) noexcept
    : iap_bytes_info() {
    *this = ::std::move(from);
  }

  inline iap_bytes_info& operator=(iap_bytes_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const iap_bytes_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const iap_bytes_info* internal_default_instance() {
    return reinterpret_cast<const iap_bytes_info*>(
               &_iap_bytes_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(iap_bytes_info* other);
  friend void swap(iap_bytes_info& a, iap_bytes_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline iap_bytes_info* New() const final {
    return CreateMaybeMessage<iap_bytes_info>(NULL);
  }

  iap_bytes_info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<iap_bytes_info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const iap_bytes_info& from);
  void MergeFrom(const iap_bytes_info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(iap_bytes_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.bytes_info bytes_info = 2;
  bool has_bytes_info() const;
  void clear_bytes_info();
  static const int kBytesInfoFieldNumber = 2;
  private:
  const ::ce::nbapi::bytes_info& _internal_bytes_info() const;
  public:
  const ::ce::nbapi::bytes_info& bytes_info() const;
  ::ce::nbapi::bytes_info* release_bytes_info();
  ::ce::nbapi::bytes_info* mutable_bytes_info();
  void set_allocated_bytes_info(::ce::nbapi::bytes_info* bytes_info);

  // optional .ce.nbapi.iap_enforcement_status session_flags = 1;
  bool has_session_flags() const;
  void clear_session_flags();
  static const int kSessionFlagsFieldNumber = 1;
  ::ce::nbapi::iap_enforcement_status session_flags() const;
  void set_session_flags(::ce::nbapi::iap_enforcement_status value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.iap_bytes_info)
 private:
  void set_has_session_flags();
  void clear_has_session_flags();
  void set_has_bytes_info();
  void clear_has_bytes_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::bytes_info* bytes_info_;
  int session_flags_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class stats_role_iap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.stats_role_iap) */ {
 public:
  stats_role_iap();
  virtual ~stats_role_iap();

  stats_role_iap(const stats_role_iap& from);

  inline stats_role_iap& operator=(const stats_role_iap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  stats_role_iap(stats_role_iap&& from) noexcept
    : stats_role_iap() {
    *this = ::std::move(from);
  }

  inline stats_role_iap& operator=(stats_role_iap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stats_role_iap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const stats_role_iap* internal_default_instance() {
    return reinterpret_cast<const stats_role_iap*>(
               &_stats_role_iap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(stats_role_iap* other);
  friend void swap(stats_role_iap& a, stats_role_iap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline stats_role_iap* New() const final {
    return CreateMaybeMessage<stats_role_iap>(NULL);
  }

  stats_role_iap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<stats_role_iap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const stats_role_iap& from);
  void MergeFrom(const stats_role_iap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(stats_role_iap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes user_role = 2;
  bool has_user_role() const;
  void clear_user_role();
  static const int kUserRoleFieldNumber = 2;
  const ::std::string& user_role() const;
  void set_user_role(const ::std::string& value);
  #if LANG_CXX11
  void set_user_role(::std::string&& value);
  #endif
  void set_user_role(const char* value);
  void set_user_role(const void* value, size_t size);
  ::std::string* mutable_user_role();
  ::std::string* release_user_role();
  void set_allocated_user_role(::std::string* user_role);

  // optional .ce.nbapi.mac_address iap_mac = 1;
  bool has_iap_mac() const;
  void clear_iap_mac();
  static const int kIapMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_iap_mac() const;
  public:
  const ::ce::nbapi::mac_address& iap_mac() const;
  ::ce::nbapi::mac_address* release_iap_mac();
  ::ce::nbapi::mac_address* mutable_iap_mac();
  void set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac);

  // optional .ce.nbapi.bytes_info bytes_info = 3;
  bool has_bytes_info() const;
  void clear_bytes_info();
  static const int kBytesInfoFieldNumber = 3;
  private:
  const ::ce::nbapi::bytes_info& _internal_bytes_info() const;
  public:
  const ::ce::nbapi::bytes_info& bytes_info() const;
  ::ce::nbapi::bytes_info* release_bytes_info();
  ::ce::nbapi::bytes_info* mutable_bytes_info();
  void set_allocated_bytes_info(::ce::nbapi::bytes_info* bytes_info);

  // @@protoc_insertion_point(class_scope:ce.nbapi.stats_role_iap)
 private:
  void set_has_iap_mac();
  void clear_has_iap_mac();
  void set_has_user_role();
  void clear_has_user_role();
  void set_has_bytes_info();
  void clear_has_bytes_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr user_role_;
  ::ce::nbapi::mac_address* iap_mac_;
  ::ce::nbapi::bytes_info* bytes_info_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class stats_vlan_iap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.stats_vlan_iap) */ {
 public:
  stats_vlan_iap();
  virtual ~stats_vlan_iap();

  stats_vlan_iap(const stats_vlan_iap& from);

  inline stats_vlan_iap& operator=(const stats_vlan_iap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  stats_vlan_iap(stats_vlan_iap&& from) noexcept
    : stats_vlan_iap() {
    *this = ::std::move(from);
  }

  inline stats_vlan_iap& operator=(stats_vlan_iap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stats_vlan_iap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const stats_vlan_iap* internal_default_instance() {
    return reinterpret_cast<const stats_vlan_iap*>(
               &_stats_vlan_iap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(stats_vlan_iap* other);
  friend void swap(stats_vlan_iap& a, stats_vlan_iap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline stats_vlan_iap* New() const final {
    return CreateMaybeMessage<stats_vlan_iap>(NULL);
  }

  stats_vlan_iap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<stats_vlan_iap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const stats_vlan_iap& from);
  void MergeFrom(const stats_vlan_iap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(stats_vlan_iap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address iap_mac = 1;
  bool has_iap_mac() const;
  void clear_iap_mac();
  static const int kIapMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_iap_mac() const;
  public:
  const ::ce::nbapi::mac_address& iap_mac() const;
  ::ce::nbapi::mac_address* release_iap_mac();
  ::ce::nbapi::mac_address* mutable_iap_mac();
  void set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac);

  // optional .ce.nbapi.bytes_info bytes_info = 3;
  bool has_bytes_info() const;
  void clear_bytes_info();
  static const int kBytesInfoFieldNumber = 3;
  private:
  const ::ce::nbapi::bytes_info& _internal_bytes_info() const;
  public:
  const ::ce::nbapi::bytes_info& bytes_info() const;
  ::ce::nbapi::bytes_info* release_bytes_info();
  ::ce::nbapi::bytes_info* mutable_bytes_info();
  void set_allocated_bytes_info(::ce::nbapi::bytes_info* bytes_info);

  // optional uint32 vlan = 2;
  bool has_vlan() const;
  void clear_vlan();
  static const int kVlanFieldNumber = 2;
  ::google::protobuf::uint32 vlan() const;
  void set_vlan(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.stats_vlan_iap)
 private:
  void set_has_iap_mac();
  void clear_has_iap_mac();
  void set_has_vlan();
  void clear_has_vlan();
  void set_has_bytes_info();
  void clear_has_bytes_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* iap_mac_;
  ::ce::nbapi::bytes_info* bytes_info_;
  ::google::protobuf::uint32 vlan_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class stats_ssid_iap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.stats_ssid_iap) */ {
 public:
  stats_ssid_iap();
  virtual ~stats_ssid_iap();

  stats_ssid_iap(const stats_ssid_iap& from);

  inline stats_ssid_iap& operator=(const stats_ssid_iap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  stats_ssid_iap(stats_ssid_iap&& from) noexcept
    : stats_ssid_iap() {
    *this = ::std::move(from);
  }

  inline stats_ssid_iap& operator=(stats_ssid_iap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stats_ssid_iap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const stats_ssid_iap* internal_default_instance() {
    return reinterpret_cast<const stats_ssid_iap*>(
               &_stats_ssid_iap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(stats_ssid_iap* other);
  friend void swap(stats_ssid_iap& a, stats_ssid_iap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline stats_ssid_iap* New() const final {
    return CreateMaybeMessage<stats_ssid_iap>(NULL);
  }

  stats_ssid_iap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<stats_ssid_iap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const stats_ssid_iap& from);
  void MergeFrom(const stats_ssid_iap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(stats_ssid_iap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes essid = 2;
  bool has_essid() const;
  void clear_essid();
  static const int kEssidFieldNumber = 2;
  const ::std::string& essid() const;
  void set_essid(const ::std::string& value);
  #if LANG_CXX11
  void set_essid(::std::string&& value);
  #endif
  void set_essid(const char* value);
  void set_essid(const void* value, size_t size);
  ::std::string* mutable_essid();
  ::std::string* release_essid();
  void set_allocated_essid(::std::string* essid);

  // optional .ce.nbapi.mac_address iap_mac = 1;
  bool has_iap_mac() const;
  void clear_iap_mac();
  static const int kIapMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_iap_mac() const;
  public:
  const ::ce::nbapi::mac_address& iap_mac() const;
  ::ce::nbapi::mac_address* release_iap_mac();
  ::ce::nbapi::mac_address* mutable_iap_mac();
  void set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac);

  // optional .ce.nbapi.bytes_info bytes_info = 3;
  bool has_bytes_info() const;
  void clear_bytes_info();
  static const int kBytesInfoFieldNumber = 3;
  private:
  const ::ce::nbapi::bytes_info& _internal_bytes_info() const;
  public:
  const ::ce::nbapi::bytes_info& bytes_info() const;
  ::ce::nbapi::bytes_info* release_bytes_info();
  ::ce::nbapi::bytes_info* mutable_bytes_info();
  void set_allocated_bytes_info(::ce::nbapi::bytes_info* bytes_info);

  // @@protoc_insertion_point(class_scope:ce.nbapi.stats_ssid_iap)
 private:
  void set_has_iap_mac();
  void clear_has_iap_mac();
  void set_has_essid();
  void clear_has_essid();
  void set_has_bytes_info();
  void clear_has_bytes_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr essid_;
  ::ce::nbapi::mac_address* iap_mac_;
  ::ce::nbapi::bytes_info* bytes_info_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class stats_port : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.stats_port) */ {
 public:
  stats_port();
  virtual ~stats_port();

  stats_port(const stats_port& from);

  inline stats_port& operator=(const stats_port& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  stats_port(stats_port&& from) noexcept
    : stats_port() {
    *this = ::std::move(from);
  }

  inline stats_port& operator=(stats_port&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stats_port& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const stats_port* internal_default_instance() {
    return reinterpret_cast<const stats_port*>(
               &_stats_port_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(stats_port* other);
  friend void swap(stats_port& a, stats_port& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline stats_port* New() const final {
    return CreateMaybeMessage<stats_port>(NULL);
  }

  stats_port* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<stats_port>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const stats_port& from);
  void MergeFrom(const stats_port& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(stats_port* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address port_mac = 1;
  bool has_port_mac() const;
  void clear_port_mac();
  static const int kPortMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_port_mac() const;
  public:
  const ::ce::nbapi::mac_address& port_mac() const;
  ::ce::nbapi::mac_address* release_port_mac();
  ::ce::nbapi::mac_address* mutable_port_mac();
  void set_allocated_port_mac(::ce::nbapi::mac_address* port_mac);

  // optional .ce.nbapi.bytes_info bytes_info = 2;
  bool has_bytes_info() const;
  void clear_bytes_info();
  static const int kBytesInfoFieldNumber = 2;
  private:
  const ::ce::nbapi::bytes_info& _internal_bytes_info() const;
  public:
  const ::ce::nbapi::bytes_info& bytes_info() const;
  ::ce::nbapi::bytes_info* release_bytes_info();
  ::ce::nbapi::bytes_info* mutable_bytes_info();
  void set_allocated_bytes_info(::ce::nbapi::bytes_info* bytes_info);

  // @@protoc_insertion_point(class_scope:ce.nbapi.stats_port)
 private:
  void set_has_port_mac();
  void clear_has_port_mac();
  void set_has_bytes_info();
  void clear_has_bytes_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* port_mac_;
  ::ce::nbapi::bytes_info* bytes_info_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class summary_webcat_iap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.summary_webcat_iap) */ {
 public:
  summary_webcat_iap();
  virtual ~summary_webcat_iap();

  summary_webcat_iap(const summary_webcat_iap& from);

  inline summary_webcat_iap& operator=(const summary_webcat_iap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  summary_webcat_iap(summary_webcat_iap&& from) noexcept
    : summary_webcat_iap() {
    *this = ::std::move(from);
  }

  inline summary_webcat_iap& operator=(summary_webcat_iap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const summary_webcat_iap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const summary_webcat_iap* internal_default_instance() {
    return reinterpret_cast<const summary_webcat_iap*>(
               &_summary_webcat_iap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(summary_webcat_iap* other);
  friend void swap(summary_webcat_iap& a, summary_webcat_iap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline summary_webcat_iap* New() const final {
    return CreateMaybeMessage<summary_webcat_iap>(NULL);
  }

  summary_webcat_iap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<summary_webcat_iap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const summary_webcat_iap& from);
  void MergeFrom(const summary_webcat_iap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(summary_webcat_iap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address iap_mac = 1;
  bool has_iap_mac() const;
  void clear_iap_mac();
  static const int kIapMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_iap_mac() const;
  public:
  const ::ce::nbapi::mac_address& iap_mac() const;
  ::ce::nbapi::mac_address* release_iap_mac();
  ::ce::nbapi::mac_address* mutable_iap_mac();
  void set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac);

  // optional .ce.nbapi.iap_bytes_info bytes_info = 3;
  bool has_bytes_info() const;
  void clear_bytes_info();
  static const int kBytesInfoFieldNumber = 3;
  private:
  const ::ce::nbapi::iap_bytes_info& _internal_bytes_info() const;
  public:
  const ::ce::nbapi::iap_bytes_info& bytes_info() const;
  ::ce::nbapi::iap_bytes_info* release_bytes_info();
  ::ce::nbapi::iap_bytes_info* mutable_bytes_info();
  void set_allocated_bytes_info(::ce::nbapi::iap_bytes_info* bytes_info);

  // optional uint32 webcat_id = 2;
  bool has_webcat_id() const;
  void clear_webcat_id();
  static const int kWebcatIdFieldNumber = 2;
  ::google::protobuf::uint32 webcat_id() const;
  void set_webcat_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.summary_webcat_iap)
 private:
  void set_has_iap_mac();
  void clear_has_iap_mac();
  void set_has_webcat_id();
  void clear_has_webcat_id();
  void set_has_bytes_info();
  void clear_has_bytes_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* iap_mac_;
  ::ce::nbapi::iap_bytes_info* bytes_info_;
  ::google::protobuf::uint32 webcat_id_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class summary_appid_iap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.summary_appid_iap) */ {
 public:
  summary_appid_iap();
  virtual ~summary_appid_iap();

  summary_appid_iap(const summary_appid_iap& from);

  inline summary_appid_iap& operator=(const summary_appid_iap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  summary_appid_iap(summary_appid_iap&& from) noexcept
    : summary_appid_iap() {
    *this = ::std::move(from);
  }

  inline summary_appid_iap& operator=(summary_appid_iap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const summary_appid_iap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const summary_appid_iap* internal_default_instance() {
    return reinterpret_cast<const summary_appid_iap*>(
               &_summary_appid_iap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(summary_appid_iap* other);
  friend void swap(summary_appid_iap& a, summary_appid_iap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline summary_appid_iap* New() const final {
    return CreateMaybeMessage<summary_appid_iap>(NULL);
  }

  summary_appid_iap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<summary_appid_iap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const summary_appid_iap& from);
  void MergeFrom(const summary_appid_iap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(summary_appid_iap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address iap_mac = 1;
  bool has_iap_mac() const;
  void clear_iap_mac();
  static const int kIapMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_iap_mac() const;
  public:
  const ::ce::nbapi::mac_address& iap_mac() const;
  ::ce::nbapi::mac_address* release_iap_mac();
  ::ce::nbapi::mac_address* mutable_iap_mac();
  void set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac);

  // optional .ce.nbapi.iap_bytes_info bytes_info = 3;
  bool has_bytes_info() const;
  void clear_bytes_info();
  static const int kBytesInfoFieldNumber = 3;
  private:
  const ::ce::nbapi::iap_bytes_info& _internal_bytes_info() const;
  public:
  const ::ce::nbapi::iap_bytes_info& bytes_info() const;
  ::ce::nbapi::iap_bytes_info* release_bytes_info();
  ::ce::nbapi::iap_bytes_info* mutable_bytes_info();
  void set_allocated_bytes_info(::ce::nbapi::iap_bytes_info* bytes_info);

  // optional uint32 app_id = 2;
  bool has_app_id() const;
  void clear_app_id();
  static const int kAppIdFieldNumber = 2;
  ::google::protobuf::uint32 app_id() const;
  void set_app_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.summary_appid_iap)
 private:
  void set_has_iap_mac();
  void clear_has_iap_mac();
  void set_has_app_id();
  void clear_has_app_id();
  void set_has_bytes_info();
  void clear_has_bytes_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* iap_mac_;
  ::ce::nbapi::iap_bytes_info* bytes_info_;
  ::google::protobuf::uint32 app_id_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class summary_webrep_iap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.summary_webrep_iap) */ {
 public:
  summary_webrep_iap();
  virtual ~summary_webrep_iap();

  summary_webrep_iap(const summary_webrep_iap& from);

  inline summary_webrep_iap& operator=(const summary_webrep_iap& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  summary_webrep_iap(summary_webrep_iap&& from) noexcept
    : summary_webrep_iap() {
    *this = ::std::move(from);
  }

  inline summary_webrep_iap& operator=(summary_webrep_iap&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const summary_webrep_iap& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const summary_webrep_iap* internal_default_instance() {
    return reinterpret_cast<const summary_webrep_iap*>(
               &_summary_webrep_iap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(summary_webrep_iap* other);
  friend void swap(summary_webrep_iap& a, summary_webrep_iap& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline summary_webrep_iap* New() const final {
    return CreateMaybeMessage<summary_webrep_iap>(NULL);
  }

  summary_webrep_iap* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<summary_webrep_iap>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const summary_webrep_iap& from);
  void MergeFrom(const summary_webrep_iap& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(summary_webrep_iap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address iap_mac = 1;
  bool has_iap_mac() const;
  void clear_iap_mac();
  static const int kIapMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_iap_mac() const;
  public:
  const ::ce::nbapi::mac_address& iap_mac() const;
  ::ce::nbapi::mac_address* release_iap_mac();
  ::ce::nbapi::mac_address* mutable_iap_mac();
  void set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac);

  // optional .ce.nbapi.iap_bytes_info bytes_info = 3;
  bool has_bytes_info() const;
  void clear_bytes_info();
  static const int kBytesInfoFieldNumber = 3;
  private:
  const ::ce::nbapi::iap_bytes_info& _internal_bytes_info() const;
  public:
  const ::ce::nbapi::iap_bytes_info& bytes_info() const;
  ::ce::nbapi::iap_bytes_info* release_bytes_info();
  ::ce::nbapi::iap_bytes_info* mutable_bytes_info();
  void set_allocated_bytes_info(::ce::nbapi::iap_bytes_info* bytes_info);

  // optional uint32 webrep_id = 2;
  bool has_webrep_id() const;
  void clear_webrep_id();
  static const int kWebrepIdFieldNumber = 2;
  ::google::protobuf::uint32 webrep_id() const;
  void set_webrep_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.summary_webrep_iap)
 private:
  void set_has_iap_mac();
  void clear_has_iap_mac();
  void set_has_webrep_id();
  void clear_has_webrep_id();
  void set_has_bytes_info();
  void clear_has_bytes_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* iap_mac_;
  ::ce::nbapi::iap_bytes_info* bytes_info_;
  ::google::protobuf::uint32 webrep_id_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ap_neighbor_list : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.ap_neighbor_list) */ {
 public:
  ap_neighbor_list();
  virtual ~ap_neighbor_list();

  ap_neighbor_list(const ap_neighbor_list& from);

  inline ap_neighbor_list& operator=(const ap_neighbor_list& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ap_neighbor_list(ap_neighbor_list&& from) noexcept
    : ap_neighbor_list() {
    *this = ::std::move(from);
  }

  inline ap_neighbor_list& operator=(ap_neighbor_list&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ap_neighbor_list& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ap_neighbor_list* internal_default_instance() {
    return reinterpret_cast<const ap_neighbor_list*>(
               &_ap_neighbor_list_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(ap_neighbor_list* other);
  friend void swap(ap_neighbor_list& a, ap_neighbor_list& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ap_neighbor_list* New() const final {
    return CreateMaybeMessage<ap_neighbor_list>(NULL);
  }

  ap_neighbor_list* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ap_neighbor_list>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ap_neighbor_list& from);
  void MergeFrom(const ap_neighbor_list& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ap_neighbor_list* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ce.nbapi.ap_neighbor neighbor = 1;
  int neighbor_size() const;
  void clear_neighbor();
  static const int kNeighborFieldNumber = 1;
  ::ce::nbapi::ap_neighbor* mutable_neighbor(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::ap_neighbor >*
      mutable_neighbor();
  const ::ce::nbapi::ap_neighbor& neighbor(int index) const;
  ::ce::nbapi::ap_neighbor* add_neighbor();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::ap_neighbor >&
      neighbor() const;

  // @@protoc_insertion_point(class_scope:ce.nbapi.ap_neighbor_list)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::ap_neighbor > neighbor_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class utilization_stats_radio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.utilization_stats_radio) */ {
 public:
  utilization_stats_radio();
  virtual ~utilization_stats_radio();

  utilization_stats_radio(const utilization_stats_radio& from);

  inline utilization_stats_radio& operator=(const utilization_stats_radio& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  utilization_stats_radio(utilization_stats_radio&& from) noexcept
    : utilization_stats_radio() {
    *this = ::std::move(from);
  }

  inline utilization_stats_radio& operator=(utilization_stats_radio&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const utilization_stats_radio& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const utilization_stats_radio* internal_default_instance() {
    return reinterpret_cast<const utilization_stats_radio*>(
               &_utilization_stats_radio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(utilization_stats_radio* other);
  friend void swap(utilization_stats_radio& a, utilization_stats_radio& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline utilization_stats_radio* New() const final {
    return CreateMaybeMessage<utilization_stats_radio>(NULL);
  }

  utilization_stats_radio* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<utilization_stats_radio>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const utilization_stats_radio& from);
  void MergeFrom(const utilization_stats_radio& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(utilization_stats_radio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ce.nbapi.util_stats ustats = 3;
  int ustats_size() const;
  void clear_ustats();
  static const int kUstatsFieldNumber = 3;
  ::ce::nbapi::util_stats* mutable_ustats(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::util_stats >*
      mutable_ustats();
  const ::ce::nbapi::util_stats& ustats(int index) const;
  ::ce::nbapi::util_stats* add_ustats();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::util_stats >&
      ustats() const;

  // optional .ce.nbapi.mac_address ap_eth_mac = 1;
  bool has_ap_eth_mac() const;
  void clear_ap_eth_mac();
  static const int kApEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_eth_mac() const;
  ::ce::nbapi::mac_address* release_ap_eth_mac();
  ::ce::nbapi::mac_address* mutable_ap_eth_mac();
  void set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac);

  // optional uint32 radio_number = 2;
  bool has_radio_number() const;
  void clear_radio_number();
  static const int kRadioNumberFieldNumber = 2;
  ::google::protobuf::uint32 radio_number() const;
  void set_radio_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.utilization_stats_radio)
 private:
  void set_has_ap_eth_mac();
  void clear_has_ap_eth_mac();
  void set_has_radio_number();
  void clear_has_radio_number();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::util_stats > ustats_;
  ::ce::nbapi::mac_address* ap_eth_mac_;
  ::google::protobuf::uint32 radio_number_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class proximity : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.proximity) */ {
 public:
  proximity();
  virtual ~proximity();

  proximity(const proximity& from);

  inline proximity& operator=(const proximity& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  proximity(proximity&& from) noexcept
    : proximity() {
    *this = ::std::move(from);
  }

  inline proximity& operator=(proximity&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const proximity& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const proximity* internal_default_instance() {
    return reinterpret_cast<const proximity*>(
               &_proximity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(proximity* other);
  friend void swap(proximity& a, proximity& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline proximity* New() const final {
    return CreateMaybeMessage<proximity>(NULL);
  }

  proximity* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<proximity>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const proximity& from);
  void MergeFrom(const proximity& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(proximity* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ap_name = 4;
  bool has_ap_name() const;
  void clear_ap_name();
  static const int kApNameFieldNumber = 4;
  const ::std::string& ap_name() const;
  void set_ap_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ap_name(::std::string&& value);
  #endif
  void set_ap_name(const char* value);
  void set_ap_name(const char* value, size_t size);
  ::std::string* mutable_ap_name();
  ::std::string* release_ap_name();
  void set_allocated_ap_name(::std::string* ap_name);

  // optional bytes hashed_sta_eth_mac = 5;
  bool has_hashed_sta_eth_mac() const;
  void clear_hashed_sta_eth_mac();
  static const int kHashedStaEthMacFieldNumber = 5;
  const ::std::string& hashed_sta_eth_mac() const;
  void set_hashed_sta_eth_mac(const ::std::string& value);
  #if LANG_CXX11
  void set_hashed_sta_eth_mac(::std::string&& value);
  #endif
  void set_hashed_sta_eth_mac(const char* value);
  void set_hashed_sta_eth_mac(const void* value, size_t size);
  ::std::string* mutable_hashed_sta_eth_mac();
  ::std::string* release_hashed_sta_eth_mac();
  void set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac);

  // optional .ce.nbapi.mac_address sta_eth_mac = 1;
  bool has_sta_eth_mac() const;
  void clear_sta_eth_mac();
  static const int kStaEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_sta_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& sta_eth_mac() const;
  ::ce::nbapi::mac_address* release_sta_eth_mac();
  ::ce::nbapi::mac_address* mutable_sta_eth_mac();
  void set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac);

  // optional .ce.nbapi.mac_address radio_mac = 2;
  bool has_radio_mac() const;
  void clear_radio_mac();
  static const int kRadioMacFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_radio_mac() const;
  public:
  const ::ce::nbapi::mac_address& radio_mac() const;
  ::ce::nbapi::mac_address* release_radio_mac();
  ::ce::nbapi::mac_address* mutable_radio_mac();
  void set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac);

  // optional int32 rssi_val = 3;
  bool has_rssi_val() const;
  void clear_rssi_val();
  static const int kRssiValFieldNumber = 3;
  ::google::protobuf::int32 rssi_val() const;
  void set_rssi_val(::google::protobuf::int32 value);

  // optional .ce.nbapi.target_dev_type target_type = 6 [default = TARGET_TYPE_STATION];
  bool has_target_type() const;
  void clear_target_type();
  static const int kTargetTypeFieldNumber = 6;
  ::ce::nbapi::target_dev_type target_type() const;
  void set_target_type(::ce::nbapi::target_dev_type value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.proximity)
 private:
  void set_has_sta_eth_mac();
  void clear_has_sta_eth_mac();
  void set_has_radio_mac();
  void clear_has_radio_mac();
  void set_has_rssi_val();
  void clear_has_rssi_val();
  void set_has_ap_name();
  void clear_has_ap_name();
  void set_has_hashed_sta_eth_mac();
  void clear_has_hashed_sta_eth_mac();
  void set_has_target_type();
  void clear_has_target_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ap_name_;
  ::google::protobuf::internal::ArenaStringPtr hashed_sta_eth_mac_;
  ::ce::nbapi::mac_address* sta_eth_mac_;
  ::ce::nbapi::mac_address* radio_mac_;
  ::google::protobuf::int32 rssi_val_;
  int target_type_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class dot1x : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.dot1x) */ {
 public:
  dot1x();
  virtual ~dot1x();

  dot1x(const dot1x& from);

  inline dot1x& operator=(const dot1x& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  dot1x(dot1x&& from) noexcept
    : dot1x() {
    *this = ::std::move(from);
  }

  inline dot1x& operator=(dot1x&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const dot1x& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const dot1x* internal_default_instance() {
    return reinterpret_cast<const dot1x*>(
               &_dot1x_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(dot1x* other);
  friend void swap(dot1x& a, dot1x& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline dot1x* New() const final {
    return CreateMaybeMessage<dot1x>(NULL);
  }

  dot1x* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<dot1x>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const dot1x& from);
  void MergeFrom(const dot1x& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(dot1x* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 4;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 4;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional .ce.nbapi.mac_address station_mac = 3;
  bool has_station_mac() const;
  void clear_station_mac();
  static const int kStationMacFieldNumber = 3;
  private:
  const ::ce::nbapi::mac_address& _internal_station_mac() const;
  public:
  const ::ce::nbapi::mac_address& station_mac() const;
  ::ce::nbapi::mac_address* release_station_mac();
  ::ce::nbapi::mac_address* mutable_station_mac();
  void set_allocated_station_mac(::ce::nbapi::mac_address* station_mac);

  // optional .ce.nbapi.mac_address bssid = 5;
  bool has_bssid() const;
  void clear_bssid();
  static const int kBssidFieldNumber = 5;
  private:
  const ::ce::nbapi::mac_address& _internal_bssid() const;
  public:
  const ::ce::nbapi::mac_address& bssid() const;
  ::ce::nbapi::mac_address* release_bssid();
  ::ce::nbapi::mac_address* mutable_bssid();
  void set_allocated_bssid(::ce::nbapi::mac_address* bssid);

  // optional .ce.nbapi.ip_address serverip = 10;
  bool has_serverip() const;
  void clear_serverip();
  static const int kServeripFieldNumber = 10;
  private:
  const ::ce::nbapi::ip_address& _internal_serverip() const;
  public:
  const ::ce::nbapi::ip_address& serverip() const;
  ::ce::nbapi::ip_address* release_serverip();
  ::ce::nbapi::ip_address* mutable_serverip();
  void set_allocated_serverip(::ce::nbapi::ip_address* serverip);

  // optional uint64 start_timestamp = 1;
  bool has_start_timestamp() const;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 1;
  ::google::protobuf::uint64 start_timestamp() const;
  void set_start_timestamp(::google::protobuf::uint64 value);

  // optional uint64 finish_timestamp = 2;
  bool has_finish_timestamp() const;
  void clear_finish_timestamp();
  static const int kFinishTimestampFieldNumber = 2;
  ::google::protobuf::uint64 finish_timestamp() const;
  void set_finish_timestamp(::google::protobuf::uint64 value);

  // optional uint32 result = 6;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 6;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // optional uint32 reason = 7;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 7;
  ::google::protobuf::uint32 reason() const;
  void set_reason(::google::protobuf::uint32 value);

  // optional uint32 server_retry_cnt = 8;
  bool has_server_retry_cnt() const;
  void clear_server_retry_cnt();
  static const int kServerRetryCntFieldNumber = 8;
  ::google::protobuf::uint32 server_retry_cnt() const;
  void set_server_retry_cnt(::google::protobuf::uint32 value);

  // optional uint32 client_retry_cnt = 9;
  bool has_client_retry_cnt() const;
  void clear_client_retry_cnt();
  static const int kClientRetryCntFieldNumber = 9;
  ::google::protobuf::uint32 client_retry_cnt() const;
  void set_client_retry_cnt(::google::protobuf::uint32 value);

  // optional uint32 srvr_elapsed_time = 11;
  bool has_srvr_elapsed_time() const;
  void clear_srvr_elapsed_time();
  static const int kSrvrElapsedTimeFieldNumber = 11;
  ::google::protobuf::uint32 srvr_elapsed_time() const;
  void set_srvr_elapsed_time(::google::protobuf::uint32 value);

  // optional uint32 clnt_elapsed_time = 12;
  bool has_clnt_elapsed_time() const;
  void clear_clnt_elapsed_time();
  static const int kClntElapsedTimeFieldNumber = 12;
  ::google::protobuf::uint32 clnt_elapsed_time() const;
  void set_clnt_elapsed_time(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.dot1x)
 private:
  void set_has_start_timestamp();
  void clear_has_start_timestamp();
  void set_has_finish_timestamp();
  void clear_has_finish_timestamp();
  void set_has_station_mac();
  void clear_has_station_mac();
  void set_has_username();
  void clear_has_username();
  void set_has_bssid();
  void clear_has_bssid();
  void set_has_result();
  void clear_has_result();
  void set_has_reason();
  void clear_has_reason();
  void set_has_server_retry_cnt();
  void clear_has_server_retry_cnt();
  void set_has_client_retry_cnt();
  void clear_has_client_retry_cnt();
  void set_has_serverip();
  void clear_has_serverip();
  void set_has_srvr_elapsed_time();
  void clear_has_srvr_elapsed_time();
  void set_has_clnt_elapsed_time();
  void clear_has_clnt_elapsed_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::ce::nbapi::mac_address* station_mac_;
  ::ce::nbapi::mac_address* bssid_;
  ::ce::nbapi::ip_address* serverip_;
  ::google::protobuf::uint64 start_timestamp_;
  ::google::protobuf::uint64 finish_timestamp_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 reason_;
  ::google::protobuf::uint32 server_retry_cnt_;
  ::google::protobuf::uint32 client_retry_cnt_;
  ::google::protobuf::uint32 srvr_elapsed_time_;
  ::google::protobuf::uint32 clnt_elapsed_time_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class wpa_key_handshake : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.wpa_key_handshake) */ {
 public:
  wpa_key_handshake();
  virtual ~wpa_key_handshake();

  wpa_key_handshake(const wpa_key_handshake& from);

  inline wpa_key_handshake& operator=(const wpa_key_handshake& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  wpa_key_handshake(wpa_key_handshake&& from) noexcept
    : wpa_key_handshake() {
    *this = ::std::move(from);
  }

  inline wpa_key_handshake& operator=(wpa_key_handshake&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const wpa_key_handshake& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const wpa_key_handshake* internal_default_instance() {
    return reinterpret_cast<const wpa_key_handshake*>(
               &_wpa_key_handshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(wpa_key_handshake* other);
  friend void swap(wpa_key_handshake& a, wpa_key_handshake& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline wpa_key_handshake* New() const final {
    return CreateMaybeMessage<wpa_key_handshake>(NULL);
  }

  wpa_key_handshake* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<wpa_key_handshake>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const wpa_key_handshake& from);
  void MergeFrom(const wpa_key_handshake& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(wpa_key_handshake* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address station_mac = 3;
  bool has_station_mac() const;
  void clear_station_mac();
  static const int kStationMacFieldNumber = 3;
  private:
  const ::ce::nbapi::mac_address& _internal_station_mac() const;
  public:
  const ::ce::nbapi::mac_address& station_mac() const;
  ::ce::nbapi::mac_address* release_station_mac();
  ::ce::nbapi::mac_address* mutable_station_mac();
  void set_allocated_station_mac(::ce::nbapi::mac_address* station_mac);

  // optional .ce.nbapi.mac_address bssid = 4;
  bool has_bssid() const;
  void clear_bssid();
  static const int kBssidFieldNumber = 4;
  private:
  const ::ce::nbapi::mac_address& _internal_bssid() const;
  public:
  const ::ce::nbapi::mac_address& bssid() const;
  ::ce::nbapi::mac_address* release_bssid();
  ::ce::nbapi::mac_address* mutable_bssid();
  void set_allocated_bssid(::ce::nbapi::mac_address* bssid);

  // optional uint64 start_timestamp = 1;
  bool has_start_timestamp() const;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 1;
  ::google::protobuf::uint64 start_timestamp() const;
  void set_start_timestamp(::google::protobuf::uint64 value);

  // optional uint64 finish_timestamp = 2;
  bool has_finish_timestamp() const;
  void clear_finish_timestamp();
  static const int kFinishTimestampFieldNumber = 2;
  ::google::protobuf::uint64 finish_timestamp() const;
  void set_finish_timestamp(::google::protobuf::uint64 value);

  // optional uint32 result = 5;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 5;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // optional uint32 trigger_reason = 6;
  bool has_trigger_reason() const;
  void clear_trigger_reason();
  static const int kTriggerReasonFieldNumber = 6;
  ::google::protobuf::uint32 trigger_reason() const;
  void set_trigger_reason(::google::protobuf::uint32 value);

  // optional uint32 reason = 7;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 7;
  ::google::protobuf::uint32 reason() const;
  void set_reason(::google::protobuf::uint32 value);

  // optional uint32 key1_retry_cnt = 8;
  bool has_key1_retry_cnt() const;
  void clear_key1_retry_cnt();
  static const int kKey1RetryCntFieldNumber = 8;
  ::google::protobuf::uint32 key1_retry_cnt() const;
  void set_key1_retry_cnt(::google::protobuf::uint32 value);

  // optional uint32 key3_retry_cnt = 9;
  bool has_key3_retry_cnt() const;
  void clear_key3_retry_cnt();
  static const int kKey3RetryCntFieldNumber = 9;
  ::google::protobuf::uint32 key3_retry_cnt() const;
  void set_key3_retry_cnt(::google::protobuf::uint32 value);

  // optional uint32 replay_counter_mismatch = 10;
  bool has_replay_counter_mismatch() const;
  void clear_replay_counter_mismatch();
  static const int kReplayCounterMismatchFieldNumber = 10;
  ::google::protobuf::uint32 replay_counter_mismatch() const;
  void set_replay_counter_mismatch(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.wpa_key_handshake)
 private:
  void set_has_start_timestamp();
  void clear_has_start_timestamp();
  void set_has_finish_timestamp();
  void clear_has_finish_timestamp();
  void set_has_station_mac();
  void clear_has_station_mac();
  void set_has_bssid();
  void clear_has_bssid();
  void set_has_result();
  void clear_has_result();
  void set_has_trigger_reason();
  void clear_has_trigger_reason();
  void set_has_reason();
  void clear_has_reason();
  void set_has_key1_retry_cnt();
  void clear_has_key1_retry_cnt();
  void set_has_key3_retry_cnt();
  void clear_has_key3_retry_cnt();
  void set_has_replay_counter_mismatch();
  void clear_has_replay_counter_mismatch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* station_mac_;
  ::ce::nbapi::mac_address* bssid_;
  ::google::protobuf::uint64 start_timestamp_;
  ::google::protobuf::uint64 finish_timestamp_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 trigger_reason_;
  ::google::protobuf::uint32 reason_;
  ::google::protobuf::uint32 key1_retry_cnt_;
  ::google::protobuf::uint32 key3_retry_cnt_;
  ::google::protobuf::uint32 replay_counter_mismatch_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class captive_portal : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.captive_portal) */ {
 public:
  captive_portal();
  virtual ~captive_portal();

  captive_portal(const captive_portal& from);

  inline captive_portal& operator=(const captive_portal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  captive_portal(captive_portal&& from) noexcept
    : captive_portal() {
    *this = ::std::move(from);
  }

  inline captive_portal& operator=(captive_portal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const captive_portal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const captive_portal* internal_default_instance() {
    return reinterpret_cast<const captive_portal*>(
               &_captive_portal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(captive_portal* other);
  friend void swap(captive_portal& a, captive_portal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline captive_portal* New() const final {
    return CreateMaybeMessage<captive_portal>(NULL);
  }

  captive_portal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<captive_portal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const captive_portal& from);
  void MergeFrom(const captive_portal& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(captive_portal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string username = 4;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 4;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional .ce.nbapi.mac_address station_mac = 3;
  bool has_station_mac() const;
  void clear_station_mac();
  static const int kStationMacFieldNumber = 3;
  private:
  const ::ce::nbapi::mac_address& _internal_station_mac() const;
  public:
  const ::ce::nbapi::mac_address& station_mac() const;
  ::ce::nbapi::mac_address* release_station_mac();
  ::ce::nbapi::mac_address* mutable_station_mac();
  void set_allocated_station_mac(::ce::nbapi::mac_address* station_mac);

  // optional .ce.nbapi.mac_address bssid = 5;
  bool has_bssid() const;
  void clear_bssid();
  static const int kBssidFieldNumber = 5;
  private:
  const ::ce::nbapi::mac_address& _internal_bssid() const;
  public:
  const ::ce::nbapi::mac_address& bssid() const;
  ::ce::nbapi::mac_address* release_bssid();
  ::ce::nbapi::mac_address* mutable_bssid();
  void set_allocated_bssid(::ce::nbapi::mac_address* bssid);

  // optional .ce.nbapi.ip_address serverip = 9;
  bool has_serverip() const;
  void clear_serverip();
  static const int kServeripFieldNumber = 9;
  private:
  const ::ce::nbapi::ip_address& _internal_serverip() const;
  public:
  const ::ce::nbapi::ip_address& serverip() const;
  ::ce::nbapi::ip_address* release_serverip();
  ::ce::nbapi::ip_address* mutable_serverip();
  void set_allocated_serverip(::ce::nbapi::ip_address* serverip);

  // optional .ce.nbapi.ip_address userip = 10;
  bool has_userip() const;
  void clear_userip();
  static const int kUseripFieldNumber = 10;
  private:
  const ::ce::nbapi::ip_address& _internal_userip() const;
  public:
  const ::ce::nbapi::ip_address& userip() const;
  ::ce::nbapi::ip_address* release_userip();
  ::ce::nbapi::ip_address* mutable_userip();
  void set_allocated_userip(::ce::nbapi::ip_address* userip);

  // optional uint64 start_timestamp = 1;
  bool has_start_timestamp() const;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 1;
  ::google::protobuf::uint64 start_timestamp() const;
  void set_start_timestamp(::google::protobuf::uint64 value);

  // optional uint64 finish_timestamp = 2;
  bool has_finish_timestamp() const;
  void clear_finish_timestamp();
  static const int kFinishTimestampFieldNumber = 2;
  ::google::protobuf::uint64 finish_timestamp() const;
  void set_finish_timestamp(::google::protobuf::uint64 value);

  // optional uint32 result = 6;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 6;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // optional uint32 reason = 7;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 7;
  ::google::protobuf::uint32 reason() const;
  void set_reason(::google::protobuf::uint32 value);

  // optional uint32 server_retry_cnt = 8;
  bool has_server_retry_cnt() const;
  void clear_server_retry_cnt();
  static const int kServerRetryCntFieldNumber = 8;
  ::google::protobuf::uint32 server_retry_cnt() const;
  void set_server_retry_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.captive_portal)
 private:
  void set_has_start_timestamp();
  void clear_has_start_timestamp();
  void set_has_finish_timestamp();
  void clear_has_finish_timestamp();
  void set_has_station_mac();
  void clear_has_station_mac();
  void set_has_username();
  void clear_has_username();
  void set_has_bssid();
  void clear_has_bssid();
  void set_has_result();
  void clear_has_result();
  void set_has_reason();
  void clear_has_reason();
  void set_has_server_retry_cnt();
  void clear_has_server_retry_cnt();
  void set_has_serverip();
  void clear_has_serverip();
  void set_has_userip();
  void clear_has_userip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::ce::nbapi::mac_address* station_mac_;
  ::ce::nbapi::mac_address* bssid_;
  ::ce::nbapi::ip_address* serverip_;
  ::ce::nbapi::ip_address* userip_;
  ::google::protobuf::uint64 start_timestamp_;
  ::google::protobuf::uint64 finish_timestamp_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 reason_;
  ::google::protobuf::uint32 server_retry_cnt_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class macauth : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.macauth) */ {
 public:
  macauth();
  virtual ~macauth();

  macauth(const macauth& from);

  inline macauth& operator=(const macauth& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  macauth(macauth&& from) noexcept
    : macauth() {
    *this = ::std::move(from);
  }

  inline macauth& operator=(macauth&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const macauth& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const macauth* internal_default_instance() {
    return reinterpret_cast<const macauth*>(
               &_macauth_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(macauth* other);
  friend void swap(macauth& a, macauth& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline macauth* New() const final {
    return CreateMaybeMessage<macauth>(NULL);
  }

  macauth* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<macauth>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const macauth& from);
  void MergeFrom(const macauth& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(macauth* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address station_mac = 3;
  bool has_station_mac() const;
  void clear_station_mac();
  static const int kStationMacFieldNumber = 3;
  private:
  const ::ce::nbapi::mac_address& _internal_station_mac() const;
  public:
  const ::ce::nbapi::mac_address& station_mac() const;
  ::ce::nbapi::mac_address* release_station_mac();
  ::ce::nbapi::mac_address* mutable_station_mac();
  void set_allocated_station_mac(::ce::nbapi::mac_address* station_mac);

  // optional .ce.nbapi.mac_address bssid = 4;
  bool has_bssid() const;
  void clear_bssid();
  static const int kBssidFieldNumber = 4;
  private:
  const ::ce::nbapi::mac_address& _internal_bssid() const;
  public:
  const ::ce::nbapi::mac_address& bssid() const;
  ::ce::nbapi::mac_address* release_bssid();
  ::ce::nbapi::mac_address* mutable_bssid();
  void set_allocated_bssid(::ce::nbapi::mac_address* bssid);

  // optional .ce.nbapi.ip_address serverip = 8;
  bool has_serverip() const;
  void clear_serverip();
  static const int kServeripFieldNumber = 8;
  private:
  const ::ce::nbapi::ip_address& _internal_serverip() const;
  public:
  const ::ce::nbapi::ip_address& serverip() const;
  ::ce::nbapi::ip_address* release_serverip();
  ::ce::nbapi::ip_address* mutable_serverip();
  void set_allocated_serverip(::ce::nbapi::ip_address* serverip);

  // optional uint64 start_timestamp = 1;
  bool has_start_timestamp() const;
  void clear_start_timestamp();
  static const int kStartTimestampFieldNumber = 1;
  ::google::protobuf::uint64 start_timestamp() const;
  void set_start_timestamp(::google::protobuf::uint64 value);

  // optional uint64 finish_timestamp = 2;
  bool has_finish_timestamp() const;
  void clear_finish_timestamp();
  static const int kFinishTimestampFieldNumber = 2;
  ::google::protobuf::uint64 finish_timestamp() const;
  void set_finish_timestamp(::google::protobuf::uint64 value);

  // optional uint32 result = 5;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 5;
  ::google::protobuf::uint32 result() const;
  void set_result(::google::protobuf::uint32 value);

  // optional uint32 reason = 6;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 6;
  ::google::protobuf::uint32 reason() const;
  void set_reason(::google::protobuf::uint32 value);

  // optional uint32 server_retry_cnt = 7;
  bool has_server_retry_cnt() const;
  void clear_server_retry_cnt();
  static const int kServerRetryCntFieldNumber = 7;
  ::google::protobuf::uint32 server_retry_cnt() const;
  void set_server_retry_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.macauth)
 private:
  void set_has_start_timestamp();
  void clear_has_start_timestamp();
  void set_has_finish_timestamp();
  void clear_has_finish_timestamp();
  void set_has_station_mac();
  void clear_has_station_mac();
  void set_has_bssid();
  void clear_has_bssid();
  void set_has_result();
  void clear_has_result();
  void set_has_reason();
  void clear_has_reason();
  void set_has_server_retry_cnt();
  void clear_has_server_retry_cnt();
  void set_has_serverip();
  void clear_has_serverip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* station_mac_;
  ::ce::nbapi::mac_address* bssid_;
  ::ce::nbapi::ip_address* serverip_;
  ::google::protobuf::uint64 start_timestamp_;
  ::google::protobuf::uint64 finish_timestamp_;
  ::google::protobuf::uint32 result_;
  ::google::protobuf::uint32 reason_;
  ::google::protobuf::uint32 server_retry_cnt_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class auth_srvr_timeout : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.auth_srvr_timeout) */ {
 public:
  auth_srvr_timeout();
  virtual ~auth_srvr_timeout();

  auth_srvr_timeout(const auth_srvr_timeout& from);

  inline auth_srvr_timeout& operator=(const auth_srvr_timeout& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  auth_srvr_timeout(auth_srvr_timeout&& from) noexcept
    : auth_srvr_timeout() {
    *this = ::std::move(from);
  }

  inline auth_srvr_timeout& operator=(auth_srvr_timeout&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const auth_srvr_timeout& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const auth_srvr_timeout* internal_default_instance() {
    return reinterpret_cast<const auth_srvr_timeout*>(
               &_auth_srvr_timeout_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(auth_srvr_timeout* other);
  friend void swap(auth_srvr_timeout& a, auth_srvr_timeout& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline auth_srvr_timeout* New() const final {
    return CreateMaybeMessage<auth_srvr_timeout>(NULL);
  }

  auth_srvr_timeout* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<auth_srvr_timeout>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const auth_srvr_timeout& from);
  void MergeFrom(const auth_srvr_timeout& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(auth_srvr_timeout* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address station_mac = 2;
  bool has_station_mac() const;
  void clear_station_mac();
  static const int kStationMacFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_station_mac() const;
  public:
  const ::ce::nbapi::mac_address& station_mac() const;
  ::ce::nbapi::mac_address* release_station_mac();
  ::ce::nbapi::mac_address* mutable_station_mac();
  void set_allocated_station_mac(::ce::nbapi::mac_address* station_mac);

  // optional .ce.nbapi.mac_address bssid = 3;
  bool has_bssid() const;
  void clear_bssid();
  static const int kBssidFieldNumber = 3;
  private:
  const ::ce::nbapi::mac_address& _internal_bssid() const;
  public:
  const ::ce::nbapi::mac_address& bssid() const;
  ::ce::nbapi::mac_address* release_bssid();
  ::ce::nbapi::mac_address* mutable_bssid();
  void set_allocated_bssid(::ce::nbapi::mac_address* bssid);

  // optional .ce.nbapi.ip_address userip = 6;
  bool has_userip() const;
  void clear_userip();
  static const int kUseripFieldNumber = 6;
  private:
  const ::ce::nbapi::ip_address& _internal_userip() const;
  public:
  const ::ce::nbapi::ip_address& userip() const;
  ::ce::nbapi::ip_address* release_userip();
  ::ce::nbapi::ip_address* mutable_userip();
  void set_allocated_userip(::ce::nbapi::ip_address* userip);

  // optional .ce.nbapi.ip_address serverip = 7;
  bool has_serverip() const;
  void clear_serverip();
  static const int kServeripFieldNumber = 7;
  private:
  const ::ce::nbapi::ip_address& _internal_serverip() const;
  public:
  const ::ce::nbapi::ip_address& serverip() const;
  ::ce::nbapi::ip_address* release_serverip();
  ::ce::nbapi::ip_address* mutable_serverip();
  void set_allocated_serverip(::ce::nbapi::ip_address* serverip);

  // optional uint64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional uint32 authtype = 4;
  bool has_authtype() const;
  void clear_authtype();
  static const int kAuthtypeFieldNumber = 4;
  ::google::protobuf::uint32 authtype() const;
  void set_authtype(::google::protobuf::uint32 value);

  // optional uint32 retry_cnt = 5;
  bool has_retry_cnt() const;
  void clear_retry_cnt();
  static const int kRetryCntFieldNumber = 5;
  ::google::protobuf::uint32 retry_cnt() const;
  void set_retry_cnt(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.auth_srvr_timeout)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_station_mac();
  void clear_has_station_mac();
  void set_has_bssid();
  void clear_has_bssid();
  void set_has_authtype();
  void clear_has_authtype();
  void set_has_retry_cnt();
  void clear_has_retry_cnt();
  void set_has_userip();
  void clear_has_userip();
  void set_has_serverip();
  void clear_has_serverip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* station_mac_;
  ::ce::nbapi::mac_address* bssid_;
  ::ce::nbapi::ip_address* userip_;
  ::ce::nbapi::ip_address* serverip_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 authtype_;
  ::google::protobuf::uint32 retry_cnt_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class security_message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.security_message) */ {
 public:
  security_message();
  virtual ~security_message();

  security_message(const security_message& from);

  inline security_message& operator=(const security_message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  security_message(security_message&& from) noexcept
    : security_message() {
    *this = ::std::move(from);
  }

  inline security_message& operator=(security_message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const security_message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const security_message* internal_default_instance() {
    return reinterpret_cast<const security_message*>(
               &_security_message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(security_message* other);
  friend void swap(security_message& a, security_message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline security_message* New() const final {
    return CreateMaybeMessage<security_message>(NULL);
  }

  security_message* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<security_message>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const security_message& from);
  void MergeFrom(const security_message& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(security_message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef security_message_security_msg_type security_msg_type;
  static const security_msg_type AUTH_SRVR_TIMEOUT_MSG =
    security_message_security_msg_type_AUTH_SRVR_TIMEOUT_MSG;
  static const security_msg_type MACAUTH_MSG =
    security_message_security_msg_type_MACAUTH_MSG;
  static const security_msg_type CAPTIVE_PORTAL_MSG =
    security_message_security_msg_type_CAPTIVE_PORTAL_MSG;
  static const security_msg_type WPA_KEY_HANDSHAKE_MSG =
    security_message_security_msg_type_WPA_KEY_HANDSHAKE_MSG;
  static const security_msg_type DOT1X_MSG =
    security_message_security_msg_type_DOT1X_MSG;
  static const security_msg_type UNKNOWN_MSG =
    security_message_security_msg_type_UNKNOWN_MSG;
  static inline bool security_msg_type_IsValid(int value) {
    return security_message_security_msg_type_IsValid(value);
  }
  static const security_msg_type security_msg_type_MIN =
    security_message_security_msg_type_security_msg_type_MIN;
  static const security_msg_type security_msg_type_MAX =
    security_message_security_msg_type_security_msg_type_MAX;
  static const int security_msg_type_ARRAYSIZE =
    security_message_security_msg_type_security_msg_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  security_msg_type_descriptor() {
    return security_message_security_msg_type_descriptor();
  }
  static inline const ::std::string& security_msg_type_Name(security_msg_type value) {
    return security_message_security_msg_type_Name(value);
  }
  static inline bool security_msg_type_Parse(const ::std::string& name,
      security_msg_type* value) {
    return security_message_security_msg_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.auth_srvr_timeout auth_srvr_timeout = 2;
  bool has_auth_srvr_timeout() const;
  void clear_auth_srvr_timeout();
  static const int kAuthSrvrTimeoutFieldNumber = 2;
  private:
  const ::ce::nbapi::auth_srvr_timeout& _internal_auth_srvr_timeout() const;
  public:
  const ::ce::nbapi::auth_srvr_timeout& auth_srvr_timeout() const;
  ::ce::nbapi::auth_srvr_timeout* release_auth_srvr_timeout();
  ::ce::nbapi::auth_srvr_timeout* mutable_auth_srvr_timeout();
  void set_allocated_auth_srvr_timeout(::ce::nbapi::auth_srvr_timeout* auth_srvr_timeout);

  // optional .ce.nbapi.macauth macauth = 3;
  bool has_macauth() const;
  void clear_macauth();
  static const int kMacauthFieldNumber = 3;
  private:
  const ::ce::nbapi::macauth& _internal_macauth() const;
  public:
  const ::ce::nbapi::macauth& macauth() const;
  ::ce::nbapi::macauth* release_macauth();
  ::ce::nbapi::macauth* mutable_macauth();
  void set_allocated_macauth(::ce::nbapi::macauth* macauth);

  // optional .ce.nbapi.captive_portal captive_portal = 4;
  bool has_captive_portal() const;
  void clear_captive_portal();
  static const int kCaptivePortalFieldNumber = 4;
  private:
  const ::ce::nbapi::captive_portal& _internal_captive_portal() const;
  public:
  const ::ce::nbapi::captive_portal& captive_portal() const;
  ::ce::nbapi::captive_portal* release_captive_portal();
  ::ce::nbapi::captive_portal* mutable_captive_portal();
  void set_allocated_captive_portal(::ce::nbapi::captive_portal* captive_portal);

  // optional .ce.nbapi.wpa_key_handshake wpa_key_handshake = 5;
  bool has_wpa_key_handshake() const;
  void clear_wpa_key_handshake();
  static const int kWpaKeyHandshakeFieldNumber = 5;
  private:
  const ::ce::nbapi::wpa_key_handshake& _internal_wpa_key_handshake() const;
  public:
  const ::ce::nbapi::wpa_key_handshake& wpa_key_handshake() const;
  ::ce::nbapi::wpa_key_handshake* release_wpa_key_handshake();
  ::ce::nbapi::wpa_key_handshake* mutable_wpa_key_handshake();
  void set_allocated_wpa_key_handshake(::ce::nbapi::wpa_key_handshake* wpa_key_handshake);

  // optional .ce.nbapi.dot1x dot1x = 6;
  bool has_dot1x() const;
  void clear_dot1x();
  static const int kDot1XFieldNumber = 6;
  private:
  const ::ce::nbapi::dot1x& _internal_dot1x() const;
  public:
  const ::ce::nbapi::dot1x& dot1x() const;
  ::ce::nbapi::dot1x* release_dot1x();
  ::ce::nbapi::dot1x* mutable_dot1x();
  void set_allocated_dot1x(::ce::nbapi::dot1x* dot1x);

  // optional .ce.nbapi.security_message.security_msg_type msg_type = 1;
  bool has_msg_type() const;
  void clear_msg_type();
  static const int kMsgTypeFieldNumber = 1;
  ::ce::nbapi::security_message_security_msg_type msg_type() const;
  void set_msg_type(::ce::nbapi::security_message_security_msg_type value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.security_message)
 private:
  void set_has_msg_type();
  void clear_has_msg_type();
  void set_has_auth_srvr_timeout();
  void clear_has_auth_srvr_timeout();
  void set_has_macauth();
  void clear_has_macauth();
  void set_has_captive_portal();
  void clear_has_captive_portal();
  void set_has_wpa_key_handshake();
  void clear_has_wpa_key_handshake();
  void set_has_dot1x();
  void clear_has_dot1x();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::auth_srvr_timeout* auth_srvr_timeout_;
  ::ce::nbapi::macauth* macauth_;
  ::ce::nbapi::captive_portal* captive_portal_;
  ::ce::nbapi::wpa_key_handshake* wpa_key_handshake_;
  ::ce::nbapi::dot1x* dot1x_;
  int msg_type_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class spectrum_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.spectrum_info) */ {
 public:
  spectrum_info();
  virtual ~spectrum_info();

  spectrum_info(const spectrum_info& from);

  inline spectrum_info& operator=(const spectrum_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  spectrum_info(spectrum_info&& from) noexcept
    : spectrum_info() {
    *this = ::std::move(from);
  }

  inline spectrum_info& operator=(spectrum_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const spectrum_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const spectrum_info* internal_default_instance() {
    return reinterpret_cast<const spectrum_info*>(
               &_spectrum_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(spectrum_info* other);
  friend void swap(spectrum_info& a, spectrum_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline spectrum_info* New() const final {
    return CreateMaybeMessage<spectrum_info>(NULL);
  }

  spectrum_info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<spectrum_info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const spectrum_info& from);
  void MergeFrom(const spectrum_info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(spectrum_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address ap_mac = 1;
  bool has_ap_mac() const;
  void clear_ap_mac();
  static const int kApMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_mac() const;
  ::ce::nbapi::mac_address* release_ap_mac();
  ::ce::nbapi::mac_address* mutable_ap_mac();
  void set_allocated_ap_mac(::ce::nbapi::mac_address* ap_mac);

  // optional uint32 radio_number = 2;
  bool has_radio_number() const;
  void clear_radio_number();
  static const int kRadioNumberFieldNumber = 2;
  ::google::protobuf::uint32 radio_number() const;
  void set_radio_number(::google::protobuf::uint32 value);

  // optional uint32 dev_id = 3;
  bool has_dev_id() const;
  void clear_dev_id();
  static const int kDevIdFieldNumber = 3;
  ::google::protobuf::uint32 dev_id() const;
  void set_dev_id(::google::protobuf::uint32 value);

  // optional uint32 dev_type = 4;
  bool has_dev_type() const;
  void clear_dev_type();
  static const int kDevTypeFieldNumber = 4;
  ::google::protobuf::uint32 dev_type() const;
  void set_dev_type(::google::protobuf::uint32 value);

  // optional uint32 low_ch = 5;
  bool has_low_ch() const;
  void clear_low_ch();
  static const int kLowChFieldNumber = 5;
  ::google::protobuf::uint32 low_ch() const;
  void set_low_ch(::google::protobuf::uint32 value);

  // optional uint32 high_ch = 6;
  bool has_high_ch() const;
  void clear_high_ch();
  static const int kHighChFieldNumber = 6;
  ::google::protobuf::uint32 high_ch() const;
  void set_high_ch(::google::protobuf::uint32 value);

  // optional uint32 signal = 7;
  bool has_signal() const;
  void clear_signal();
  static const int kSignalFieldNumber = 7;
  ::google::protobuf::uint32 signal() const;
  void set_signal(::google::protobuf::uint32 value);

  // optional uint32 duty_cycle = 8;
  bool has_duty_cycle() const;
  void clear_duty_cycle();
  static const int kDutyCycleFieldNumber = 8;
  ::google::protobuf::uint32 duty_cycle() const;
  void set_duty_cycle(::google::protobuf::uint32 value);

  // optional uint32 center_freq = 9;
  bool has_center_freq() const;
  void clear_center_freq();
  static const int kCenterFreqFieldNumber = 9;
  ::google::protobuf::uint32 center_freq() const;
  void set_center_freq(::google::protobuf::uint32 value);

  // optional uint64 timestamp = 10;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 10;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional uint64 active_time = 11;
  bool has_active_time() const;
  void clear_active_time();
  static const int kActiveTimeFieldNumber = 11;
  ::google::protobuf::uint64 active_time() const;
  void set_active_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.spectrum_info)
 private:
  void set_has_ap_mac();
  void clear_has_ap_mac();
  void set_has_radio_number();
  void clear_has_radio_number();
  void set_has_dev_id();
  void clear_has_dev_id();
  void set_has_dev_type();
  void clear_has_dev_type();
  void set_has_low_ch();
  void clear_has_low_ch();
  void set_has_high_ch();
  void clear_has_high_ch();
  void set_has_signal();
  void clear_has_signal();
  void set_has_duty_cycle();
  void clear_has_duty_cycle();
  void set_has_center_freq();
  void clear_has_center_freq();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_active_time();
  void clear_has_active_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* ap_mac_;
  ::google::protobuf::uint32 radio_number_;
  ::google::protobuf::uint32 dev_id_;
  ::google::protobuf::uint32 dev_type_;
  ::google::protobuf::uint32 low_ch_;
  ::google::protobuf::uint32 high_ch_;
  ::google::protobuf::uint32 signal_;
  ::google::protobuf::uint32 duty_cycle_;
  ::google::protobuf::uint32 center_freq_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint64 active_time_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class rogue_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.rogue_info) */ {
 public:
  rogue_info();
  virtual ~rogue_info();

  rogue_info(const rogue_info& from);

  inline rogue_info& operator=(const rogue_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  rogue_info(rogue_info&& from) noexcept
    : rogue_info() {
    *this = ::std::move(from);
  }

  inline rogue_info& operator=(rogue_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rogue_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const rogue_info* internal_default_instance() {
    return reinterpret_cast<const rogue_info*>(
               &_rogue_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(rogue_info* other);
  friend void swap(rogue_info& a, rogue_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline rogue_info* New() const final {
    return CreateMaybeMessage<rogue_info>(NULL);
  }

  rogue_info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<rogue_info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const rogue_info& from);
  void MergeFrom(const rogue_info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rogue_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.mac_address monitor_mac = 1;
  bool has_monitor_mac() const;
  void clear_monitor_mac();
  static const int kMonitorMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_monitor_mac() const;
  public:
  const ::ce::nbapi::mac_address& monitor_mac() const;
  ::ce::nbapi::mac_address* release_monitor_mac();
  ::ce::nbapi::mac_address* mutable_monitor_mac();
  void set_allocated_monitor_mac(::ce::nbapi::mac_address* monitor_mac);

  // optional .ce.nbapi.mac_address heard_mac = 2;
  bool has_heard_mac() const;
  void clear_heard_mac();
  static const int kHeardMacFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_heard_mac() const;
  public:
  const ::ce::nbapi::mac_address& heard_mac() const;
  ::ce::nbapi::mac_address* release_heard_mac();
  ::ce::nbapi::mac_address* mutable_heard_mac();
  void set_allocated_heard_mac(::ce::nbapi::mac_address* heard_mac);

  // optional uint32 monitor_channel = 3;
  bool has_monitor_channel() const;
  void clear_monitor_channel();
  static const int kMonitorChannelFieldNumber = 3;
  ::google::protobuf::uint32 monitor_channel() const;
  void set_monitor_channel(::google::protobuf::uint32 value);

  // optional uint32 is_ap = 4;
  bool has_is_ap() const;
  void clear_is_ap();
  static const int kIsApFieldNumber = 4;
  ::google::protobuf::uint32 is_ap() const;
  void set_is_ap(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.rogue_info)
 private:
  void set_has_monitor_mac();
  void clear_has_monitor_mac();
  void set_has_heard_mac();
  void clear_has_heard_mac();
  void set_has_monitor_channel();
  void clear_has_monitor_channel();
  void set_has_is_ap();
  void clear_has_is_ap();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::mac_address* monitor_mac_;
  ::ce::nbapi::mac_address* heard_mac_;
  ::google::protobuf::uint32 monitor_channel_;
  ::google::protobuf::uint32 is_ap_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class key_value_type : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.key_value_type) */ {
 public:
  key_value_type();
  virtual ~key_value_type();

  key_value_type(const key_value_type& from);

  inline key_value_type& operator=(const key_value_type& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  key_value_type(key_value_type&& from) noexcept
    : key_value_type() {
    *this = ::std::move(from);
  }

  inline key_value_type& operator=(key_value_type&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const key_value_type& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const key_value_type* internal_default_instance() {
    return reinterpret_cast<const key_value_type*>(
               &_key_value_type_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(key_value_type* other);
  friend void swap(key_value_type& a, key_value_type& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline key_value_type* New() const final {
    return CreateMaybeMessage<key_value_type>(NULL);
  }

  key_value_type* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<key_value_type>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const key_value_type& from);
  void MergeFrom(const key_value_type& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(key_value_type* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.key_value_type)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.info) */ {
 public:
  info();
  virtual ~info();

  info(const info& from);

  inline info& operator=(const info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  info(info&& from) noexcept
    : info() {
    *this = ::std::move(from);
  }

  inline info& operator=(info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const info* internal_default_instance() {
    return reinterpret_cast<const info*>(
               &_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  void Swap(info* other);
  friend void swap(info& a, info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline info* New() const final {
    return CreateMaybeMessage<info>(NULL);
  }

  info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const info& from);
  void MergeFrom(const info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef info_mode_type mode_type;
  static const mode_type CONTEXT =
    info_mode_type_CONTEXT;
  static const mode_type CONTEXT_AND_LOCATION_WITH_CALIBRATION =
    info_mode_type_CONTEXT_AND_LOCATION_WITH_CALIBRATION;
  static const mode_type CONTEXT_AND_ESTIMATED_LOCATION =
    info_mode_type_CONTEXT_AND_ESTIMATED_LOCATION;
  static inline bool mode_type_IsValid(int value) {
    return info_mode_type_IsValid(value);
  }
  static const mode_type mode_type_MIN =
    info_mode_type_mode_type_MIN;
  static const mode_type mode_type_MAX =
    info_mode_type_mode_type_MAX;
  static const int mode_type_ARRAYSIZE =
    info_mode_type_mode_type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  mode_type_descriptor() {
    return info_mode_type_descriptor();
  }
  static inline const ::std::string& mode_type_Name(mode_type value) {
    return info_mode_type_Name(value);
  }
  static inline bool mode_type_Parse(const ::std::string& name,
      mode_type* value) {
    return info_mode_type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .ce.nbapi.key_value_type key_value = 3;
  int key_value_size() const;
  void clear_key_value();
  static const int kKeyValueFieldNumber = 3;
  ::ce::nbapi::key_value_type* mutable_key_value(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::key_value_type >*
      mutable_key_value();
  const ::ce::nbapi::key_value_type& key_value(int index) const;
  ::ce::nbapi::key_value_type* add_key_value();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::key_value_type >&
      key_value() const;

  // optional .ce.nbapi.info.mode_type current_mode = 1;
  bool has_current_mode() const;
  void clear_current_mode();
  static const int kCurrentModeFieldNumber = 1;
  ::ce::nbapi::info_mode_type current_mode() const;
  void set_current_mode(::ce::nbapi::info_mode_type value);

  // optional bool license_valid = 2;
  bool has_license_valid() const;
  void clear_license_valid();
  static const int kLicenseValidFieldNumber = 2;
  bool license_valid() const;
  void set_license_valid(bool value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.info)
 private:
  void set_has_current_mode();
  void clear_has_current_mode();
  void set_has_license_valid();
  void clear_has_license_valid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::key_value_type > key_value_;
  int current_mode_;
  bool license_valid_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class controller_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.controller_info) */ {
 public:
  controller_info();
  virtual ~controller_info();

  controller_info(const controller_info& from);

  inline controller_info& operator=(const controller_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  controller_info(controller_info&& from) noexcept
    : controller_info() {
    *this = ::std::move(from);
  }

  inline controller_info& operator=(controller_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const controller_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const controller_info* internal_default_instance() {
    return reinterpret_cast<const controller_info*>(
               &_controller_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  void Swap(controller_info* other);
  friend void swap(controller_info& a, controller_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline controller_info* New() const final {
    return CreateMaybeMessage<controller_info>(NULL);
  }

  controller_info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<controller_info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const controller_info& from);
  void MergeFrom(const controller_info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(controller_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ce.nbapi.access_point access_points = 2;
  int access_points_size() const;
  void clear_access_points();
  static const int kAccessPointsFieldNumber = 2;
  ::ce::nbapi::access_point* mutable_access_points(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::access_point >*
      mutable_access_points();
  const ::ce::nbapi::access_point& access_points(int index) const;
  ::ce::nbapi::access_point* add_access_points();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::access_point >&
      access_points() const;

  // required .ce.nbapi.ip_address controller_ip_address = 1;
  bool has_controller_ip_address() const;
  void clear_controller_ip_address();
  static const int kControllerIpAddressFieldNumber = 1;
  private:
  const ::ce::nbapi::ip_address& _internal_controller_ip_address() const;
  public:
  const ::ce::nbapi::ip_address& controller_ip_address() const;
  ::ce::nbapi::ip_address* release_controller_ip_address();
  ::ce::nbapi::ip_address* mutable_controller_ip_address();
  void set_allocated_controller_ip_address(::ce::nbapi::ip_address* controller_ip_address);

  // @@protoc_insertion_point(class_scope:ce.nbapi.controller_info)
 private:
  void set_has_controller_ip_address();
  void clear_has_controller_ip_address();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::access_point > access_points_;
  ::ce::nbapi::ip_address* controller_ip_address_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class cluster_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.cluster_info) */ {
 public:
  cluster_info();
  virtual ~cluster_info();

  cluster_info(const cluster_info& from);

  inline cluster_info& operator=(const cluster_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  cluster_info(cluster_info&& from) noexcept
    : cluster_info() {
    *this = ::std::move(from);
  }

  inline cluster_info& operator=(cluster_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const cluster_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const cluster_info* internal_default_instance() {
    return reinterpret_cast<const cluster_info*>(
               &_cluster_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  void Swap(cluster_info* other);
  friend void swap(cluster_info& a, cluster_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline cluster_info* New() const final {
    return CreateMaybeMessage<cluster_info>(NULL);
  }

  cluster_info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<cluster_info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const cluster_info& from);
  void MergeFrom(const cluster_info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(cluster_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ce.nbapi.access_point access_points = 5;
  int access_points_size() const;
  void clear_access_points();
  static const int kAccessPointsFieldNumber = 5;
  ::ce::nbapi::access_point* mutable_access_points(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::access_point >*
      mutable_access_points();
  const ::ce::nbapi::access_point& access_points(int index) const;
  ::ce::nbapi::access_point* add_access_points();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::access_point >&
      access_points() const;

  // optional string cluster_key = 1;
  bool has_cluster_key() const;
  void clear_cluster_key();
  static const int kClusterKeyFieldNumber = 1;
  const ::std::string& cluster_key() const;
  void set_cluster_key(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster_key(::std::string&& value);
  #endif
  void set_cluster_key(const char* value);
  void set_cluster_key(const char* value, size_t size);
  ::std::string* mutable_cluster_key();
  ::std::string* release_cluster_key();
  void set_allocated_cluster_key(::std::string* cluster_key);

  // optional string cluster_name = 2;
  bool has_cluster_name() const;
  void clear_cluster_name();
  static const int kClusterNameFieldNumber = 2;
  const ::std::string& cluster_name() const;
  void set_cluster_name(const ::std::string& value);
  #if LANG_CXX11
  void set_cluster_name(::std::string&& value);
  #endif
  void set_cluster_name(const char* value);
  void set_cluster_name(const char* value, size_t size);
  ::std::string* mutable_cluster_name();
  ::std::string* release_cluster_name();
  void set_allocated_cluster_name(::std::string* cluster_name);

  // optional string organization = 3;
  bool has_organization() const;
  void clear_organization();
  static const int kOrganizationFieldNumber = 3;
  const ::std::string& organization() const;
  void set_organization(const ::std::string& value);
  #if LANG_CXX11
  void set_organization(::std::string&& value);
  #endif
  void set_organization(const char* value);
  void set_organization(const char* value, size_t size);
  ::std::string* mutable_organization();
  ::std::string* release_organization();
  void set_allocated_organization(::std::string* organization);

  // optional .ce.nbapi.ip_address cluster_ip = 4;
  bool has_cluster_ip() const;
  void clear_cluster_ip();
  static const int kClusterIpFieldNumber = 4;
  private:
  const ::ce::nbapi::ip_address& _internal_cluster_ip() const;
  public:
  const ::ce::nbapi::ip_address& cluster_ip() const;
  ::ce::nbapi::ip_address* release_cluster_ip();
  ::ce::nbapi::ip_address* mutable_cluster_ip();
  void set_allocated_cluster_ip(::ce::nbapi::ip_address* cluster_ip);

  // @@protoc_insertion_point(class_scope:ce.nbapi.cluster_info)
 private:
  void set_has_cluster_key();
  void clear_has_cluster_key();
  void set_has_cluster_name();
  void clear_has_cluster_name();
  void set_has_organization();
  void clear_has_organization();
  void set_has_cluster_ip();
  void clear_has_cluster_ip();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::access_point > access_points_;
  ::google::protobuf::internal::ArenaStringPtr cluster_key_;
  ::google::protobuf::internal::ArenaStringPtr cluster_name_;
  ::google::protobuf::internal::ArenaStringPtr organization_;
  ::ce::nbapi::ip_address* cluster_ip_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class topology : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.topology) */ {
 public:
  topology();
  virtual ~topology();

  topology(const topology& from);

  inline topology& operator=(const topology& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  topology(topology&& from) noexcept
    : topology() {
    *this = ::std::move(from);
  }

  inline topology& operator=(topology&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const topology& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const topology* internal_default_instance() {
    return reinterpret_cast<const topology*>(
               &_topology_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  void Swap(topology* other);
  friend void swap(topology& a, topology& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline topology* New() const final {
    return CreateMaybeMessage<topology>(NULL);
  }

  topology* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<topology>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const topology& from);
  void MergeFrom(const topology& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(topology* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ce.nbapi.controller_info controller = 2;
  bool has_controller() const;
  void clear_controller();
  static const int kControllerFieldNumber = 2;
  private:
  const ::ce::nbapi::controller_info& _internal_controller() const;
  public:
  const ::ce::nbapi::controller_info& controller() const;
  ::ce::nbapi::controller_info* release_controller();
  ::ce::nbapi::controller_info* mutable_controller();
  void set_allocated_controller(::ce::nbapi::controller_info* controller);

  // optional .ce.nbapi.cluster_info cluster = 3;
  bool has_cluster() const;
  void clear_cluster();
  static const int kClusterFieldNumber = 3;
  private:
  const ::ce::nbapi::cluster_info& _internal_cluster() const;
  public:
  const ::ce::nbapi::cluster_info& cluster() const;
  ::ce::nbapi::cluster_info* release_cluster();
  ::ce::nbapi::cluster_info* mutable_cluster();
  void set_allocated_cluster(::ce::nbapi::cluster_info* cluster);

  // @@protoc_insertion_point(class_scope:ce.nbapi.topology)
 private:
  void set_has_controller();
  void clear_has_controller();
  void set_has_cluster();
  void clear_has_cluster();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::controller_info* controller_;
  ::ce::nbapi::cluster_info* cluster_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ap_location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.ap_location) */ {
 public:
  ap_location();
  virtual ~ap_location();

  ap_location(const ap_location& from);

  inline ap_location& operator=(const ap_location& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ap_location(ap_location&& from) noexcept
    : ap_location() {
    *this = ::std::move(from);
  }

  inline ap_location& operator=(ap_location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ap_location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ap_location* internal_default_instance() {
    return reinterpret_cast<const ap_location*>(
               &_ap_location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  void Swap(ap_location* other);
  friend void swap(ap_location& a, ap_location& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ap_location* New() const final {
    return CreateMaybeMessage<ap_location>(NULL);
  }

  ap_location* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ap_location>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ap_location& from);
  void MergeFrom(const ap_location& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ap_location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes campus_id = 2;
  bool has_campus_id() const;
  void clear_campus_id();
  static const int kCampusIdFieldNumber = 2;
  const ::std::string& campus_id() const;
  void set_campus_id(const ::std::string& value);
  #if LANG_CXX11
  void set_campus_id(::std::string&& value);
  #endif
  void set_campus_id(const char* value);
  void set_campus_id(const void* value, size_t size);
  ::std::string* mutable_campus_id();
  ::std::string* release_campus_id();
  void set_allocated_campus_id(::std::string* campus_id);

  // optional bytes building_id = 3;
  bool has_building_id() const;
  void clear_building_id();
  static const int kBuildingIdFieldNumber = 3;
  const ::std::string& building_id() const;
  void set_building_id(const ::std::string& value);
  #if LANG_CXX11
  void set_building_id(::std::string&& value);
  #endif
  void set_building_id(const char* value);
  void set_building_id(const void* value, size_t size);
  ::std::string* mutable_building_id();
  ::std::string* release_building_id();
  void set_allocated_building_id(::std::string* building_id);

  // optional bytes floor_id = 4;
  bool has_floor_id() const;
  void clear_floor_id();
  static const int kFloorIdFieldNumber = 4;
  const ::std::string& floor_id() const;
  void set_floor_id(const ::std::string& value);
  #if LANG_CXX11
  void set_floor_id(::std::string&& value);
  #endif
  void set_floor_id(const char* value);
  void set_floor_id(const void* value, size_t size);
  ::std::string* mutable_floor_id();
  ::std::string* release_floor_id();
  void set_allocated_floor_id(::std::string* floor_id);

  // required .ce.nbapi.mac_address ap_eth_mac = 1;
  bool has_ap_eth_mac() const;
  void clear_ap_eth_mac();
  static const int kApEthMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_eth_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_eth_mac() const;
  ::ce::nbapi::mac_address* release_ap_eth_mac();
  ::ce::nbapi::mac_address* mutable_ap_eth_mac();
  void set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac);

  // optional double longitude = 5;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 5;
  double longitude() const;
  void set_longitude(double value);

  // optional double latitude = 6;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 6;
  double latitude() const;
  void set_latitude(double value);

  // optional double ap_x = 7;
  bool has_ap_x() const;
  void clear_ap_x();
  static const int kApXFieldNumber = 7;
  double ap_x() const;
  void set_ap_x(double value);

  // optional double ap_y = 8;
  bool has_ap_y() const;
  void clear_ap_y();
  static const int kApYFieldNumber = 8;
  double ap_y() const;
  void set_ap_y(double value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.ap_location)
 private:
  void set_has_ap_eth_mac();
  void clear_has_ap_eth_mac();
  void set_has_campus_id();
  void clear_has_campus_id();
  void set_has_building_id();
  void clear_has_building_id();
  void set_has_floor_id();
  void clear_has_floor_id();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_ap_x();
  void clear_has_ap_x();
  void set_has_ap_y();
  void clear_has_ap_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr campus_id_;
  ::google::protobuf::internal::ArenaStringPtr building_id_;
  ::google::protobuf::internal::ArenaStringPtr floor_id_;
  ::ce::nbapi::mac_address* ap_eth_mac_;
  double longitude_;
  double latitude_;
  double ap_x_;
  double ap_y_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class nb_event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.nb_event) */ {
 public:
  nb_event();
  virtual ~nb_event();

  nb_event(const nb_event& from);

  inline nb_event& operator=(const nb_event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  nb_event(nb_event&& from) noexcept
    : nb_event() {
    *this = ::std::move(from);
  }

  inline nb_event& operator=(nb_event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const nb_event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const nb_event* internal_default_instance() {
    return reinterpret_cast<const nb_event*>(
               &_nb_event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  void Swap(nb_event* other);
  friend void swap(nb_event& a, nb_event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline nb_event* New() const final {
    return CreateMaybeMessage<nb_event>(NULL);
  }

  nb_event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<nb_event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const nb_event& from);
  void MergeFrom(const nb_event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(nb_event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef nb_event_event_operation event_operation;
  static const event_operation OP_ADD =
    nb_event_event_operation_OP_ADD;
  static const event_operation OP_UPDATE =
    nb_event_event_operation_OP_UPDATE;
  static const event_operation OP_DELETE =
    nb_event_event_operation_OP_DELETE;
  static const event_operation OP_SYNC =
    nb_event_event_operation_OP_SYNC;
  static inline bool event_operation_IsValid(int value) {
    return nb_event_event_operation_IsValid(value);
  }
  static const event_operation event_operation_MIN =
    nb_event_event_operation_event_operation_MIN;
  static const event_operation event_operation_MAX =
    nb_event_event_operation_event_operation_MAX;
  static const int event_operation_ARRAYSIZE =
    nb_event_event_operation_event_operation_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  event_operation_descriptor() {
    return nb_event_event_operation_descriptor();
  }
  static inline const ::std::string& event_operation_Name(event_operation value) {
    return nb_event_event_operation_Name(value);
  }
  static inline bool event_operation_Parse(const ::std::string& name,
      event_operation* value) {
    return nb_event_event_operation_Parse(name, value);
  }

  typedef nb_event_license_info license_info;
  static const license_info hb_Dhak =
    nb_event_license_info_hb_Dhak;
  static const license_info hb_LimitOk =
    nb_event_license_info_hb_LimitOk;
  static const license_info hb_ThresholdXNotice =
    nb_event_license_info_hb_ThresholdXNotice;
  static const license_info hb_ThresholdOkNotice =
    nb_event_license_info_hb_ThresholdOkNotice;
  static const license_info hb_LicenseExceeded =
    nb_event_license_info_hb_LicenseExceeded;
  static const license_info hb_EvalStarted =
    nb_event_license_info_hb_EvalStarted;
  static const license_info hb_NewLimitExceeded =
    nb_event_license_info_hb_NewLimitExceeded;
  static const license_info hb_EvalDone =
    nb_event_license_info_hb_EvalDone;
  static const license_info hb_ALSOnline =
    nb_event_license_info_hb_ALSOnline;
  static const license_info hb_ALSDieing =
    nb_event_license_info_hb_ALSDieing;
  static const license_info hb_LICENSE_BLOCKED =
    nb_event_license_info_hb_LICENSE_BLOCKED;
  static inline bool license_info_IsValid(int value) {
    return nb_event_license_info_IsValid(value);
  }
  static const license_info license_info_MIN =
    nb_event_license_info_license_info_MIN;
  static const license_info license_info_MAX =
    nb_event_license_info_license_info_MAX;
  static const int license_info_ARRAYSIZE =
    nb_event_license_info_license_info_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  license_info_descriptor() {
    return nb_event_license_info_descriptor();
  }
  static inline const ::std::string& license_info_Name(license_info value) {
    return nb_event_license_info_Name(value);
  }
  static inline bool license_info_Parse(const ::std::string& name,
      license_info* value) {
    return nb_event_license_info_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes source_id = 5;
  bool has_source_id() const;
  void clear_source_id();
  static const int kSourceIdFieldNumber = 5;
  const ::std::string& source_id() const;
  void set_source_id(const ::std::string& value);
  #if LANG_CXX11
  void set_source_id(::std::string&& value);
  #endif
  void set_source_id(const char* value);
  void set_source_id(const void* value, size_t size);
  ::std::string* mutable_source_id();
  ::std::string* release_source_id();
  void set_allocated_source_id(::std::string* source_id);

  // optional .ce.nbapi.location location = 500;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 500;
  private:
  const ::ce::nbapi::location& _internal_location() const;
  public:
  const ::ce::nbapi::location& location() const;
  ::ce::nbapi::location* release_location();
  ::ce::nbapi::location* mutable_location();
  void set_allocated_location(::ce::nbapi::location* location);

  // optional .ce.nbapi.presence presence = 501;
  bool has_presence() const;
  void clear_presence();
  static const int kPresenceFieldNumber = 501;
  private:
  const ::ce::nbapi::presence& _internal_presence() const;
  public:
  const ::ce::nbapi::presence& presence() const;
  ::ce::nbapi::presence* release_presence();
  ::ce::nbapi::presence* mutable_presence();
  void set_allocated_presence(::ce::nbapi::presence* presence);

  // optional .ce.nbapi.rssi rssi = 502;
  bool has_rssi() const;
  void clear_rssi();
  static const int kRssiFieldNumber = 502;
  private:
  const ::ce::nbapi::rssi& _internal_rssi() const;
  public:
  const ::ce::nbapi::rssi& rssi() const;
  ::ce::nbapi::rssi* release_rssi();
  ::ce::nbapi::rssi* mutable_rssi();
  void set_allocated_rssi(::ce::nbapi::rssi* rssi);

  // optional .ce.nbapi.station station = 503;
  bool has_station() const;
  void clear_station();
  static const int kStationFieldNumber = 503;
  private:
  const ::ce::nbapi::station& _internal_station() const;
  public:
  const ::ce::nbapi::station& station() const;
  ::ce::nbapi::station* release_station();
  ::ce::nbapi::station* mutable_station();
  void set_allocated_station(::ce::nbapi::station* station);

  // optional .ce.nbapi.radio radio = 505;
  bool has_radio() const;
  void clear_radio();
  static const int kRadioFieldNumber = 505;
  private:
  const ::ce::nbapi::radio& _internal_radio() const;
  public:
  const ::ce::nbapi::radio& radio() const;
  ::ce::nbapi::radio* release_radio();
  ::ce::nbapi::radio* mutable_radio();
  void set_allocated_radio(::ce::nbapi::radio* radio);

  // optional .ce.nbapi.destination destination = 507;
  bool has_destination() const;
  void clear_destination();
  static const int kDestinationFieldNumber = 507;
  private:
  const ::ce::nbapi::destination& _internal_destination() const;
  public:
  const ::ce::nbapi::destination& destination() const;
  ::ce::nbapi::destination* release_destination();
  ::ce::nbapi::destination* mutable_destination();
  void set_allocated_destination(::ce::nbapi::destination* destination);

  // optional .ce.nbapi.application application = 509;
  bool has_application() const;
  void clear_application();
  static const int kApplicationFieldNumber = 509;
  private:
  const ::ce::nbapi::application& _internal_application() const;
  public:
  const ::ce::nbapi::application& application() const;
  ::ce::nbapi::application* release_application();
  ::ce::nbapi::application* mutable_application();
  void set_allocated_application(::ce::nbapi::application* application);

  // optional .ce.nbapi.visibility_rec visibility_rec = 510;
  bool has_visibility_rec() const;
  void clear_visibility_rec();
  static const int kVisibilityRecFieldNumber = 510;
  private:
  const ::ce::nbapi::visibility_rec& _internal_visibility_rec() const;
  public:
  const ::ce::nbapi::visibility_rec& visibility_rec() const;
  ::ce::nbapi::visibility_rec* release_visibility_rec();
  ::ce::nbapi::visibility_rec* mutable_visibility_rec();
  void set_allocated_visibility_rec(::ce::nbapi::visibility_rec* visibility_rec);

  // optional .ce.nbapi.campus campus = 511;
  bool has_campus() const;
  void clear_campus();
  static const int kCampusFieldNumber = 511;
  private:
  const ::ce::nbapi::campus& _internal_campus() const;
  public:
  const ::ce::nbapi::campus& campus() const;
  ::ce::nbapi::campus* release_campus();
  ::ce::nbapi::campus* mutable_campus();
  void set_allocated_campus(::ce::nbapi::campus* campus);

  // optional .ce.nbapi.building building = 512;
  bool has_building() const;
  void clear_building();
  static const int kBuildingFieldNumber = 512;
  private:
  const ::ce::nbapi::building& _internal_building() const;
  public:
  const ::ce::nbapi::building& building() const;
  ::ce::nbapi::building* release_building();
  ::ce::nbapi::building* mutable_building();
  void set_allocated_building(::ce::nbapi::building* building);

  // optional .ce.nbapi.floor floor = 513;
  bool has_floor() const;
  void clear_floor();
  static const int kFloorFieldNumber = 513;
  private:
  const ::ce::nbapi::floor& _internal_floor() const;
  public:
  const ::ce::nbapi::floor& floor() const;
  ::ce::nbapi::floor* release_floor();
  ::ce::nbapi::floor* mutable_floor();
  void set_allocated_floor(::ce::nbapi::floor* floor);

  // optional .ce.nbapi.access_point access_point = 514;
  bool has_access_point() const;
  void clear_access_point();
  static const int kAccessPointFieldNumber = 514;
  private:
  const ::ce::nbapi::access_point& _internal_access_point() const;
  public:
  const ::ce::nbapi::access_point& access_point() const;
  ::ce::nbapi::access_point* release_access_point();
  ::ce::nbapi::access_point* mutable_access_point();
  void set_allocated_access_point(::ce::nbapi::access_point* access_point);

  // optional .ce.nbapi.virtual_access_point virtual_access_point = 515;
  bool has_virtual_access_point() const;
  void clear_virtual_access_point();
  static const int kVirtualAccessPointFieldNumber = 515;
  private:
  const ::ce::nbapi::virtual_access_point& _internal_virtual_access_point() const;
  public:
  const ::ce::nbapi::virtual_access_point& virtual_access_point() const;
  ::ce::nbapi::virtual_access_point* release_virtual_access_point();
  ::ce::nbapi::virtual_access_point* mutable_virtual_access_point();
  void set_allocated_virtual_access_point(::ce::nbapi::virtual_access_point* virtual_access_point);

  // optional .ce.nbapi.geofence geofence = 516;
  bool has_geofence() const;
  void clear_geofence();
  static const int kGeofenceFieldNumber = 516;
  private:
  const ::ce::nbapi::geofence& _internal_geofence() const;
  public:
  const ::ce::nbapi::geofence& geofence() const;
  ::ce::nbapi::geofence* release_geofence();
  ::ce::nbapi::geofence* mutable_geofence();
  void set_allocated_geofence(::ce::nbapi::geofence* geofence);

  // optional .ce.nbapi.geofence_notify geofence_notify = 517;
  bool has_geofence_notify() const;
  void clear_geofence_notify();
  static const int kGeofenceNotifyFieldNumber = 517;
  private:
  const ::ce::nbapi::geofence_notify& _internal_geofence_notify() const;
  public:
  const ::ce::nbapi::geofence_notify& geofence_notify() const;
  ::ce::nbapi::geofence_notify* release_geofence_notify();
  ::ce::nbapi::geofence_notify* mutable_geofence_notify();
  void set_allocated_geofence_notify(::ce::nbapi::geofence_notify* geofence_notify);

  // optional .ce.nbapi.stats_radio stats_radio = 518;
  bool has_stats_radio() const;
  void clear_stats_radio();
  static const int kStatsRadioFieldNumber = 518;
  private:
  const ::ce::nbapi::stats_radio& _internal_stats_radio() const;
  public:
  const ::ce::nbapi::stats_radio& stats_radio() const;
  ::ce::nbapi::stats_radio* release_stats_radio();
  ::ce::nbapi::stats_radio* mutable_stats_radio();
  void set_allocated_stats_radio(::ce::nbapi::stats_radio* stats_radio);

  // optional .ce.nbapi.stats_vap stats_vap = 519;
  bool has_stats_vap() const;
  void clear_stats_vap();
  static const int kStatsVapFieldNumber = 519;
  private:
  const ::ce::nbapi::stats_vap& _internal_stats_vap() const;
  public:
  const ::ce::nbapi::stats_vap& stats_vap() const;
  ::ce::nbapi::stats_vap* release_stats_vap();
  ::ce::nbapi::stats_vap* mutable_stats_vap();
  void set_allocated_stats_vap(::ce::nbapi::stats_vap* stats_vap);

  // optional .ce.nbapi.stats_station stats_station = 520;
  bool has_stats_station() const;
  void clear_stats_station();
  static const int kStatsStationFieldNumber = 520;
  private:
  const ::ce::nbapi::stats_station& _internal_stats_station() const;
  public:
  const ::ce::nbapi::stats_station& stats_station() const;
  ::ce::nbapi::stats_station* release_stats_station();
  ::ce::nbapi::stats_station* mutable_stats_station();
  void set_allocated_stats_station(::ce::nbapi::stats_station* stats_station);

  // optional .ce.nbapi.ap_neighbor_list ap_neighbor_list = 521;
  bool has_ap_neighbor_list() const;
  void clear_ap_neighbor_list();
  static const int kApNeighborListFieldNumber = 521;
  private:
  const ::ce::nbapi::ap_neighbor_list& _internal_ap_neighbor_list() const;
  public:
  const ::ce::nbapi::ap_neighbor_list& ap_neighbor_list() const;
  ::ce::nbapi::ap_neighbor_list* release_ap_neighbor_list();
  ::ce::nbapi::ap_neighbor_list* mutable_ap_neighbor_list();
  void set_allocated_ap_neighbor_list(::ce::nbapi::ap_neighbor_list* ap_neighbor_list);

  // optional .ce.nbapi.utilization_stats_radio utilization_stats_radio = 522;
  bool has_utilization_stats_radio() const;
  void clear_utilization_stats_radio();
  static const int kUtilizationStatsRadioFieldNumber = 522;
  private:
  const ::ce::nbapi::utilization_stats_radio& _internal_utilization_stats_radio() const;
  public:
  const ::ce::nbapi::utilization_stats_radio& utilization_stats_radio() const;
  ::ce::nbapi::utilization_stats_radio* release_utilization_stats_radio();
  ::ce::nbapi::utilization_stats_radio* mutable_utilization_stats_radio();
  void set_allocated_utilization_stats_radio(::ce::nbapi::utilization_stats_radio* utilization_stats_radio);

  // optional .ce.nbapi.sta_rssi sta_rssi = 523;
  bool has_sta_rssi() const;
  void clear_sta_rssi();
  static const int kStaRssiFieldNumber = 523;
  private:
  const ::ce::nbapi::sta_rssi& _internal_sta_rssi() const;
  public:
  const ::ce::nbapi::sta_rssi& sta_rssi() const;
  ::ce::nbapi::sta_rssi* release_sta_rssi();
  ::ce::nbapi::sta_rssi* mutable_sta_rssi();
  void set_allocated_sta_rssi(::ce::nbapi::sta_rssi* sta_rssi);

  // optional .ce.nbapi.ap_rssi ap_rssi = 524;
  bool has_ap_rssi() const;
  void clear_ap_rssi();
  static const int kApRssiFieldNumber = 524;
  private:
  const ::ce::nbapi::ap_rssi& _internal_ap_rssi() const;
  public:
  const ::ce::nbapi::ap_rssi& ap_rssi() const;
  ::ce::nbapi::ap_rssi* release_ap_rssi();
  ::ce::nbapi::ap_rssi* mutable_ap_rssi();
  void set_allocated_ap_rssi(::ce::nbapi::ap_rssi* ap_rssi);

  // optional .ce.nbapi.proximity proximity = 525;
  bool has_proximity() const;
  void clear_proximity();
  static const int kProximityFieldNumber = 525;
  private:
  const ::ce::nbapi::proximity& _internal_proximity() const;
  public:
  const ::ce::nbapi::proximity& proximity() const;
  ::ce::nbapi::proximity* release_proximity();
  ::ce::nbapi::proximity* mutable_proximity();
  void set_allocated_proximity(::ce::nbapi::proximity* proximity);

  // optional .ce.nbapi.webcc_category webcc_category = 526;
  bool has_webcc_category() const;
  void clear_webcc_category();
  static const int kWebccCategoryFieldNumber = 526;
  private:
  const ::ce::nbapi::webcc_category& _internal_webcc_category() const;
  public:
  const ::ce::nbapi::webcc_category& webcc_category() const;
  ::ce::nbapi::webcc_category* release_webcc_category();
  ::ce::nbapi::webcc_category* mutable_webcc_category();
  void set_allocated_webcc_category(::ce::nbapi::webcc_category* webcc_category);

  // optional .ce.nbapi.webcc_info webcc_info = 527;
  bool has_webcc_info() const;
  void clear_webcc_info();
  static const int kWebccInfoFieldNumber = 527;
  private:
  const ::ce::nbapi::webcc_info& _internal_webcc_info() const;
  public:
  const ::ce::nbapi::webcc_info& webcc_info() const;
  ::ce::nbapi::webcc_info* release_webcc_info();
  ::ce::nbapi::webcc_info* mutable_webcc_info();
  void set_allocated_webcc_info(::ce::nbapi::webcc_info* webcc_info);

  // optional .ce.nbapi.security_message security_message = 528;
  bool has_security_message() const;
  void clear_security_message();
  static const int kSecurityMessageFieldNumber = 528;
  private:
  const ::ce::nbapi::security_message& _internal_security_message() const;
  public:
  const ::ce::nbapi::security_message& security_message() const;
  ::ce::nbapi::security_message* release_security_message();
  ::ce::nbapi::security_message* mutable_security_message();
  void set_allocated_security_message(::ce::nbapi::security_message* security_message);

  // optional .ce.nbapi.spectrum_info spectrum_info = 529;
  bool has_spectrum_info() const;
  void clear_spectrum_info();
  static const int kSpectrumInfoFieldNumber = 529;
  private:
  const ::ce::nbapi::spectrum_info& _internal_spectrum_info() const;
  public:
  const ::ce::nbapi::spectrum_info& spectrum_info() const;
  ::ce::nbapi::spectrum_info* release_spectrum_info();
  ::ce::nbapi::spectrum_info* mutable_spectrum_info();
  void set_allocated_spectrum_info(::ce::nbapi::spectrum_info* spectrum_info);

  // optional .ce.nbapi.state_station state_station = 530;
  bool has_state_station() const;
  void clear_state_station();
  static const int kStateStationFieldNumber = 530;
  private:
  const ::ce::nbapi::state_station& _internal_state_station() const;
  public:
  const ::ce::nbapi::state_station& state_station() const;
  ::ce::nbapi::state_station* release_state_station();
  ::ce::nbapi::state_station* mutable_state_station();
  void set_allocated_state_station(::ce::nbapi::state_station* state_station);

  // optional .ce.nbapi.controller_info controller = 531;
  bool has_controller() const;
  void clear_controller();
  static const int kControllerFieldNumber = 531;
  private:
  const ::ce::nbapi::controller_info& _internal_controller() const;
  public:
  const ::ce::nbapi::controller_info& controller() const;
  ::ce::nbapi::controller_info* release_controller();
  ::ce::nbapi::controller_info* mutable_controller();
  void set_allocated_controller(::ce::nbapi::controller_info* controller);

  // optional .ce.nbapi.cluster_info cluster = 532;
  bool has_cluster() const;
  void clear_cluster();
  static const int kClusterFieldNumber = 532;
  private:
  const ::ce::nbapi::cluster_info& _internal_cluster() const;
  public:
  const ::ce::nbapi::cluster_info& cluster() const;
  ::ce::nbapi::cluster_info* release_cluster();
  ::ce::nbapi::cluster_info* mutable_cluster();
  void set_allocated_cluster(::ce::nbapi::cluster_info* cluster);

  // optional .ce.nbapi.uplink_bandwidth uplink_bandwidth = 533;
  bool has_uplink_bandwidth() const;
  void clear_uplink_bandwidth();
  static const int kUplinkBandwidthFieldNumber = 533;
  private:
  const ::ce::nbapi::uplink_bandwidth& _internal_uplink_bandwidth() const;
  public:
  const ::ce::nbapi::uplink_bandwidth& uplink_bandwidth() const;
  ::ce::nbapi::uplink_bandwidth* release_uplink_bandwidth();
  ::ce::nbapi::uplink_bandwidth* mutable_uplink_bandwidth();
  void set_allocated_uplink_bandwidth(::ce::nbapi::uplink_bandwidth* uplink_bandwidth);

  // optional .ce.nbapi.iap_client_url iapClientURL = 544;
  bool has_iapclienturl() const;
  void clear_iapclienturl();
  static const int kIapClientURLFieldNumber = 544;
  private:
  const ::ce::nbapi::iap_client_url& _internal_iapclienturl() const;
  public:
  const ::ce::nbapi::iap_client_url& iapclienturl() const;
  ::ce::nbapi::iap_client_url* release_iapclienturl();
  ::ce::nbapi::iap_client_url* mutable_iapclienturl();
  void set_allocated_iapclienturl(::ce::nbapi::iap_client_url* iapclienturl);

  // optional .ce.nbapi.rogue_info rogue_info = 545;
  bool has_rogue_info() const;
  void clear_rogue_info();
  static const int kRogueInfoFieldNumber = 545;
  private:
  const ::ce::nbapi::rogue_info& _internal_rogue_info() const;
  public:
  const ::ce::nbapi::rogue_info& rogue_info() const;
  ::ce::nbapi::rogue_info* release_rogue_info();
  ::ce::nbapi::rogue_info* mutable_rogue_info();
  void set_allocated_rogue_info(::ce::nbapi::rogue_info* rogue_info);

  // optional .ce.nbapi.air_monitor_info air_mon_info = 546;
  bool has_air_mon_info() const;
  void clear_air_mon_info();
  static const int kAirMonInfoFieldNumber = 546;
  private:
  const ::ce::nbapi::air_monitor_info& _internal_air_mon_info() const;
  public:
  const ::ce::nbapi::air_monitor_info& air_mon_info() const;
  ::ce::nbapi::air_monitor_info* release_air_mon_info();
  ::ce::nbapi::air_monitor_info* mutable_air_mon_info();
  void set_allocated_air_mon_info(::ce::nbapi::air_monitor_info* air_mon_info);

  // optional .ce.nbapi.ap_location ap_location = 547;
  bool has_ap_location() const;
  void clear_ap_location();
  static const int kApLocationFieldNumber = 547;
  private:
  const ::ce::nbapi::ap_location& _internal_ap_location() const;
  public:
  const ::ce::nbapi::ap_location& ap_location() const;
  ::ce::nbapi::ap_location* release_ap_location();
  ::ce::nbapi::ap_location* mutable_ap_location();
  void set_allocated_ap_location(::ce::nbapi::ap_location* ap_location);

  // optional .ce.nbapi.state_access_point state_access_point = 548;
  bool has_state_access_point() const;
  void clear_state_access_point();
  static const int kStateAccessPointFieldNumber = 548;
  private:
  const ::ce::nbapi::state_access_point& _internal_state_access_point() const;
  public:
  const ::ce::nbapi::state_access_point& state_access_point() const;
  ::ce::nbapi::state_access_point* release_state_access_point();
  ::ce::nbapi::state_access_point* mutable_state_access_point();
  void set_allocated_state_access_point(::ce::nbapi::state_access_point* state_access_point);

  // optional .ce.nbapi.stats_modem stats_modem = 549;
  bool has_stats_modem() const;
  void clear_stats_modem();
  static const int kStatsModemFieldNumber = 549;
  private:
  const ::ce::nbapi::stats_modem& _internal_stats_modem() const;
  public:
  const ::ce::nbapi::stats_modem& stats_modem() const;
  ::ce::nbapi::stats_modem* release_stats_modem();
  ::ce::nbapi::stats_modem* mutable_stats_modem();
  void set_allocated_stats_modem(::ce::nbapi::stats_modem* stats_modem);

  // optional .ce.nbapi.uplink_info uplink_info = 550;
  bool has_uplink_info() const;
  void clear_uplink_info();
  static const int kUplinkInfoFieldNumber = 550;
  private:
  const ::ce::nbapi::uplink_info& _internal_uplink_info() const;
  public:
  const ::ce::nbapi::uplink_info& uplink_info() const;
  ::ce::nbapi::uplink_info* release_uplink_info();
  ::ce::nbapi::uplink_info* mutable_uplink_info();
  void set_allocated_uplink_info(::ce::nbapi::uplink_info* uplink_info);

  // optional .ce.nbapi.stats_uplink stats_uplink = 551;
  bool has_stats_uplink() const;
  void clear_stats_uplink();
  static const int kStatsUplinkFieldNumber = 551;
  private:
  const ::ce::nbapi::stats_uplink& _internal_stats_uplink() const;
  public:
  const ::ce::nbapi::stats_uplink& stats_uplink() const;
  ::ce::nbapi::stats_uplink* release_stats_uplink();
  ::ce::nbapi::stats_uplink* mutable_stats_uplink();
  void set_allocated_stats_uplink(::ce::nbapi::stats_uplink* stats_uplink);

  // optional .ce.nbapi.wan_comp_uplink wan_comp_uplink = 552;
  bool has_wan_comp_uplink() const;
  void clear_wan_comp_uplink();
  static const int kWanCompUplinkFieldNumber = 552;
  private:
  const ::ce::nbapi::wan_comp_uplink& _internal_wan_comp_uplink() const;
  public:
  const ::ce::nbapi::wan_comp_uplink& wan_comp_uplink() const;
  ::ce::nbapi::wan_comp_uplink* release_wan_comp_uplink();
  ::ce::nbapi::wan_comp_uplink* mutable_wan_comp_uplink();
  void set_allocated_wan_comp_uplink(::ce::nbapi::wan_comp_uplink* wan_comp_uplink);

  // optional .ce.nbapi.stats_ip_probe_uplink stats_ip_probe_uplink = 553;
  bool has_stats_ip_probe_uplink() const;
  void clear_stats_ip_probe_uplink();
  static const int kStatsIpProbeUplinkFieldNumber = 553;
  private:
  const ::ce::nbapi::stats_ip_probe_uplink& _internal_stats_ip_probe_uplink() const;
  public:
  const ::ce::nbapi::stats_ip_probe_uplink& stats_ip_probe_uplink() const;
  ::ce::nbapi::stats_ip_probe_uplink* release_stats_ip_probe_uplink();
  ::ce::nbapi::stats_ip_probe_uplink* mutable_stats_ip_probe_uplink();
  void set_allocated_stats_ip_probe_uplink(::ce::nbapi::stats_ip_probe_uplink* stats_ip_probe_uplink);

  // optional .ce.nbapi.summary_webcat_iap summary_webcat = 554;
  bool has_summary_webcat() const;
  void clear_summary_webcat();
  static const int kSummaryWebcatFieldNumber = 554;
  private:
  const ::ce::nbapi::summary_webcat_iap& _internal_summary_webcat() const;
  public:
  const ::ce::nbapi::summary_webcat_iap& summary_webcat() const;
  ::ce::nbapi::summary_webcat_iap* release_summary_webcat();
  ::ce::nbapi::summary_webcat_iap* mutable_summary_webcat();
  void set_allocated_summary_webcat(::ce::nbapi::summary_webcat_iap* summary_webcat);

  // optional .ce.nbapi.summary_appid_iap summary_appid = 555;
  bool has_summary_appid() const;
  void clear_summary_appid();
  static const int kSummaryAppidFieldNumber = 555;
  private:
  const ::ce::nbapi::summary_appid_iap& _internal_summary_appid() const;
  public:
  const ::ce::nbapi::summary_appid_iap& summary_appid() const;
  ::ce::nbapi::summary_appid_iap* release_summary_appid();
  ::ce::nbapi::summary_appid_iap* mutable_summary_appid();
  void set_allocated_summary_appid(::ce::nbapi::summary_appid_iap* summary_appid);

  // optional .ce.nbapi.summary_webrep_iap summary_webrep = 556;
  bool has_summary_webrep() const;
  void clear_summary_webrep();
  static const int kSummaryWebrepFieldNumber = 556;
  private:
  const ::ce::nbapi::summary_webrep_iap& _internal_summary_webrep() const;
  public:
  const ::ce::nbapi::summary_webrep_iap& summary_webrep() const;
  ::ce::nbapi::summary_webrep_iap* release_summary_webrep();
  ::ce::nbapi::summary_webrep_iap* mutable_summary_webrep();
  void set_allocated_summary_webrep(::ce::nbapi::summary_webrep_iap* summary_webrep);

  // optional .ce.nbapi.stats_role_iap stats_role = 557;
  bool has_stats_role() const;
  void clear_stats_role();
  static const int kStatsRoleFieldNumber = 557;
  private:
  const ::ce::nbapi::stats_role_iap& _internal_stats_role() const;
  public:
  const ::ce::nbapi::stats_role_iap& stats_role() const;
  ::ce::nbapi::stats_role_iap* release_stats_role();
  ::ce::nbapi::stats_role_iap* mutable_stats_role();
  void set_allocated_stats_role(::ce::nbapi::stats_role_iap* stats_role);

  // optional .ce.nbapi.stats_vlan_iap stats_vlan = 558;
  bool has_stats_vlan() const;
  void clear_stats_vlan();
  static const int kStatsVlanFieldNumber = 558;
  private:
  const ::ce::nbapi::stats_vlan_iap& _internal_stats_vlan() const;
  public:
  const ::ce::nbapi::stats_vlan_iap& stats_vlan() const;
  ::ce::nbapi::stats_vlan_iap* release_stats_vlan();
  ::ce::nbapi::stats_vlan_iap* mutable_stats_vlan();
  void set_allocated_stats_vlan(::ce::nbapi::stats_vlan_iap* stats_vlan);

  // optional .ce.nbapi.stats_ssid_iap stats_ssid = 559;
  bool has_stats_ssid() const;
  void clear_stats_ssid();
  static const int kStatsSsidFieldNumber = 559;
  private:
  const ::ce::nbapi::stats_ssid_iap& _internal_stats_ssid() const;
  public:
  const ::ce::nbapi::stats_ssid_iap& stats_ssid() const;
  ::ce::nbapi::stats_ssid_iap* release_stats_ssid();
  ::ce::nbapi::stats_ssid_iap* mutable_stats_ssid();
  void set_allocated_stats_ssid(::ce::nbapi::stats_ssid_iap* stats_ssid);

  // optional .ce.nbapi.tag_rssi tag_rssi = 560;
  bool has_tag_rssi() const;
  void clear_tag_rssi();
  static const int kTagRssiFieldNumber = 560;
  private:
  const ::ce::nbapi::tag_rssi& _internal_tag_rssi() const;
  public:
  const ::ce::nbapi::tag_rssi& tag_rssi() const;
  ::ce::nbapi::tag_rssi* release_tag_rssi();
  ::ce::nbapi::tag_rssi* mutable_tag_rssi();
  void set_allocated_tag_rssi(::ce::nbapi::tag_rssi* tag_rssi);

  // optional uint64 seq = 1;
  bool has_seq() const;
  void clear_seq();
  static const int kSeqFieldNumber = 1;
  ::google::protobuf::uint64 seq() const;
  void set_seq(::google::protobuf::uint64 value);

  // optional uint32 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // optional .ce.nbapi.nb_event.event_operation op = 3;
  bool has_op() const;
  void clear_op();
  static const int kOpFieldNumber = 3;
  ::ce::nbapi::nb_event_event_operation op() const;
  void set_op(::ce::nbapi::nb_event_event_operation value);

  // optional uint64 topic_seq = 4;
  bool has_topic_seq() const;
  void clear_topic_seq();
  static const int kTopicSeqFieldNumber = 4;
  ::google::protobuf::uint64 topic_seq() const;
  void set_topic_seq(::google::protobuf::uint64 value);

  // optional .ce.nbapi.nb_event.license_info lic_info = 6 [default = hb_Dhak];
  bool has_lic_info() const;
  void clear_lic_info();
  static const int kLicInfoFieldNumber = 6;
  ::ce::nbapi::nb_event_license_info lic_info() const;
  void set_lic_info(::ce::nbapi::nb_event_license_info value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.nb_event)
 private:
  void set_has_seq();
  void clear_has_seq();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_op();
  void clear_has_op();
  void set_has_topic_seq();
  void clear_has_topic_seq();
  void set_has_source_id();
  void clear_has_source_id();
  void set_has_lic_info();
  void clear_has_lic_info();
  void set_has_location();
  void clear_has_location();
  void set_has_presence();
  void clear_has_presence();
  void set_has_rssi();
  void clear_has_rssi();
  void set_has_station();
  void clear_has_station();
  void set_has_radio();
  void clear_has_radio();
  void set_has_destination();
  void clear_has_destination();
  void set_has_application();
  void clear_has_application();
  void set_has_visibility_rec();
  void clear_has_visibility_rec();
  void set_has_campus();
  void clear_has_campus();
  void set_has_building();
  void clear_has_building();
  void set_has_floor();
  void clear_has_floor();
  void set_has_access_point();
  void clear_has_access_point();
  void set_has_virtual_access_point();
  void clear_has_virtual_access_point();
  void set_has_geofence();
  void clear_has_geofence();
  void set_has_geofence_notify();
  void clear_has_geofence_notify();
  void set_has_stats_radio();
  void clear_has_stats_radio();
  void set_has_stats_vap();
  void clear_has_stats_vap();
  void set_has_stats_station();
  void clear_has_stats_station();
  void set_has_ap_neighbor_list();
  void clear_has_ap_neighbor_list();
  void set_has_utilization_stats_radio();
  void clear_has_utilization_stats_radio();
  void set_has_sta_rssi();
  void clear_has_sta_rssi();
  void set_has_ap_rssi();
  void clear_has_ap_rssi();
  void set_has_proximity();
  void clear_has_proximity();
  void set_has_webcc_category();
  void clear_has_webcc_category();
  void set_has_webcc_info();
  void clear_has_webcc_info();
  void set_has_security_message();
  void clear_has_security_message();
  void set_has_spectrum_info();
  void clear_has_spectrum_info();
  void set_has_state_station();
  void clear_has_state_station();
  void set_has_controller();
  void clear_has_controller();
  void set_has_cluster();
  void clear_has_cluster();
  void set_has_uplink_bandwidth();
  void clear_has_uplink_bandwidth();
  void set_has_iapclienturl();
  void clear_has_iapclienturl();
  void set_has_rogue_info();
  void clear_has_rogue_info();
  void set_has_air_mon_info();
  void clear_has_air_mon_info();
  void set_has_ap_location();
  void clear_has_ap_location();
  void set_has_state_access_point();
  void clear_has_state_access_point();
  void set_has_stats_modem();
  void clear_has_stats_modem();
  void set_has_uplink_info();
  void clear_has_uplink_info();
  void set_has_stats_uplink();
  void clear_has_stats_uplink();
  void set_has_wan_comp_uplink();
  void clear_has_wan_comp_uplink();
  void set_has_stats_ip_probe_uplink();
  void clear_has_stats_ip_probe_uplink();
  void set_has_summary_webcat();
  void clear_has_summary_webcat();
  void set_has_summary_appid();
  void clear_has_summary_appid();
  void set_has_summary_webrep();
  void clear_has_summary_webrep();
  void set_has_stats_role();
  void clear_has_stats_role();
  void set_has_stats_vlan();
  void clear_has_stats_vlan();
  void set_has_stats_ssid();
  void clear_has_stats_ssid();
  void set_has_tag_rssi();
  void clear_has_tag_rssi();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<2> _has_bits_;
  ::google::protobuf::internal::ArenaStringPtr source_id_;
  ::ce::nbapi::location* location_;
  ::ce::nbapi::presence* presence_;
  ::ce::nbapi::rssi* rssi_;
  ::ce::nbapi::station* station_;
  ::ce::nbapi::radio* radio_;
  ::ce::nbapi::destination* destination_;
  ::ce::nbapi::application* application_;
  ::ce::nbapi::visibility_rec* visibility_rec_;
  ::ce::nbapi::campus* campus_;
  ::ce::nbapi::building* building_;
  ::ce::nbapi::floor* floor_;
  ::ce::nbapi::access_point* access_point_;
  ::ce::nbapi::virtual_access_point* virtual_access_point_;
  ::ce::nbapi::geofence* geofence_;
  ::ce::nbapi::geofence_notify* geofence_notify_;
  ::ce::nbapi::stats_radio* stats_radio_;
  ::ce::nbapi::stats_vap* stats_vap_;
  ::ce::nbapi::stats_station* stats_station_;
  ::ce::nbapi::ap_neighbor_list* ap_neighbor_list_;
  ::ce::nbapi::utilization_stats_radio* utilization_stats_radio_;
  ::ce::nbapi::sta_rssi* sta_rssi_;
  ::ce::nbapi::ap_rssi* ap_rssi_;
  ::ce::nbapi::proximity* proximity_;
  ::ce::nbapi::webcc_category* webcc_category_;
  ::ce::nbapi::webcc_info* webcc_info_;
  ::ce::nbapi::security_message* security_message_;
  ::ce::nbapi::spectrum_info* spectrum_info_;
  ::ce::nbapi::state_station* state_station_;
  ::ce::nbapi::controller_info* controller_;
  ::ce::nbapi::cluster_info* cluster_;
  ::ce::nbapi::uplink_bandwidth* uplink_bandwidth_;
  ::ce::nbapi::iap_client_url* iapclienturl_;
  ::ce::nbapi::rogue_info* rogue_info_;
  ::ce::nbapi::air_monitor_info* air_mon_info_;
  ::ce::nbapi::ap_location* ap_location_;
  ::ce::nbapi::state_access_point* state_access_point_;
  ::ce::nbapi::stats_modem* stats_modem_;
  ::ce::nbapi::uplink_info* uplink_info_;
  ::ce::nbapi::stats_uplink* stats_uplink_;
  ::ce::nbapi::wan_comp_uplink* wan_comp_uplink_;
  ::ce::nbapi::stats_ip_probe_uplink* stats_ip_probe_uplink_;
  ::ce::nbapi::summary_webcat_iap* summary_webcat_;
  ::ce::nbapi::summary_appid_iap* summary_appid_;
  ::ce::nbapi::summary_webrep_iap* summary_webrep_;
  ::ce::nbapi::stats_role_iap* stats_role_;
  ::ce::nbapi::stats_vlan_iap* stats_vlan_;
  ::ce::nbapi::stats_ssid_iap* stats_ssid_;
  ::ce::nbapi::tag_rssi* tag_rssi_;
  ::google::protobuf::uint64 seq_;
  ::google::protobuf::uint32 timestamp_;
  int op_;
  ::google::protobuf::uint64 topic_seq_;
  int lic_info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Location_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Location_result) */ {
 public:
  query_response_Location_result();
  virtual ~query_response_Location_result();

  query_response_Location_result(const query_response_Location_result& from);

  inline query_response_Location_result& operator=(const query_response_Location_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Location_result(query_response_Location_result&& from) noexcept
    : query_response_Location_result() {
    *this = ::std::move(from);
  }

  inline query_response_Location_result& operator=(query_response_Location_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Location_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Location_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Location_result*>(
               &_query_response_Location_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  void Swap(query_response_Location_result* other);
  friend void swap(query_response_Location_result& a, query_response_Location_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Location_result* New() const final {
    return CreateMaybeMessage<query_response_Location_result>(NULL);
  }

  query_response_Location_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Location_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Location_result& from);
  void MergeFrom(const query_response_Location_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Location_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.location msg = 11;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 11;
  private:
  const ::ce::nbapi::location& _internal_msg() const;
  public:
  const ::ce::nbapi::location& msg() const;
  ::ce::nbapi::location* release_msg();
  ::ce::nbapi::location* mutable_msg();
  void set_allocated_msg(::ce::nbapi::location* msg);

  // optional uint32 ts = 12;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 12;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Location_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::location* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Presence_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Presence_result) */ {
 public:
  query_response_Presence_result();
  virtual ~query_response_Presence_result();

  query_response_Presence_result(const query_response_Presence_result& from);

  inline query_response_Presence_result& operator=(const query_response_Presence_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Presence_result(query_response_Presence_result&& from) noexcept
    : query_response_Presence_result() {
    *this = ::std::move(from);
  }

  inline query_response_Presence_result& operator=(query_response_Presence_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Presence_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Presence_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Presence_result*>(
               &_query_response_Presence_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  void Swap(query_response_Presence_result* other);
  friend void swap(query_response_Presence_result& a, query_response_Presence_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Presence_result* New() const final {
    return CreateMaybeMessage<query_response_Presence_result>(NULL);
  }

  query_response_Presence_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Presence_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Presence_result& from);
  void MergeFrom(const query_response_Presence_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Presence_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.presence msg = 21;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 21;
  private:
  const ::ce::nbapi::presence& _internal_msg() const;
  public:
  const ::ce::nbapi::presence& msg() const;
  ::ce::nbapi::presence* release_msg();
  ::ce::nbapi::presence* mutable_msg();
  void set_allocated_msg(::ce::nbapi::presence* msg);

  // optional uint32 ts = 22;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 22;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Presence_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::presence* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Rssi_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Rssi_result) */ {
 public:
  query_response_Rssi_result();
  virtual ~query_response_Rssi_result();

  query_response_Rssi_result(const query_response_Rssi_result& from);

  inline query_response_Rssi_result& operator=(const query_response_Rssi_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Rssi_result(query_response_Rssi_result&& from) noexcept
    : query_response_Rssi_result() {
    *this = ::std::move(from);
  }

  inline query_response_Rssi_result& operator=(query_response_Rssi_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Rssi_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Rssi_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Rssi_result*>(
               &_query_response_Rssi_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  void Swap(query_response_Rssi_result* other);
  friend void swap(query_response_Rssi_result& a, query_response_Rssi_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Rssi_result* New() const final {
    return CreateMaybeMessage<query_response_Rssi_result>(NULL);
  }

  query_response_Rssi_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Rssi_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Rssi_result& from);
  void MergeFrom(const query_response_Rssi_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Rssi_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.rssi msg = 31;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 31;
  private:
  const ::ce::nbapi::rssi& _internal_msg() const;
  public:
  const ::ce::nbapi::rssi& msg() const;
  ::ce::nbapi::rssi* release_msg();
  ::ce::nbapi::rssi* mutable_msg();
  void set_allocated_msg(::ce::nbapi::rssi* msg);

  // optional uint32 ts = 32;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 32;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Rssi_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::rssi* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Station_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Station_result) */ {
 public:
  query_response_Station_result();
  virtual ~query_response_Station_result();

  query_response_Station_result(const query_response_Station_result& from);

  inline query_response_Station_result& operator=(const query_response_Station_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Station_result(query_response_Station_result&& from) noexcept
    : query_response_Station_result() {
    *this = ::std::move(from);
  }

  inline query_response_Station_result& operator=(query_response_Station_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Station_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Station_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Station_result*>(
               &_query_response_Station_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  void Swap(query_response_Station_result* other);
  friend void swap(query_response_Station_result& a, query_response_Station_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Station_result* New() const final {
    return CreateMaybeMessage<query_response_Station_result>(NULL);
  }

  query_response_Station_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Station_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Station_result& from);
  void MergeFrom(const query_response_Station_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Station_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.station msg = 41;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 41;
  private:
  const ::ce::nbapi::station& _internal_msg() const;
  public:
  const ::ce::nbapi::station& msg() const;
  ::ce::nbapi::station* release_msg();
  ::ce::nbapi::station* mutable_msg();
  void set_allocated_msg(::ce::nbapi::station* msg);

  // optional uint32 ts = 42;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 42;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Station_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::station* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Radio_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Radio_result) */ {
 public:
  query_response_Radio_result();
  virtual ~query_response_Radio_result();

  query_response_Radio_result(const query_response_Radio_result& from);

  inline query_response_Radio_result& operator=(const query_response_Radio_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Radio_result(query_response_Radio_result&& from) noexcept
    : query_response_Radio_result() {
    *this = ::std::move(from);
  }

  inline query_response_Radio_result& operator=(query_response_Radio_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Radio_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Radio_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Radio_result*>(
               &_query_response_Radio_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  void Swap(query_response_Radio_result* other);
  friend void swap(query_response_Radio_result& a, query_response_Radio_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Radio_result* New() const final {
    return CreateMaybeMessage<query_response_Radio_result>(NULL);
  }

  query_response_Radio_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Radio_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Radio_result& from);
  void MergeFrom(const query_response_Radio_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Radio_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.radio msg = 51;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 51;
  private:
  const ::ce::nbapi::radio& _internal_msg() const;
  public:
  const ::ce::nbapi::radio& msg() const;
  ::ce::nbapi::radio* release_msg();
  ::ce::nbapi::radio* mutable_msg();
  void set_allocated_msg(::ce::nbapi::radio* msg);

  // optional uint32 ts = 52;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 52;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Radio_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::radio* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Destination_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Destination_result) */ {
 public:
  query_response_Destination_result();
  virtual ~query_response_Destination_result();

  query_response_Destination_result(const query_response_Destination_result& from);

  inline query_response_Destination_result& operator=(const query_response_Destination_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Destination_result(query_response_Destination_result&& from) noexcept
    : query_response_Destination_result() {
    *this = ::std::move(from);
  }

  inline query_response_Destination_result& operator=(query_response_Destination_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Destination_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Destination_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Destination_result*>(
               &_query_response_Destination_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  void Swap(query_response_Destination_result* other);
  friend void swap(query_response_Destination_result& a, query_response_Destination_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Destination_result* New() const final {
    return CreateMaybeMessage<query_response_Destination_result>(NULL);
  }

  query_response_Destination_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Destination_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Destination_result& from);
  void MergeFrom(const query_response_Destination_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Destination_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.destination msg = 61;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 61;
  private:
  const ::ce::nbapi::destination& _internal_msg() const;
  public:
  const ::ce::nbapi::destination& msg() const;
  ::ce::nbapi::destination* release_msg();
  ::ce::nbapi::destination* mutable_msg();
  void set_allocated_msg(::ce::nbapi::destination* msg);

  // optional uint32 ts = 62;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 62;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Destination_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::destination* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Application_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Application_result) */ {
 public:
  query_response_Application_result();
  virtual ~query_response_Application_result();

  query_response_Application_result(const query_response_Application_result& from);

  inline query_response_Application_result& operator=(const query_response_Application_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Application_result(query_response_Application_result&& from) noexcept
    : query_response_Application_result() {
    *this = ::std::move(from);
  }

  inline query_response_Application_result& operator=(query_response_Application_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Application_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Application_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Application_result*>(
               &_query_response_Application_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  void Swap(query_response_Application_result* other);
  friend void swap(query_response_Application_result& a, query_response_Application_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Application_result* New() const final {
    return CreateMaybeMessage<query_response_Application_result>(NULL);
  }

  query_response_Application_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Application_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Application_result& from);
  void MergeFrom(const query_response_Application_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Application_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.application msg = 71;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 71;
  private:
  const ::ce::nbapi::application& _internal_msg() const;
  public:
  const ::ce::nbapi::application& msg() const;
  ::ce::nbapi::application* release_msg();
  ::ce::nbapi::application* mutable_msg();
  void set_allocated_msg(::ce::nbapi::application* msg);

  // optional uint32 ts = 72;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 72;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Application_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::application* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Visibility_rec_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Visibility_rec_result) */ {
 public:
  query_response_Visibility_rec_result();
  virtual ~query_response_Visibility_rec_result();

  query_response_Visibility_rec_result(const query_response_Visibility_rec_result& from);

  inline query_response_Visibility_rec_result& operator=(const query_response_Visibility_rec_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Visibility_rec_result(query_response_Visibility_rec_result&& from) noexcept
    : query_response_Visibility_rec_result() {
    *this = ::std::move(from);
  }

  inline query_response_Visibility_rec_result& operator=(query_response_Visibility_rec_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Visibility_rec_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Visibility_rec_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Visibility_rec_result*>(
               &_query_response_Visibility_rec_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  void Swap(query_response_Visibility_rec_result* other);
  friend void swap(query_response_Visibility_rec_result& a, query_response_Visibility_rec_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Visibility_rec_result* New() const final {
    return CreateMaybeMessage<query_response_Visibility_rec_result>(NULL);
  }

  query_response_Visibility_rec_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Visibility_rec_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Visibility_rec_result& from);
  void MergeFrom(const query_response_Visibility_rec_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Visibility_rec_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.visibility_rec msg = 81;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 81;
  private:
  const ::ce::nbapi::visibility_rec& _internal_msg() const;
  public:
  const ::ce::nbapi::visibility_rec& msg() const;
  ::ce::nbapi::visibility_rec* release_msg();
  ::ce::nbapi::visibility_rec* mutable_msg();
  void set_allocated_msg(::ce::nbapi::visibility_rec* msg);

  // optional uint32 ts = 82;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 82;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Visibility_rec_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::visibility_rec* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Campus_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Campus_result) */ {
 public:
  query_response_Campus_result();
  virtual ~query_response_Campus_result();

  query_response_Campus_result(const query_response_Campus_result& from);

  inline query_response_Campus_result& operator=(const query_response_Campus_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Campus_result(query_response_Campus_result&& from) noexcept
    : query_response_Campus_result() {
    *this = ::std::move(from);
  }

  inline query_response_Campus_result& operator=(query_response_Campus_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Campus_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Campus_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Campus_result*>(
               &_query_response_Campus_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  void Swap(query_response_Campus_result* other);
  friend void swap(query_response_Campus_result& a, query_response_Campus_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Campus_result* New() const final {
    return CreateMaybeMessage<query_response_Campus_result>(NULL);
  }

  query_response_Campus_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Campus_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Campus_result& from);
  void MergeFrom(const query_response_Campus_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Campus_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.campus msg = 91;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 91;
  private:
  const ::ce::nbapi::campus& _internal_msg() const;
  public:
  const ::ce::nbapi::campus& msg() const;
  ::ce::nbapi::campus* release_msg();
  ::ce::nbapi::campus* mutable_msg();
  void set_allocated_msg(::ce::nbapi::campus* msg);

  // optional uint32 ts = 92;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 92;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Campus_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::campus* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Building_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Building_result) */ {
 public:
  query_response_Building_result();
  virtual ~query_response_Building_result();

  query_response_Building_result(const query_response_Building_result& from);

  inline query_response_Building_result& operator=(const query_response_Building_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Building_result(query_response_Building_result&& from) noexcept
    : query_response_Building_result() {
    *this = ::std::move(from);
  }

  inline query_response_Building_result& operator=(query_response_Building_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Building_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Building_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Building_result*>(
               &_query_response_Building_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  void Swap(query_response_Building_result* other);
  friend void swap(query_response_Building_result& a, query_response_Building_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Building_result* New() const final {
    return CreateMaybeMessage<query_response_Building_result>(NULL);
  }

  query_response_Building_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Building_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Building_result& from);
  void MergeFrom(const query_response_Building_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Building_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.building msg = 101;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 101;
  private:
  const ::ce::nbapi::building& _internal_msg() const;
  public:
  const ::ce::nbapi::building& msg() const;
  ::ce::nbapi::building* release_msg();
  ::ce::nbapi::building* mutable_msg();
  void set_allocated_msg(::ce::nbapi::building* msg);

  // optional uint32 ts = 102;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 102;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Building_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::building* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Floor_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Floor_result) */ {
 public:
  query_response_Floor_result();
  virtual ~query_response_Floor_result();

  query_response_Floor_result(const query_response_Floor_result& from);

  inline query_response_Floor_result& operator=(const query_response_Floor_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Floor_result(query_response_Floor_result&& from) noexcept
    : query_response_Floor_result() {
    *this = ::std::move(from);
  }

  inline query_response_Floor_result& operator=(query_response_Floor_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Floor_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Floor_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Floor_result*>(
               &_query_response_Floor_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  void Swap(query_response_Floor_result* other);
  friend void swap(query_response_Floor_result& a, query_response_Floor_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Floor_result* New() const final {
    return CreateMaybeMessage<query_response_Floor_result>(NULL);
  }

  query_response_Floor_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Floor_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Floor_result& from);
  void MergeFrom(const query_response_Floor_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Floor_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.floor msg = 111;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 111;
  private:
  const ::ce::nbapi::floor& _internal_msg() const;
  public:
  const ::ce::nbapi::floor& msg() const;
  ::ce::nbapi::floor* release_msg();
  ::ce::nbapi::floor* mutable_msg();
  void set_allocated_msg(::ce::nbapi::floor* msg);

  // optional uint32 ts = 112;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 112;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Floor_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::floor* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Access_point_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Access_point_result) */ {
 public:
  query_response_Access_point_result();
  virtual ~query_response_Access_point_result();

  query_response_Access_point_result(const query_response_Access_point_result& from);

  inline query_response_Access_point_result& operator=(const query_response_Access_point_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Access_point_result(query_response_Access_point_result&& from) noexcept
    : query_response_Access_point_result() {
    *this = ::std::move(from);
  }

  inline query_response_Access_point_result& operator=(query_response_Access_point_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Access_point_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Access_point_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Access_point_result*>(
               &_query_response_Access_point_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  void Swap(query_response_Access_point_result* other);
  friend void swap(query_response_Access_point_result& a, query_response_Access_point_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Access_point_result* New() const final {
    return CreateMaybeMessage<query_response_Access_point_result>(NULL);
  }

  query_response_Access_point_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Access_point_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Access_point_result& from);
  void MergeFrom(const query_response_Access_point_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Access_point_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.access_point msg = 121;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 121;
  private:
  const ::ce::nbapi::access_point& _internal_msg() const;
  public:
  const ::ce::nbapi::access_point& msg() const;
  ::ce::nbapi::access_point* release_msg();
  ::ce::nbapi::access_point* mutable_msg();
  void set_allocated_msg(::ce::nbapi::access_point* msg);

  // optional uint32 ts = 122;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 122;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Access_point_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::access_point* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Virtual_access_point_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Virtual_access_point_result) */ {
 public:
  query_response_Virtual_access_point_result();
  virtual ~query_response_Virtual_access_point_result();

  query_response_Virtual_access_point_result(const query_response_Virtual_access_point_result& from);

  inline query_response_Virtual_access_point_result& operator=(const query_response_Virtual_access_point_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Virtual_access_point_result(query_response_Virtual_access_point_result&& from) noexcept
    : query_response_Virtual_access_point_result() {
    *this = ::std::move(from);
  }

  inline query_response_Virtual_access_point_result& operator=(query_response_Virtual_access_point_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Virtual_access_point_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Virtual_access_point_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Virtual_access_point_result*>(
               &_query_response_Virtual_access_point_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  void Swap(query_response_Virtual_access_point_result* other);
  friend void swap(query_response_Virtual_access_point_result& a, query_response_Virtual_access_point_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Virtual_access_point_result* New() const final {
    return CreateMaybeMessage<query_response_Virtual_access_point_result>(NULL);
  }

  query_response_Virtual_access_point_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Virtual_access_point_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Virtual_access_point_result& from);
  void MergeFrom(const query_response_Virtual_access_point_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Virtual_access_point_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.virtual_access_point msg = 131;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 131;
  private:
  const ::ce::nbapi::virtual_access_point& _internal_msg() const;
  public:
  const ::ce::nbapi::virtual_access_point& msg() const;
  ::ce::nbapi::virtual_access_point* release_msg();
  ::ce::nbapi::virtual_access_point* mutable_msg();
  void set_allocated_msg(::ce::nbapi::virtual_access_point* msg);

  // optional uint32 ts = 132;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 132;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Virtual_access_point_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::virtual_access_point* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Geofence_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Geofence_result) */ {
 public:
  query_response_Geofence_result();
  virtual ~query_response_Geofence_result();

  query_response_Geofence_result(const query_response_Geofence_result& from);

  inline query_response_Geofence_result& operator=(const query_response_Geofence_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Geofence_result(query_response_Geofence_result&& from) noexcept
    : query_response_Geofence_result() {
    *this = ::std::move(from);
  }

  inline query_response_Geofence_result& operator=(query_response_Geofence_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Geofence_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Geofence_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Geofence_result*>(
               &_query_response_Geofence_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  void Swap(query_response_Geofence_result* other);
  friend void swap(query_response_Geofence_result& a, query_response_Geofence_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Geofence_result* New() const final {
    return CreateMaybeMessage<query_response_Geofence_result>(NULL);
  }

  query_response_Geofence_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Geofence_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Geofence_result& from);
  void MergeFrom(const query_response_Geofence_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Geofence_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.geofence msg = 141;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 141;
  private:
  const ::ce::nbapi::geofence& _internal_msg() const;
  public:
  const ::ce::nbapi::geofence& msg() const;
  ::ce::nbapi::geofence* release_msg();
  ::ce::nbapi::geofence* mutable_msg();
  void set_allocated_msg(::ce::nbapi::geofence* msg);

  // optional uint32 ts = 142;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 142;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Geofence_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::geofence* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Proximity_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Proximity_result) */ {
 public:
  query_response_Proximity_result();
  virtual ~query_response_Proximity_result();

  query_response_Proximity_result(const query_response_Proximity_result& from);

  inline query_response_Proximity_result& operator=(const query_response_Proximity_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Proximity_result(query_response_Proximity_result&& from) noexcept
    : query_response_Proximity_result() {
    *this = ::std::move(from);
  }

  inline query_response_Proximity_result& operator=(query_response_Proximity_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Proximity_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Proximity_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Proximity_result*>(
               &_query_response_Proximity_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  void Swap(query_response_Proximity_result* other);
  friend void swap(query_response_Proximity_result& a, query_response_Proximity_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Proximity_result* New() const final {
    return CreateMaybeMessage<query_response_Proximity_result>(NULL);
  }

  query_response_Proximity_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Proximity_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Proximity_result& from);
  void MergeFrom(const query_response_Proximity_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Proximity_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.proximity msg = 152;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 152;
  private:
  const ::ce::nbapi::proximity& _internal_msg() const;
  public:
  const ::ce::nbapi::proximity& msg() const;
  ::ce::nbapi::proximity* release_msg();
  ::ce::nbapi::proximity* mutable_msg();
  void set_allocated_msg(::ce::nbapi::proximity* msg);

  // optional uint32 ts = 153;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 153;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Proximity_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::proximity* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_WebCCCategory_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.WebCCCategory_result) */ {
 public:
  query_response_WebCCCategory_result();
  virtual ~query_response_WebCCCategory_result();

  query_response_WebCCCategory_result(const query_response_WebCCCategory_result& from);

  inline query_response_WebCCCategory_result& operator=(const query_response_WebCCCategory_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_WebCCCategory_result(query_response_WebCCCategory_result&& from) noexcept
    : query_response_WebCCCategory_result() {
    *this = ::std::move(from);
  }

  inline query_response_WebCCCategory_result& operator=(query_response_WebCCCategory_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_WebCCCategory_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_WebCCCategory_result* internal_default_instance() {
    return reinterpret_cast<const query_response_WebCCCategory_result*>(
               &_query_response_WebCCCategory_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  void Swap(query_response_WebCCCategory_result* other);
  friend void swap(query_response_WebCCCategory_result& a, query_response_WebCCCategory_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_WebCCCategory_result* New() const final {
    return CreateMaybeMessage<query_response_WebCCCategory_result>(NULL);
  }

  query_response_WebCCCategory_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_WebCCCategory_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_WebCCCategory_result& from);
  void MergeFrom(const query_response_WebCCCategory_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_WebCCCategory_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.webcc_category msg = 161;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 161;
  private:
  const ::ce::nbapi::webcc_category& _internal_msg() const;
  public:
  const ::ce::nbapi::webcc_category& msg() const;
  ::ce::nbapi::webcc_category* release_msg();
  ::ce::nbapi::webcc_category* mutable_msg();
  void set_allocated_msg(::ce::nbapi::webcc_category* msg);

  // optional uint32 ts = 162;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 162;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.WebCCCategory_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::webcc_category* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Info_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Info_result) */ {
 public:
  query_response_Info_result();
  virtual ~query_response_Info_result();

  query_response_Info_result(const query_response_Info_result& from);

  inline query_response_Info_result& operator=(const query_response_Info_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Info_result(query_response_Info_result&& from) noexcept
    : query_response_Info_result() {
    *this = ::std::move(from);
  }

  inline query_response_Info_result& operator=(query_response_Info_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Info_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Info_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Info_result*>(
               &_query_response_Info_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  void Swap(query_response_Info_result* other);
  friend void swap(query_response_Info_result& a, query_response_Info_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Info_result* New() const final {
    return CreateMaybeMessage<query_response_Info_result>(NULL);
  }

  query_response_Info_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Info_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Info_result& from);
  void MergeFrom(const query_response_Info_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Info_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.info msg = 171;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 171;
  private:
  const ::ce::nbapi::info& _internal_msg() const;
  public:
  const ::ce::nbapi::info& msg() const;
  ::ce::nbapi::info* release_msg();
  ::ce::nbapi::info* mutable_msg();
  void set_allocated_msg(::ce::nbapi::info* msg);

  // optional uint32 ts = 172;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 172;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Info_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::info* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Topology_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Topology_result) */ {
 public:
  query_response_Topology_result();
  virtual ~query_response_Topology_result();

  query_response_Topology_result(const query_response_Topology_result& from);

  inline query_response_Topology_result& operator=(const query_response_Topology_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Topology_result(query_response_Topology_result&& from) noexcept
    : query_response_Topology_result() {
    *this = ::std::move(from);
  }

  inline query_response_Topology_result& operator=(query_response_Topology_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Topology_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Topology_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Topology_result*>(
               &_query_response_Topology_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  void Swap(query_response_Topology_result* other);
  friend void swap(query_response_Topology_result& a, query_response_Topology_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Topology_result* New() const final {
    return CreateMaybeMessage<query_response_Topology_result>(NULL);
  }

  query_response_Topology_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Topology_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Topology_result& from);
  void MergeFrom(const query_response_Topology_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Topology_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.topology msg = 181;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 181;
  private:
  const ::ce::nbapi::topology& _internal_msg() const;
  public:
  const ::ce::nbapi::topology& msg() const;
  ::ce::nbapi::topology* release_msg();
  ::ce::nbapi::topology* mutable_msg();
  void set_allocated_msg(::ce::nbapi::topology* msg);

  // optional uint32 ts = 182;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 182;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Topology_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::topology* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Controller_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Controller_result) */ {
 public:
  query_response_Controller_result();
  virtual ~query_response_Controller_result();

  query_response_Controller_result(const query_response_Controller_result& from);

  inline query_response_Controller_result& operator=(const query_response_Controller_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Controller_result(query_response_Controller_result&& from) noexcept
    : query_response_Controller_result() {
    *this = ::std::move(from);
  }

  inline query_response_Controller_result& operator=(query_response_Controller_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Controller_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Controller_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Controller_result*>(
               &_query_response_Controller_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  void Swap(query_response_Controller_result* other);
  friend void swap(query_response_Controller_result& a, query_response_Controller_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Controller_result* New() const final {
    return CreateMaybeMessage<query_response_Controller_result>(NULL);
  }

  query_response_Controller_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Controller_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Controller_result& from);
  void MergeFrom(const query_response_Controller_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Controller_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.controller_info msg = 191;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 191;
  private:
  const ::ce::nbapi::controller_info& _internal_msg() const;
  public:
  const ::ce::nbapi::controller_info& msg() const;
  ::ce::nbapi::controller_info* release_msg();
  ::ce::nbapi::controller_info* mutable_msg();
  void set_allocated_msg(::ce::nbapi::controller_info* msg);

  // optional uint32 ts = 192;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 192;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Controller_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::controller_info* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Cluster_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Cluster_result) */ {
 public:
  query_response_Cluster_result();
  virtual ~query_response_Cluster_result();

  query_response_Cluster_result(const query_response_Cluster_result& from);

  inline query_response_Cluster_result& operator=(const query_response_Cluster_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Cluster_result(query_response_Cluster_result&& from) noexcept
    : query_response_Cluster_result() {
    *this = ::std::move(from);
  }

  inline query_response_Cluster_result& operator=(query_response_Cluster_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Cluster_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Cluster_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Cluster_result*>(
               &_query_response_Cluster_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  void Swap(query_response_Cluster_result* other);
  friend void swap(query_response_Cluster_result& a, query_response_Cluster_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Cluster_result* New() const final {
    return CreateMaybeMessage<query_response_Cluster_result>(NULL);
  }

  query_response_Cluster_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Cluster_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Cluster_result& from);
  void MergeFrom(const query_response_Cluster_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Cluster_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.cluster_info msg = 201;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 201;
  private:
  const ::ce::nbapi::cluster_info& _internal_msg() const;
  public:
  const ::ce::nbapi::cluster_info& msg() const;
  ::ce::nbapi::cluster_info* release_msg();
  ::ce::nbapi::cluster_info* mutable_msg();
  void set_allocated_msg(::ce::nbapi::cluster_info* msg);

  // optional uint32 ts = 202;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 202;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Cluster_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::cluster_info* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response_Access_point_location_result : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response.Access_point_location_result) */ {
 public:
  query_response_Access_point_location_result();
  virtual ~query_response_Access_point_location_result();

  query_response_Access_point_location_result(const query_response_Access_point_location_result& from);

  inline query_response_Access_point_location_result& operator=(const query_response_Access_point_location_result& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response_Access_point_location_result(query_response_Access_point_location_result&& from) noexcept
    : query_response_Access_point_location_result() {
    *this = ::std::move(from);
  }

  inline query_response_Access_point_location_result& operator=(query_response_Access_point_location_result&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response_Access_point_location_result& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response_Access_point_location_result* internal_default_instance() {
    return reinterpret_cast<const query_response_Access_point_location_result*>(
               &_query_response_Access_point_location_result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  void Swap(query_response_Access_point_location_result* other);
  friend void swap(query_response_Access_point_location_result& a, query_response_Access_point_location_result& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response_Access_point_location_result* New() const final {
    return CreateMaybeMessage<query_response_Access_point_location_result>(NULL);
  }

  query_response_Access_point_location_result* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response_Access_point_location_result>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response_Access_point_location_result& from);
  void MergeFrom(const query_response_Access_point_location_result& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response_Access_point_location_result* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ce.nbapi.ap_location msg = 211;
  bool has_msg() const;
  void clear_msg();
  static const int kMsgFieldNumber = 211;
  private:
  const ::ce::nbapi::ap_location& _internal_msg() const;
  public:
  const ::ce::nbapi::ap_location& msg() const;
  ::ce::nbapi::ap_location* release_msg();
  ::ce::nbapi::ap_location* mutable_msg();
  void set_allocated_msg(::ce::nbapi::ap_location* msg);

  // optional uint32 ts = 212;
  bool has_ts() const;
  void clear_ts();
  static const int kTsFieldNumber = 212;
  ::google::protobuf::uint32 ts() const;
  void set_ts(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response.Access_point_location_result)
 private:
  void set_has_msg();
  void clear_has_msg();
  void set_has_ts();
  void clear_has_ts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ce::nbapi::ap_location* msg_;
  ::google::protobuf::uint32 ts_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class query_response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.query_response) */ {
 public:
  query_response();
  virtual ~query_response();

  query_response(const query_response& from);

  inline query_response& operator=(const query_response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  query_response(query_response&& from) noexcept
    : query_response() {
    *this = ::std::move(from);
  }

  inline query_response& operator=(query_response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const query_response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const query_response* internal_default_instance() {
    return reinterpret_cast<const query_response*>(
               &_query_response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  void Swap(query_response* other);
  friend void swap(query_response& a, query_response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline query_response* New() const final {
    return CreateMaybeMessage<query_response>(NULL);
  }

  query_response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<query_response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const query_response& from);
  void MergeFrom(const query_response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(query_response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef query_response_Location_result Location_result;
  typedef query_response_Presence_result Presence_result;
  typedef query_response_Rssi_result Rssi_result;
  typedef query_response_Station_result Station_result;
  typedef query_response_Radio_result Radio_result;
  typedef query_response_Destination_result Destination_result;
  typedef query_response_Application_result Application_result;
  typedef query_response_Visibility_rec_result Visibility_rec_result;
  typedef query_response_Campus_result Campus_result;
  typedef query_response_Building_result Building_result;
  typedef query_response_Floor_result Floor_result;
  typedef query_response_Access_point_result Access_point_result;
  typedef query_response_Virtual_access_point_result Virtual_access_point_result;
  typedef query_response_Geofence_result Geofence_result;
  typedef query_response_Proximity_result Proximity_result;
  typedef query_response_WebCCCategory_result WebCCCategory_result;
  typedef query_response_Info_result Info_result;
  typedef query_response_Topology_result Topology_result;
  typedef query_response_Controller_result Controller_result;
  typedef query_response_Cluster_result Cluster_result;
  typedef query_response_Access_point_location_result Access_point_location_result;

  // accessors -------------------------------------------------------

  // repeated group Location_result = 10 { ... };
  int location_result_size() const;
  void clear_location_result();
  static const int kLocationResultFieldNumber = 10;
  ::ce::nbapi::query_response_Location_result* mutable_location_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Location_result >*
      mutable_location_result();
  const ::ce::nbapi::query_response_Location_result& location_result(int index) const;
  ::ce::nbapi::query_response_Location_result* add_location_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Location_result >&
      location_result() const;

  // repeated group Presence_result = 20 { ... };
  int presence_result_size() const;
  void clear_presence_result();
  static const int kPresenceResultFieldNumber = 20;
  ::ce::nbapi::query_response_Presence_result* mutable_presence_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Presence_result >*
      mutable_presence_result();
  const ::ce::nbapi::query_response_Presence_result& presence_result(int index) const;
  ::ce::nbapi::query_response_Presence_result* add_presence_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Presence_result >&
      presence_result() const;

  // repeated group Rssi_result = 30 { ... };
  int rssi_result_size() const;
  void clear_rssi_result();
  static const int kRssiResultFieldNumber = 30;
  ::ce::nbapi::query_response_Rssi_result* mutable_rssi_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Rssi_result >*
      mutable_rssi_result();
  const ::ce::nbapi::query_response_Rssi_result& rssi_result(int index) const;
  ::ce::nbapi::query_response_Rssi_result* add_rssi_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Rssi_result >&
      rssi_result() const;

  // repeated group Station_result = 40 { ... };
  int station_result_size() const;
  void clear_station_result();
  static const int kStationResultFieldNumber = 40;
  ::ce::nbapi::query_response_Station_result* mutable_station_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Station_result >*
      mutable_station_result();
  const ::ce::nbapi::query_response_Station_result& station_result(int index) const;
  ::ce::nbapi::query_response_Station_result* add_station_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Station_result >&
      station_result() const;

  // repeated group Radio_result = 50 { ... };
  int radio_result_size() const;
  void clear_radio_result();
  static const int kRadioResultFieldNumber = 50;
  ::ce::nbapi::query_response_Radio_result* mutable_radio_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Radio_result >*
      mutable_radio_result();
  const ::ce::nbapi::query_response_Radio_result& radio_result(int index) const;
  ::ce::nbapi::query_response_Radio_result* add_radio_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Radio_result >&
      radio_result() const;

  // repeated group Destination_result = 60 { ... };
  int destination_result_size() const;
  void clear_destination_result();
  static const int kDestinationResultFieldNumber = 60;
  ::ce::nbapi::query_response_Destination_result* mutable_destination_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Destination_result >*
      mutable_destination_result();
  const ::ce::nbapi::query_response_Destination_result& destination_result(int index) const;
  ::ce::nbapi::query_response_Destination_result* add_destination_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Destination_result >&
      destination_result() const;

  // repeated group Application_result = 70 { ... };
  int application_result_size() const;
  void clear_application_result();
  static const int kApplicationResultFieldNumber = 70;
  ::ce::nbapi::query_response_Application_result* mutable_application_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Application_result >*
      mutable_application_result();
  const ::ce::nbapi::query_response_Application_result& application_result(int index) const;
  ::ce::nbapi::query_response_Application_result* add_application_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Application_result >&
      application_result() const;

  // repeated group Visibility_rec_result = 80 { ... };
  int visibility_rec_result_size() const;
  void clear_visibility_rec_result();
  static const int kVisibilityRecResultFieldNumber = 80;
  ::ce::nbapi::query_response_Visibility_rec_result* mutable_visibility_rec_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Visibility_rec_result >*
      mutable_visibility_rec_result();
  const ::ce::nbapi::query_response_Visibility_rec_result& visibility_rec_result(int index) const;
  ::ce::nbapi::query_response_Visibility_rec_result* add_visibility_rec_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Visibility_rec_result >&
      visibility_rec_result() const;

  // repeated group Campus_result = 90 { ... };
  int campus_result_size() const;
  void clear_campus_result();
  static const int kCampusResultFieldNumber = 90;
  ::ce::nbapi::query_response_Campus_result* mutable_campus_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Campus_result >*
      mutable_campus_result();
  const ::ce::nbapi::query_response_Campus_result& campus_result(int index) const;
  ::ce::nbapi::query_response_Campus_result* add_campus_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Campus_result >&
      campus_result() const;

  // repeated group Building_result = 100 { ... };
  int building_result_size() const;
  void clear_building_result();
  static const int kBuildingResultFieldNumber = 100;
  ::ce::nbapi::query_response_Building_result* mutable_building_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Building_result >*
      mutable_building_result();
  const ::ce::nbapi::query_response_Building_result& building_result(int index) const;
  ::ce::nbapi::query_response_Building_result* add_building_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Building_result >&
      building_result() const;

  // repeated group Floor_result = 110 { ... };
  int floor_result_size() const;
  void clear_floor_result();
  static const int kFloorResultFieldNumber = 110;
  ::ce::nbapi::query_response_Floor_result* mutable_floor_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Floor_result >*
      mutable_floor_result();
  const ::ce::nbapi::query_response_Floor_result& floor_result(int index) const;
  ::ce::nbapi::query_response_Floor_result* add_floor_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Floor_result >&
      floor_result() const;

  // repeated group Access_point_result = 120 { ... };
  int access_point_result_size() const;
  void clear_access_point_result();
  static const int kAccessPointResultFieldNumber = 120;
  ::ce::nbapi::query_response_Access_point_result* mutable_access_point_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Access_point_result >*
      mutable_access_point_result();
  const ::ce::nbapi::query_response_Access_point_result& access_point_result(int index) const;
  ::ce::nbapi::query_response_Access_point_result* add_access_point_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Access_point_result >&
      access_point_result() const;

  // repeated group Virtual_access_point_result = 130 { ... };
  int virtual_access_point_result_size() const;
  void clear_virtual_access_point_result();
  static const int kVirtualAccessPointResultFieldNumber = 130;
  ::ce::nbapi::query_response_Virtual_access_point_result* mutable_virtual_access_point_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Virtual_access_point_result >*
      mutable_virtual_access_point_result();
  const ::ce::nbapi::query_response_Virtual_access_point_result& virtual_access_point_result(int index) const;
  ::ce::nbapi::query_response_Virtual_access_point_result* add_virtual_access_point_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Virtual_access_point_result >&
      virtual_access_point_result() const;

  // repeated group Geofence_result = 140 { ... };
  int geofence_result_size() const;
  void clear_geofence_result();
  static const int kGeofenceResultFieldNumber = 140;
  ::ce::nbapi::query_response_Geofence_result* mutable_geofence_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Geofence_result >*
      mutable_geofence_result();
  const ::ce::nbapi::query_response_Geofence_result& geofence_result(int index) const;
  ::ce::nbapi::query_response_Geofence_result* add_geofence_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Geofence_result >&
      geofence_result() const;

  // repeated group Proximity_result = 150 { ... };
  int proximity_result_size() const;
  void clear_proximity_result();
  static const int kProximityResultFieldNumber = 150;
  ::ce::nbapi::query_response_Proximity_result* mutable_proximity_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Proximity_result >*
      mutable_proximity_result();
  const ::ce::nbapi::query_response_Proximity_result& proximity_result(int index) const;
  ::ce::nbapi::query_response_Proximity_result* add_proximity_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Proximity_result >&
      proximity_result() const;

  // repeated group WebCCCategory_result = 160 { ... };
  int webcccategory_result_size() const;
  void clear_webcccategory_result();
  static const int kWebcccategoryResultFieldNumber = 160;
  ::ce::nbapi::query_response_WebCCCategory_result* mutable_webcccategory_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_WebCCCategory_result >*
      mutable_webcccategory_result();
  const ::ce::nbapi::query_response_WebCCCategory_result& webcccategory_result(int index) const;
  ::ce::nbapi::query_response_WebCCCategory_result* add_webcccategory_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_WebCCCategory_result >&
      webcccategory_result() const;

  // repeated group Topology_result = 180 { ... };
  int topology_result_size() const;
  void clear_topology_result();
  static const int kTopologyResultFieldNumber = 180;
  ::ce::nbapi::query_response_Topology_result* mutable_topology_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Topology_result >*
      mutable_topology_result();
  const ::ce::nbapi::query_response_Topology_result& topology_result(int index) const;
  ::ce::nbapi::query_response_Topology_result* add_topology_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Topology_result >&
      topology_result() const;

  // repeated group Controller_result = 190 { ... };
  int controller_result_size() const;
  void clear_controller_result();
  static const int kControllerResultFieldNumber = 190;
  ::ce::nbapi::query_response_Controller_result* mutable_controller_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Controller_result >*
      mutable_controller_result();
  const ::ce::nbapi::query_response_Controller_result& controller_result(int index) const;
  ::ce::nbapi::query_response_Controller_result* add_controller_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Controller_result >&
      controller_result() const;

  // repeated group Cluster_result = 200 { ... };
  int cluster_result_size() const;
  void clear_cluster_result();
  static const int kClusterResultFieldNumber = 200;
  ::ce::nbapi::query_response_Cluster_result* mutable_cluster_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Cluster_result >*
      mutable_cluster_result();
  const ::ce::nbapi::query_response_Cluster_result& cluster_result(int index) const;
  ::ce::nbapi::query_response_Cluster_result* add_cluster_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Cluster_result >&
      cluster_result() const;

  // repeated group Access_point_location_result = 210 { ... };
  int access_point_location_result_size() const;
  void clear_access_point_location_result();
  static const int kAccessPointLocationResultFieldNumber = 210;
  ::ce::nbapi::query_response_Access_point_location_result* mutable_access_point_location_result(int index);
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Access_point_location_result >*
      mutable_access_point_location_result();
  const ::ce::nbapi::query_response_Access_point_location_result& access_point_location_result(int index) const;
  ::ce::nbapi::query_response_Access_point_location_result* add_access_point_location_result();
  const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Access_point_location_result >&
      access_point_location_result() const;

  // optional group Info_result = 170 { ... };
  bool has_info_result() const;
  void clear_info_result();
  static const int kInfoResultFieldNumber = 170;
  private:
  const ::ce::nbapi::query_response_Info_result& _internal_info_result() const;
  public:
  const ::ce::nbapi::query_response_Info_result& info_result() const;
  ::ce::nbapi::query_response_Info_result* release_info_result();
  ::ce::nbapi::query_response_Info_result* mutable_info_result();
  void set_allocated_info_result(::ce::nbapi::query_response_Info_result* info_result);

  // @@protoc_insertion_point(class_scope:ce.nbapi.query_response)
 private:
  void set_has_info_result();
  void clear_has_info_result();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Location_result > location_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Presence_result > presence_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Rssi_result > rssi_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Station_result > station_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Radio_result > radio_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Destination_result > destination_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Application_result > application_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Visibility_rec_result > visibility_rec_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Campus_result > campus_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Building_result > building_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Floor_result > floor_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Access_point_result > access_point_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Virtual_access_point_result > virtual_access_point_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Geofence_result > geofence_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Proximity_result > proximity_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_WebCCCategory_result > webcccategory_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Topology_result > topology_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Controller_result > controller_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Cluster_result > cluster_result_;
  ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Access_point_location_result > access_point_location_result_;
  ::ce::nbapi::query_response_Info_result* info_result_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class iap_client_url : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.iap_client_url) */ {
 public:
  iap_client_url();
  virtual ~iap_client_url();

  iap_client_url(const iap_client_url& from);

  inline iap_client_url& operator=(const iap_client_url& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  iap_client_url(iap_client_url&& from) noexcept
    : iap_client_url() {
    *this = ::std::move(from);
  }

  inline iap_client_url& operator=(iap_client_url&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const iap_client_url& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const iap_client_url* internal_default_instance() {
    return reinterpret_cast<const iap_client_url*>(
               &_iap_client_url_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  void Swap(iap_client_url* other);
  friend void swap(iap_client_url& a, iap_client_url& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline iap_client_url* New() const final {
    return CreateMaybeMessage<iap_client_url>(NULL);
  }

  iap_client_url* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<iap_client_url>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const iap_client_url& from);
  void MergeFrom(const iap_client_url& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(iap_client_url* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string ap_host_name = 5;
  bool has_ap_host_name() const;
  void clear_ap_host_name();
  static const int kApHostNameFieldNumber = 5;
  const ::std::string& ap_host_name() const;
  void set_ap_host_name(const ::std::string& value);
  #if LANG_CXX11
  void set_ap_host_name(::std::string&& value);
  #endif
  void set_ap_host_name(const char* value);
  void set_ap_host_name(const char* value, size_t size);
  ::std::string* mutable_ap_host_name();
  ::std::string* release_ap_host_name();
  void set_allocated_ap_host_name(::std::string* ap_host_name);

  // optional .ce.nbapi.iap_message_info info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  private:
  const ::ce::nbapi::iap_message_info& _internal_info() const;
  public:
  const ::ce::nbapi::iap_message_info& info() const;
  ::ce::nbapi::iap_message_info* release_info();
  ::ce::nbapi::iap_message_info* mutable_info();
  void set_allocated_info(::ce::nbapi::iap_message_info* info);

  // optional .ce.nbapi.mac_address ap_mac = 3;
  bool has_ap_mac() const;
  void clear_ap_mac();
  static const int kApMacFieldNumber = 3;
  private:
  const ::ce::nbapi::mac_address& _internal_ap_mac() const;
  public:
  const ::ce::nbapi::mac_address& ap_mac() const;
  ::ce::nbapi::mac_address* release_ap_mac();
  ::ce::nbapi::mac_address* mutable_ap_mac();
  void set_allocated_ap_mac(::ce::nbapi::mac_address* ap_mac);

  // optional .ce.nbapi.url_detail_record url_record = 4;
  bool has_url_record() const;
  void clear_url_record();
  static const int kUrlRecordFieldNumber = 4;
  private:
  const ::ce::nbapi::url_detail_record& _internal_url_record() const;
  public:
  const ::ce::nbapi::url_detail_record& url_record() const;
  ::ce::nbapi::url_detail_record* release_url_record();
  ::ce::nbapi::url_detail_record* mutable_url_record();
  void set_allocated_url_record(::ce::nbapi::url_detail_record* url_record);

  // optional uint64 timestamp = 2;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.iap_client_url)
 private:
  void set_has_info();
  void clear_has_info();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_ap_mac();
  void clear_has_ap_mac();
  void set_has_url_record();
  void clear_has_url_record();
  void set_has_ap_host_name();
  void clear_has_ap_host_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr ap_host_name_;
  ::ce::nbapi::iap_message_info* info_;
  ::ce::nbapi::mac_address* ap_mac_;
  ::ce::nbapi::url_detail_record* url_record_;
  ::google::protobuf::uint64 timestamp_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class url_detail_record : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.url_detail_record) */ {
 public:
  url_detail_record();
  virtual ~url_detail_record();

  url_detail_record(const url_detail_record& from);

  inline url_detail_record& operator=(const url_detail_record& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  url_detail_record(url_detail_record&& from) noexcept
    : url_detail_record() {
    *this = ::std::move(from);
  }

  inline url_detail_record& operator=(url_detail_record&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const url_detail_record& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const url_detail_record* internal_default_instance() {
    return reinterpret_cast<const url_detail_record*>(
               &_url_detail_record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  void Swap(url_detail_record* other);
  friend void swap(url_detail_record& a, url_detail_record& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline url_detail_record* New() const final {
    return CreateMaybeMessage<url_detail_record>(NULL);
  }

  url_detail_record* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<url_detail_record>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const url_detail_record& from);
  void MergeFrom(const url_detail_record& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(url_detail_record* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef url_detail_record_url_http_method url_http_method;
  static const url_http_method NON_HTTP =
    url_detail_record_url_http_method_NON_HTTP;
  static const url_http_method HTTP_GET =
    url_detail_record_url_http_method_HTTP_GET;
  static const url_http_method HTTP_PUT =
    url_detail_record_url_http_method_HTTP_PUT;
  static const url_http_method HTTP_POST =
    url_detail_record_url_http_method_HTTP_POST;
  static const url_http_method HTTP_HEAD =
    url_detail_record_url_http_method_HTTP_HEAD;
  static inline bool url_http_method_IsValid(int value) {
    return url_detail_record_url_http_method_IsValid(value);
  }
  static const url_http_method url_http_method_MIN =
    url_detail_record_url_http_method_url_http_method_MIN;
  static const url_http_method url_http_method_MAX =
    url_detail_record_url_http_method_url_http_method_MAX;
  static const int url_http_method_ARRAYSIZE =
    url_detail_record_url_http_method_url_http_method_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  url_http_method_descriptor() {
    return url_detail_record_url_http_method_descriptor();
  }
  static inline const ::std::string& url_http_method_Name(url_http_method value) {
    return url_detail_record_url_http_method_Name(value);
  }
  static inline bool url_http_method_Parse(const ::std::string& name,
      url_http_method* value) {
    return url_detail_record_url_http_method_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional bytes url = 3;
  bool has_url() const;
  void clear_url();
  static const int kUrlFieldNumber = 3;
  const ::std::string& url() const;
  void set_url(const ::std::string& value);
  #if LANG_CXX11
  void set_url(::std::string&& value);
  #endif
  void set_url(const char* value);
  void set_url(const void* value, size_t size);
  ::std::string* mutable_url();
  ::std::string* release_url();
  void set_allocated_url(::std::string* url);

  // optional .ce.nbapi.ip_address client_ip = 1;
  bool has_client_ip() const;
  void clear_client_ip();
  static const int kClientIpFieldNumber = 1;
  private:
  const ::ce::nbapi::ip_address& _internal_client_ip() const;
  public:
  const ::ce::nbapi::ip_address& client_ip() const;
  ::ce::nbapi::ip_address* release_client_ip();
  ::ce::nbapi::ip_address* mutable_client_ip();
  void set_allocated_client_ip(::ce::nbapi::ip_address* client_ip);

  // optional .ce.nbapi.ip_address dest_ip = 2;
  bool has_dest_ip() const;
  void clear_dest_ip();
  static const int kDestIpFieldNumber = 2;
  private:
  const ::ce::nbapi::ip_address& _internal_dest_ip() const;
  public:
  const ::ce::nbapi::ip_address& dest_ip() const;
  ::ce::nbapi::ip_address* release_dest_ip();
  ::ce::nbapi::ip_address* mutable_dest_ip();
  void set_allocated_dest_ip(::ce::nbapi::ip_address* dest_ip);

  // optional .ce.nbapi.mac_address client_mac = 5;
  bool has_client_mac() const;
  void clear_client_mac();
  static const int kClientMacFieldNumber = 5;
  private:
  const ::ce::nbapi::mac_address& _internal_client_mac() const;
  public:
  const ::ce::nbapi::mac_address& client_mac() const;
  ::ce::nbapi::mac_address* release_client_mac();
  ::ce::nbapi::mac_address* mutable_client_mac();
  void set_allocated_client_mac(::ce::nbapi::mac_address* client_mac);

  // optional uint64 last_hit_timestamp = 7;
  bool has_last_hit_timestamp() const;
  void clear_last_hit_timestamp();
  static const int kLastHitTimestampFieldNumber = 7;
  ::google::protobuf::uint64 last_hit_timestamp() const;
  void set_last_hit_timestamp(::google::protobuf::uint64 value);

  // optional uint32 hit_count = 4;
  bool has_hit_count() const;
  void clear_hit_count();
  static const int kHitCountFieldNumber = 4;
  ::google::protobuf::uint32 hit_count() const;
  void set_hit_count(::google::protobuf::uint32 value);

  // optional .ce.nbapi.url_detail_record.url_http_method http_method = 6;
  bool has_http_method() const;
  void clear_http_method();
  static const int kHttpMethodFieldNumber = 6;
  ::ce::nbapi::url_detail_record_url_http_method http_method() const;
  void set_http_method(::ce::nbapi::url_detail_record_url_http_method value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.url_detail_record)
 private:
  void set_has_client_ip();
  void clear_has_client_ip();
  void set_has_dest_ip();
  void clear_has_dest_ip();
  void set_has_url();
  void clear_has_url();
  void set_has_hit_count();
  void clear_has_hit_count();
  void set_has_client_mac();
  void clear_has_client_mac();
  void set_has_http_method();
  void clear_has_http_method();
  void set_has_last_hit_timestamp();
  void clear_has_last_hit_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr url_;
  ::ce::nbapi::ip_address* client_ip_;
  ::ce::nbapi::ip_address* dest_ip_;
  ::ce::nbapi::mac_address* client_mac_;
  ::google::protobuf::uint64 last_hit_timestamp_;
  ::google::protobuf::uint32 hit_count_;
  int http_method_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class iap_message_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.iap_message_info) */ {
 public:
  iap_message_info();
  virtual ~iap_message_info();

  iap_message_info(const iap_message_info& from);

  inline iap_message_info& operator=(const iap_message_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  iap_message_info(iap_message_info&& from) noexcept
    : iap_message_info() {
    *this = ::std::move(from);
  }

  inline iap_message_info& operator=(iap_message_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const iap_message_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const iap_message_info* internal_default_instance() {
    return reinterpret_cast<const iap_message_info*>(
               &_iap_message_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  void Swap(iap_message_info* other);
  friend void swap(iap_message_info& a, iap_message_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline iap_message_info* New() const final {
    return CreateMaybeMessage<iap_message_info>(NULL);
  }

  iap_message_info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<iap_message_info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const iap_message_info& from);
  void MergeFrom(const iap_message_info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(iap_message_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes guid = 4;
  bool has_guid() const;
  void clear_guid();
  static const int kGuidFieldNumber = 4;
  const ::std::string& guid() const;
  void set_guid(const ::std::string& value);
  #if LANG_CXX11
  void set_guid(::std::string&& value);
  #endif
  void set_guid(const char* value);
  void set_guid(const void* value, size_t size);
  ::std::string* mutable_guid();
  ::std::string* release_guid();
  void set_allocated_guid(::std::string* guid);

  // optional string oem_tag = 5;
  bool has_oem_tag() const;
  void clear_oem_tag();
  static const int kOemTagFieldNumber = 5;
  const ::std::string& oem_tag() const;
  void set_oem_tag(const ::std::string& value);
  #if LANG_CXX11
  void set_oem_tag(::std::string&& value);
  #endif
  void set_oem_tag(const char* value);
  void set_oem_tag(const char* value, size_t size);
  ::std::string* mutable_oem_tag();
  ::std::string* release_oem_tag();
  void set_allocated_oem_tag(::std::string* oem_tag);

  // optional uint64 sequence = 3;
  bool has_sequence() const;
  void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  ::google::protobuf::uint64 sequence() const;
  void set_sequence(::google::protobuf::uint64 value);

  // optional uint32 version = 1;
  bool has_version() const;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::uint32 version() const;
  void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.iap_message_info)
 private:
  void set_has_version();
  void clear_has_version();
  void set_has_sequence();
  void clear_has_sequence();
  void set_has_guid();
  void clear_has_guid();
  void set_has_oem_tag();
  void clear_has_oem_tag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr guid_;
  ::google::protobuf::internal::ArenaStringPtr oem_tag_;
  ::google::protobuf::uint64 sequence_;
  ::google::protobuf::uint32 version_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class air_monitor_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.air_monitor_info) */ {
 public:
  air_monitor_info();
  virtual ~air_monitor_info();

  air_monitor_info(const air_monitor_info& from);

  inline air_monitor_info& operator=(const air_monitor_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  air_monitor_info(air_monitor_info&& from) noexcept
    : air_monitor_info() {
    *this = ::std::move(from);
  }

  inline air_monitor_info& operator=(air_monitor_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const air_monitor_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const air_monitor_info* internal_default_instance() {
    return reinterpret_cast<const air_monitor_info*>(
               &_air_monitor_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  void Swap(air_monitor_info* other);
  friend void swap(air_monitor_info& a, air_monitor_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline air_monitor_info* New() const final {
    return CreateMaybeMessage<air_monitor_info>(NULL);
  }

  air_monitor_info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<air_monitor_info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const air_monitor_info& from);
  void MergeFrom(const air_monitor_info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(air_monitor_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes essid = 2;
  bool has_essid() const;
  void clear_essid();
  static const int kEssidFieldNumber = 2;
  const ::std::string& essid() const;
  void set_essid(const ::std::string& value);
  #if LANG_CXX11
  void set_essid(::std::string&& value);
  #endif
  void set_essid(const char* value);
  void set_essid(const void* value, size_t size);
  ::std::string* mutable_essid();
  ::std::string* release_essid();
  void set_allocated_essid(::std::string* essid);

  // optional .ce.nbapi.mac_address monitor_mac = 1;
  bool has_monitor_mac() const;
  void clear_monitor_mac();
  static const int kMonitorMacFieldNumber = 1;
  private:
  const ::ce::nbapi::mac_address& _internal_monitor_mac() const;
  public:
  const ::ce::nbapi::mac_address& monitor_mac() const;
  ::ce::nbapi::mac_address* release_monitor_mac();
  ::ce::nbapi::mac_address* mutable_monitor_mac();
  void set_allocated_monitor_mac(::ce::nbapi::mac_address* monitor_mac);

  // optional .ce.nbapi.mac_address heard_mac = 8;
  bool has_heard_mac() const;
  void clear_heard_mac();
  static const int kHeardMacFieldNumber = 8;
  private:
  const ::ce::nbapi::mac_address& _internal_heard_mac() const;
  public:
  const ::ce::nbapi::mac_address& heard_mac() const;
  ::ce::nbapi::mac_address* release_heard_mac();
  ::ce::nbapi::mac_address* mutable_heard_mac();
  void set_allocated_heard_mac(::ce::nbapi::mac_address* heard_mac);

  // optional .ce.nbapi.mac_address bssid = 9;
  bool has_bssid() const;
  void clear_bssid();
  static const int kBssidFieldNumber = 9;
  private:
  const ::ce::nbapi::mac_address& _internal_bssid() const;
  public:
  const ::ce::nbapi::mac_address& bssid() const;
  ::ce::nbapi::mac_address* release_bssid();
  ::ce::nbapi::mac_address* mutable_bssid();
  void set_allocated_bssid(::ce::nbapi::mac_address* bssid);

  // optional .ce.nbapi.air_monitor_rogue_info am_rogue = 13;
  bool has_am_rogue() const;
  void clear_am_rogue();
  static const int kAmRogueFieldNumber = 13;
  private:
  const ::ce::nbapi::air_monitor_rogue_info& _internal_am_rogue() const;
  public:
  const ::ce::nbapi::air_monitor_rogue_info& am_rogue() const;
  ::ce::nbapi::air_monitor_rogue_info* release_am_rogue();
  ::ce::nbapi::air_monitor_rogue_info* mutable_am_rogue();
  void set_allocated_am_rogue(::ce::nbapi::air_monitor_rogue_info* am_rogue);

  // optional uint32 monitor_channel = 3;
  bool has_monitor_channel() const;
  void clear_monitor_channel();
  static const int kMonitorChannelFieldNumber = 3;
  ::google::protobuf::uint32 monitor_channel() const;
  void set_monitor_channel(::google::protobuf::uint32 value);

  // optional uint32 is_ap = 4;
  bool has_is_ap() const;
  void clear_is_ap();
  static const int kIsApFieldNumber = 4;
  ::google::protobuf::uint32 is_ap() const;
  void set_is_ap(::google::protobuf::uint32 value);

  // optional uint32 classification_type = 5;
  bool has_classification_type() const;
  void clear_classification_type();
  static const int kClassificationTypeFieldNumber = 5;
  ::google::protobuf::uint32 classification_type() const;
  void set_classification_type(::google::protobuf::uint32 value);

  // optional uint32 phy_type = 6;
  bool has_phy_type() const;
  void clear_phy_type();
  static const int kPhyTypeFieldNumber = 6;
  ::google::protobuf::uint32 phy_type() const;
  void set_phy_type(::google::protobuf::uint32 value);

  // optional uint32 ht_type = 7;
  bool has_ht_type() const;
  void clear_ht_type();
  static const int kHtTypeFieldNumber = 7;
  ::google::protobuf::uint32 ht_type() const;
  void set_ht_type(::google::protobuf::uint32 value);

  // optional uint32 encr_type = 10;
  bool has_encr_type() const;
  void clear_encr_type();
  static const int kEncrTypeFieldNumber = 10;
  ::google::protobuf::uint32 encr_type() const;
  void set_encr_type(::google::protobuf::uint32 value);

  // optional uint32 encr_cipher = 11;
  bool has_encr_cipher() const;
  void clear_encr_cipher();
  static const int kEncrCipherFieldNumber = 11;
  ::google::protobuf::uint32 encr_cipher() const;
  void set_encr_cipher(::google::protobuf::uint32 value);

  // optional uint32 auth_alg = 12;
  bool has_auth_alg() const;
  void clear_auth_alg();
  static const int kAuthAlgFieldNumber = 12;
  ::google::protobuf::uint32 auth_alg() const;
  void set_auth_alg(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.air_monitor_info)
 private:
  void set_has_monitor_mac();
  void clear_has_monitor_mac();
  void set_has_essid();
  void clear_has_essid();
  void set_has_monitor_channel();
  void clear_has_monitor_channel();
  void set_has_is_ap();
  void clear_has_is_ap();
  void set_has_classification_type();
  void clear_has_classification_type();
  void set_has_phy_type();
  void clear_has_phy_type();
  void set_has_ht_type();
  void clear_has_ht_type();
  void set_has_heard_mac();
  void clear_has_heard_mac();
  void set_has_bssid();
  void clear_has_bssid();
  void set_has_encr_type();
  void clear_has_encr_type();
  void set_has_encr_cipher();
  void clear_has_encr_cipher();
  void set_has_auth_alg();
  void clear_has_auth_alg();
  void set_has_am_rogue();
  void clear_has_am_rogue();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr essid_;
  ::ce::nbapi::mac_address* monitor_mac_;
  ::ce::nbapi::mac_address* heard_mac_;
  ::ce::nbapi::mac_address* bssid_;
  ::ce::nbapi::air_monitor_rogue_info* am_rogue_;
  ::google::protobuf::uint32 monitor_channel_;
  ::google::protobuf::uint32 is_ap_;
  ::google::protobuf::uint32 classification_type_;
  ::google::protobuf::uint32 phy_type_;
  ::google::protobuf::uint32 ht_type_;
  ::google::protobuf::uint32 encr_type_;
  ::google::protobuf::uint32 encr_cipher_;
  ::google::protobuf::uint32 auth_alg_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class air_monitor_rogue_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ce.nbapi.air_monitor_rogue_info) */ {
 public:
  air_monitor_rogue_info();
  virtual ~air_monitor_rogue_info();

  air_monitor_rogue_info(const air_monitor_rogue_info& from);

  inline air_monitor_rogue_info& operator=(const air_monitor_rogue_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  air_monitor_rogue_info(air_monitor_rogue_info&& from) noexcept
    : air_monitor_rogue_info() {
    *this = ::std::move(from);
  }

  inline air_monitor_rogue_info& operator=(air_monitor_rogue_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const air_monitor_rogue_info& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const air_monitor_rogue_info* internal_default_instance() {
    return reinterpret_cast<const air_monitor_rogue_info*>(
               &_air_monitor_rogue_info_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  void Swap(air_monitor_rogue_info* other);
  friend void swap(air_monitor_rogue_info& a, air_monitor_rogue_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline air_monitor_rogue_info* New() const final {
    return CreateMaybeMessage<air_monitor_rogue_info>(NULL);
  }

  air_monitor_rogue_info* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<air_monitor_rogue_info>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const air_monitor_rogue_info& from);
  void MergeFrom(const air_monitor_rogue_info& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(air_monitor_rogue_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string monitor_name = 4;
  bool has_monitor_name() const;
  void clear_monitor_name();
  static const int kMonitorNameFieldNumber = 4;
  const ::std::string& monitor_name() const;
  void set_monitor_name(const ::std::string& value);
  #if LANG_CXX11
  void set_monitor_name(::std::string&& value);
  #endif
  void set_monitor_name(const char* value);
  void set_monitor_name(const char* value, size_t size);
  ::std::string* mutable_monitor_name();
  ::std::string* release_monitor_name();
  void set_allocated_monitor_name(::std::string* monitor_name);

  // optional .ce.nbapi.mac_address match_mac = 2;
  bool has_match_mac() const;
  void clear_match_mac();
  static const int kMatchMacFieldNumber = 2;
  private:
  const ::ce::nbapi::mac_address& _internal_match_mac() const;
  public:
  const ::ce::nbapi::mac_address& match_mac() const;
  ::ce::nbapi::mac_address* release_match_mac();
  ::ce::nbapi::mac_address* mutable_match_mac();
  void set_allocated_match_mac(::ce::nbapi::mac_address* match_mac);

  // optional .ce.nbapi.ip_address match_ip = 3;
  bool has_match_ip() const;
  void clear_match_ip();
  static const int kMatchIpFieldNumber = 3;
  private:
  const ::ce::nbapi::ip_address& _internal_match_ip() const;
  public:
  const ::ce::nbapi::ip_address& match_ip() const;
  ::ce::nbapi::ip_address* release_match_ip();
  ::ce::nbapi::ip_address* mutable_match_ip();
  void set_allocated_match_ip(::ce::nbapi::ip_address* match_ip);

  // optional uint32 match_type = 1;
  bool has_match_type() const;
  void clear_match_type();
  static const int kMatchTypeFieldNumber = 1;
  ::google::protobuf::uint32 match_type() const;
  void set_match_type(::google::protobuf::uint32 value);

  // optional uint32 nat_match_type = 5;
  bool has_nat_match_type() const;
  void clear_nat_match_type();
  static const int kNatMatchTypeFieldNumber = 5;
  ::google::protobuf::uint32 nat_match_type() const;
  void set_nat_match_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ce.nbapi.air_monitor_rogue_info)
 private:
  void set_has_match_type();
  void clear_has_match_type();
  void set_has_match_mac();
  void clear_has_match_mac();
  void set_has_match_ip();
  void clear_has_match_ip();
  void set_has_monitor_name();
  void clear_has_monitor_name();
  void set_has_nat_match_type();
  void clear_has_nat_match_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr monitor_name_;
  ::ce::nbapi::mac_address* match_mac_;
  ::ce::nbapi::ip_address* match_ip_;
  ::google::protobuf::uint32 match_type_;
  ::google::protobuf::uint32 nat_match_type_;
  friend struct ::protobuf_schema_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ip_address

// required .ce.nbapi.ip_address.addr_family af = 1;
inline bool ip_address::has_af() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ip_address::set_has_af() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ip_address::clear_has_af() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ip_address::clear_af() {
  af_ = 0;
  clear_has_af();
}
inline ::ce::nbapi::ip_address_addr_family ip_address::af() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ip_address.af)
  return static_cast< ::ce::nbapi::ip_address_addr_family >(af_);
}
inline void ip_address::set_af(::ce::nbapi::ip_address_addr_family value) {
  assert(::ce::nbapi::ip_address_addr_family_IsValid(value));
  set_has_af();
  af_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ip_address.af)
}

// required bytes addr = 2;
inline bool ip_address::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ip_address::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ip_address::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ip_address::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_addr();
}
inline const ::std::string& ip_address::addr() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ip_address.addr)
  return addr_.GetNoArena();
}
inline void ip_address::set_addr(const ::std::string& value) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.ip_address.addr)
}
#if LANG_CXX11
inline void ip_address::set_addr(::std::string&& value) {
  set_has_addr();
  addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.ip_address.addr)
}
#endif
inline void ip_address::set_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.ip_address.addr)
}
inline void ip_address::set_addr(const void* value, size_t size) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.ip_address.addr)
}
inline ::std::string* ip_address::mutable_addr() {
  set_has_addr();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ip_address.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ip_address::release_addr() {
  // @@protoc_insertion_point(field_release:ce.nbapi.ip_address.addr)
  if (!has_addr()) {
    return NULL;
  }
  clear_has_addr();
  return addr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ip_address::set_allocated_addr(::std::string* addr) {
  if (addr != NULL) {
    set_has_addr();
  } else {
    clear_has_addr();
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.ip_address.addr)
}

// -------------------------------------------------------------------

// mac_address

// required bytes addr = 1;
inline bool mac_address::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mac_address::set_has_addr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mac_address::clear_has_addr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mac_address::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_addr();
}
inline const ::std::string& mac_address::addr() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.mac_address.addr)
  return addr_.GetNoArena();
}
inline void mac_address::set_addr(const ::std::string& value) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.mac_address.addr)
}
#if LANG_CXX11
inline void mac_address::set_addr(::std::string&& value) {
  set_has_addr();
  addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.mac_address.addr)
}
#endif
inline void mac_address::set_addr(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.mac_address.addr)
}
inline void mac_address::set_addr(const void* value, size_t size) {
  set_has_addr();
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.mac_address.addr)
}
inline ::std::string* mac_address::mutable_addr() {
  set_has_addr();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.mac_address.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* mac_address::release_addr() {
  // @@protoc_insertion_point(field_release:ce.nbapi.mac_address.addr)
  if (!has_addr()) {
    return NULL;
  }
  clear_has_addr();
  return addr_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void mac_address::set_allocated_addr(::std::string* addr) {
  if (addr != NULL) {
    set_has_addr();
  } else {
    clear_has_addr();
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.mac_address.addr)
}

// -------------------------------------------------------------------

// data_rate_stats

// optional uint32 rate = 1;
inline bool data_rate_stats::has_rate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void data_rate_stats::set_has_rate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void data_rate_stats::clear_has_rate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void data_rate_stats::clear_rate() {
  rate_ = 0u;
  clear_has_rate();
}
inline ::google::protobuf::uint32 data_rate_stats::rate() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.data_rate_stats.rate)
  return rate_;
}
inline void data_rate_stats::set_rate(::google::protobuf::uint32 value) {
  set_has_rate();
  rate_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.data_rate_stats.rate)
}

// optional uint32 tx_frame_count = 2;
inline bool data_rate_stats::has_tx_frame_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void data_rate_stats::set_has_tx_frame_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void data_rate_stats::clear_has_tx_frame_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void data_rate_stats::clear_tx_frame_count() {
  tx_frame_count_ = 0u;
  clear_has_tx_frame_count();
}
inline ::google::protobuf::uint32 data_rate_stats::tx_frame_count() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.data_rate_stats.tx_frame_count)
  return tx_frame_count_;
}
inline void data_rate_stats::set_tx_frame_count(::google::protobuf::uint32 value) {
  set_has_tx_frame_count();
  tx_frame_count_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.data_rate_stats.tx_frame_count)
}

// optional uint32 tx_byte_count = 3;
inline bool data_rate_stats::has_tx_byte_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void data_rate_stats::set_has_tx_byte_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void data_rate_stats::clear_has_tx_byte_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void data_rate_stats::clear_tx_byte_count() {
  tx_byte_count_ = 0u;
  clear_has_tx_byte_count();
}
inline ::google::protobuf::uint32 data_rate_stats::tx_byte_count() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.data_rate_stats.tx_byte_count)
  return tx_byte_count_;
}
inline void data_rate_stats::set_tx_byte_count(::google::protobuf::uint32 value) {
  set_has_tx_byte_count();
  tx_byte_count_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.data_rate_stats.tx_byte_count)
}

// optional uint32 rx_frame_count = 4;
inline bool data_rate_stats::has_rx_frame_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void data_rate_stats::set_has_rx_frame_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void data_rate_stats::clear_has_rx_frame_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void data_rate_stats::clear_rx_frame_count() {
  rx_frame_count_ = 0u;
  clear_has_rx_frame_count();
}
inline ::google::protobuf::uint32 data_rate_stats::rx_frame_count() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.data_rate_stats.rx_frame_count)
  return rx_frame_count_;
}
inline void data_rate_stats::set_rx_frame_count(::google::protobuf::uint32 value) {
  set_has_rx_frame_count();
  rx_frame_count_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.data_rate_stats.rx_frame_count)
}

// optional uint32 rx_byte_count = 5;
inline bool data_rate_stats::has_rx_byte_count() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void data_rate_stats::set_has_rx_byte_count() {
  _has_bits_[0] |= 0x00000010u;
}
inline void data_rate_stats::clear_has_rx_byte_count() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void data_rate_stats::clear_rx_byte_count() {
  rx_byte_count_ = 0u;
  clear_has_rx_byte_count();
}
inline ::google::protobuf::uint32 data_rate_stats::rx_byte_count() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.data_rate_stats.rx_byte_count)
  return rx_byte_count_;
}
inline void data_rate_stats::set_rx_byte_count(::google::protobuf::uint32 value) {
  set_has_rx_byte_count();
  rx_byte_count_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.data_rate_stats.rx_byte_count)
}

// -------------------------------------------------------------------

// data_prio_stats

// optional .ce.nbapi.data_prio prio = 1;
inline bool data_prio_stats::has_prio() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void data_prio_stats::set_has_prio() {
  _has_bits_[0] |= 0x00000001u;
}
inline void data_prio_stats::clear_has_prio() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void data_prio_stats::clear_prio() {
  prio_ = 0;
  clear_has_prio();
}
inline ::ce::nbapi::data_prio data_prio_stats::prio() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.data_prio_stats.prio)
  return static_cast< ::ce::nbapi::data_prio >(prio_);
}
inline void data_prio_stats::set_prio(::ce::nbapi::data_prio value) {
  assert(::ce::nbapi::data_prio_IsValid(value));
  set_has_prio();
  prio_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.data_prio_stats.prio)
}

// optional uint32 tx_frame_count = 2;
inline bool data_prio_stats::has_tx_frame_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void data_prio_stats::set_has_tx_frame_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void data_prio_stats::clear_has_tx_frame_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void data_prio_stats::clear_tx_frame_count() {
  tx_frame_count_ = 0u;
  clear_has_tx_frame_count();
}
inline ::google::protobuf::uint32 data_prio_stats::tx_frame_count() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.data_prio_stats.tx_frame_count)
  return tx_frame_count_;
}
inline void data_prio_stats::set_tx_frame_count(::google::protobuf::uint32 value) {
  set_has_tx_frame_count();
  tx_frame_count_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.data_prio_stats.tx_frame_count)
}

// optional uint32 rx_frame_count = 3;
inline bool data_prio_stats::has_rx_frame_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void data_prio_stats::set_has_rx_frame_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void data_prio_stats::clear_has_rx_frame_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void data_prio_stats::clear_rx_frame_count() {
  rx_frame_count_ = 0u;
  clear_has_rx_frame_count();
}
inline ::google::protobuf::uint32 data_prio_stats::rx_frame_count() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.data_prio_stats.rx_frame_count)
  return rx_frame_count_;
}
inline void data_prio_stats::set_rx_frame_count(::google::protobuf::uint32 value) {
  set_has_rx_frame_count();
  rx_frame_count_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.data_prio_stats.rx_frame_count)
}

// optional uint32 tx_drop_count = 4;
inline bool data_prio_stats::has_tx_drop_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void data_prio_stats::set_has_tx_drop_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void data_prio_stats::clear_has_tx_drop_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void data_prio_stats::clear_tx_drop_count() {
  tx_drop_count_ = 0u;
  clear_has_tx_drop_count();
}
inline ::google::protobuf::uint32 data_prio_stats::tx_drop_count() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.data_prio_stats.tx_drop_count)
  return tx_drop_count_;
}
inline void data_prio_stats::set_tx_drop_count(::google::protobuf::uint32 value) {
  set_has_tx_drop_count();
  tx_drop_count_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.data_prio_stats.tx_drop_count)
}

// -------------------------------------------------------------------

// data_traffic_type_stats

// optional .ce.nbapi.traffic_type type = 1;
inline bool data_traffic_type_stats::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void data_traffic_type_stats::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void data_traffic_type_stats::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void data_traffic_type_stats::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ce::nbapi::traffic_type data_traffic_type_stats::type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.data_traffic_type_stats.type)
  return static_cast< ::ce::nbapi::traffic_type >(type_);
}
inline void data_traffic_type_stats::set_type(::ce::nbapi::traffic_type value) {
  assert(::ce::nbapi::traffic_type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.data_traffic_type_stats.type)
}

// optional uint32 tx_frame_count = 2;
inline bool data_traffic_type_stats::has_tx_frame_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void data_traffic_type_stats::set_has_tx_frame_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void data_traffic_type_stats::clear_has_tx_frame_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void data_traffic_type_stats::clear_tx_frame_count() {
  tx_frame_count_ = 0u;
  clear_has_tx_frame_count();
}
inline ::google::protobuf::uint32 data_traffic_type_stats::tx_frame_count() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.data_traffic_type_stats.tx_frame_count)
  return tx_frame_count_;
}
inline void data_traffic_type_stats::set_tx_frame_count(::google::protobuf::uint32 value) {
  set_has_tx_frame_count();
  tx_frame_count_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.data_traffic_type_stats.tx_frame_count)
}

// optional uint32 rx_frame_count = 3;
inline bool data_traffic_type_stats::has_rx_frame_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void data_traffic_type_stats::set_has_rx_frame_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void data_traffic_type_stats::clear_has_rx_frame_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void data_traffic_type_stats::clear_rx_frame_count() {
  rx_frame_count_ = 0u;
  clear_has_rx_frame_count();
}
inline ::google::protobuf::uint32 data_traffic_type_stats::rx_frame_count() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.data_traffic_type_stats.rx_frame_count)
  return rx_frame_count_;
}
inline void data_traffic_type_stats::set_rx_frame_count(::google::protobuf::uint32 value) {
  set_has_rx_frame_count();
  rx_frame_count_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.data_traffic_type_stats.rx_frame_count)
}

// -------------------------------------------------------------------

// ap_neighbor

// optional .ce.nbapi.mac_address ap_eth_mac = 1;
inline bool ap_neighbor::has_ap_eth_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ap_neighbor::set_has_ap_eth_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ap_neighbor::clear_has_ap_eth_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ap_neighbor::clear_ap_eth_mac() {
  if (ap_eth_mac_ != NULL) ap_eth_mac_->Clear();
  clear_has_ap_eth_mac();
}
inline const ::ce::nbapi::mac_address& ap_neighbor::_internal_ap_eth_mac() const {
  return *ap_eth_mac_;
}
inline const ::ce::nbapi::mac_address& ap_neighbor::ap_eth_mac() const {
  const ::ce::nbapi::mac_address* p = ap_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_neighbor.ap_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* ap_neighbor::release_ap_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.ap_neighbor.ap_eth_mac)
  clear_has_ap_eth_mac();
  ::ce::nbapi::mac_address* temp = ap_eth_mac_;
  ap_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* ap_neighbor::mutable_ap_eth_mac() {
  set_has_ap_eth_mac();
  if (ap_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ap_neighbor.ap_eth_mac)
  return ap_eth_mac_;
}
inline void ap_neighbor::set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_eth_mac_;
  }
  if (ap_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_eth_mac, submessage_arena);
    }
    set_has_ap_eth_mac();
  } else {
    clear_has_ap_eth_mac();
  }
  ap_eth_mac_ = ap_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.ap_neighbor.ap_eth_mac)
}

// optional .ce.nbapi.mac_address bssid = 2;
inline bool ap_neighbor::has_bssid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ap_neighbor::set_has_bssid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ap_neighbor::clear_has_bssid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ap_neighbor::clear_bssid() {
  if (bssid_ != NULL) bssid_->Clear();
  clear_has_bssid();
}
inline const ::ce::nbapi::mac_address& ap_neighbor::_internal_bssid() const {
  return *bssid_;
}
inline const ::ce::nbapi::mac_address& ap_neighbor::bssid() const {
  const ::ce::nbapi::mac_address* p = bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_neighbor.bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* ap_neighbor::release_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.ap_neighbor.bssid)
  clear_has_bssid();
  ::ce::nbapi::mac_address* temp = bssid_;
  bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* ap_neighbor::mutable_bssid() {
  set_has_bssid();
  if (bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ap_neighbor.bssid)
  return bssid_;
}
inline void ap_neighbor::set_allocated_bssid(::ce::nbapi::mac_address* bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bssid_;
  }
  if (bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bssid, submessage_arena);
    }
    set_has_bssid();
  } else {
    clear_has_bssid();
  }
  bssid_ = bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.ap_neighbor.bssid)
}

// optional .ce.nbapi.phy_type phy = 3;
inline bool ap_neighbor::has_phy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ap_neighbor::set_has_phy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ap_neighbor::clear_has_phy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ap_neighbor::clear_phy() {
  phy_ = 0;
  clear_has_phy();
}
inline ::ce::nbapi::phy_type ap_neighbor::phy() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_neighbor.phy)
  return static_cast< ::ce::nbapi::phy_type >(phy_);
}
inline void ap_neighbor::set_phy(::ce::nbapi::phy_type value) {
  assert(::ce::nbapi::phy_type_IsValid(value));
  set_has_phy();
  phy_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_neighbor.phy)
}

// optional .ce.nbapi.mac_address neighbor_bssid = 4;
inline bool ap_neighbor::has_neighbor_bssid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ap_neighbor::set_has_neighbor_bssid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ap_neighbor::clear_has_neighbor_bssid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ap_neighbor::clear_neighbor_bssid() {
  if (neighbor_bssid_ != NULL) neighbor_bssid_->Clear();
  clear_has_neighbor_bssid();
}
inline const ::ce::nbapi::mac_address& ap_neighbor::_internal_neighbor_bssid() const {
  return *neighbor_bssid_;
}
inline const ::ce::nbapi::mac_address& ap_neighbor::neighbor_bssid() const {
  const ::ce::nbapi::mac_address* p = neighbor_bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_neighbor.neighbor_bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* ap_neighbor::release_neighbor_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.ap_neighbor.neighbor_bssid)
  clear_has_neighbor_bssid();
  ::ce::nbapi::mac_address* temp = neighbor_bssid_;
  neighbor_bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* ap_neighbor::mutable_neighbor_bssid() {
  set_has_neighbor_bssid();
  if (neighbor_bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    neighbor_bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ap_neighbor.neighbor_bssid)
  return neighbor_bssid_;
}
inline void ap_neighbor::set_allocated_neighbor_bssid(::ce::nbapi::mac_address* neighbor_bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete neighbor_bssid_;
  }
  if (neighbor_bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      neighbor_bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, neighbor_bssid, submessage_arena);
    }
    set_has_neighbor_bssid();
  } else {
    clear_has_neighbor_bssid();
  }
  neighbor_bssid_ = neighbor_bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.ap_neighbor.neighbor_bssid)
}

// optional string neighbor_ssid = 5;
inline bool ap_neighbor::has_neighbor_ssid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ap_neighbor::set_has_neighbor_ssid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ap_neighbor::clear_has_neighbor_ssid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ap_neighbor::clear_neighbor_ssid() {
  neighbor_ssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_neighbor_ssid();
}
inline const ::std::string& ap_neighbor::neighbor_ssid() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_neighbor.neighbor_ssid)
  return neighbor_ssid_.GetNoArena();
}
inline void ap_neighbor::set_neighbor_ssid(const ::std::string& value) {
  set_has_neighbor_ssid();
  neighbor_ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_neighbor.neighbor_ssid)
}
#if LANG_CXX11
inline void ap_neighbor::set_neighbor_ssid(::std::string&& value) {
  set_has_neighbor_ssid();
  neighbor_ssid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.ap_neighbor.neighbor_ssid)
}
#endif
inline void ap_neighbor::set_neighbor_ssid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_neighbor_ssid();
  neighbor_ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.ap_neighbor.neighbor_ssid)
}
inline void ap_neighbor::set_neighbor_ssid(const char* value, size_t size) {
  set_has_neighbor_ssid();
  neighbor_ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.ap_neighbor.neighbor_ssid)
}
inline ::std::string* ap_neighbor::mutable_neighbor_ssid() {
  set_has_neighbor_ssid();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ap_neighbor.neighbor_ssid)
  return neighbor_ssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ap_neighbor::release_neighbor_ssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.ap_neighbor.neighbor_ssid)
  if (!has_neighbor_ssid()) {
    return NULL;
  }
  clear_has_neighbor_ssid();
  return neighbor_ssid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ap_neighbor::set_allocated_neighbor_ssid(::std::string* neighbor_ssid) {
  if (neighbor_ssid != NULL) {
    set_has_neighbor_ssid();
  } else {
    clear_has_neighbor_ssid();
  }
  neighbor_ssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), neighbor_ssid);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.ap_neighbor.neighbor_ssid)
}

// optional .ce.nbapi.ap_neighbor.network_type neighbor_network = 6;
inline bool ap_neighbor::has_neighbor_network() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ap_neighbor::set_has_neighbor_network() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ap_neighbor::clear_has_neighbor_network() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ap_neighbor::clear_neighbor_network() {
  neighbor_network_ = 0;
  clear_has_neighbor_network();
}
inline ::ce::nbapi::ap_neighbor_network_type ap_neighbor::neighbor_network() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_neighbor.neighbor_network)
  return static_cast< ::ce::nbapi::ap_neighbor_network_type >(neighbor_network_);
}
inline void ap_neighbor::set_neighbor_network(::ce::nbapi::ap_neighbor_network_type value) {
  assert(::ce::nbapi::ap_neighbor_network_type_IsValid(value));
  set_has_neighbor_network();
  neighbor_network_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_neighbor.neighbor_network)
}

// optional uint32 neighbor_channel = 7;
inline bool ap_neighbor::has_neighbor_channel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ap_neighbor::set_has_neighbor_channel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ap_neighbor::clear_has_neighbor_channel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ap_neighbor::clear_neighbor_channel() {
  neighbor_channel_ = 0u;
  clear_has_neighbor_channel();
}
inline ::google::protobuf::uint32 ap_neighbor::neighbor_channel() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_neighbor.neighbor_channel)
  return neighbor_channel_;
}
inline void ap_neighbor::set_neighbor_channel(::google::protobuf::uint32 value) {
  set_has_neighbor_channel();
  neighbor_channel_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_neighbor.neighbor_channel)
}

// optional uint32 neighbor_rssi = 10;
inline bool ap_neighbor::has_neighbor_rssi() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ap_neighbor::set_has_neighbor_rssi() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ap_neighbor::clear_has_neighbor_rssi() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ap_neighbor::clear_neighbor_rssi() {
  neighbor_rssi_ = 0u;
  clear_has_neighbor_rssi();
}
inline ::google::protobuf::uint32 ap_neighbor::neighbor_rssi() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_neighbor.neighbor_rssi)
  return neighbor_rssi_;
}
inline void ap_neighbor::set_neighbor_rssi(::google::protobuf::uint32 value) {
  set_has_neighbor_rssi();
  neighbor_rssi_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_neighbor.neighbor_rssi)
}

// -------------------------------------------------------------------

// util_stats

// optional .ce.nbapi.util_stats.util_stat_type type = 1;
inline bool util_stats::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void util_stats::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void util_stats::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void util_stats::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::ce::nbapi::util_stats_util_stat_type util_stats::type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.util_stats.type)
  return static_cast< ::ce::nbapi::util_stats_util_stat_type >(type_);
}
inline void util_stats::set_type(::ce::nbapi::util_stats_util_stat_type value) {
  assert(::ce::nbapi::util_stats_util_stat_type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.util_stats.type)
}

// optional uint32 bucket1 = 2;
inline bool util_stats::has_bucket1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void util_stats::set_has_bucket1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void util_stats::clear_has_bucket1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void util_stats::clear_bucket1() {
  bucket1_ = 0u;
  clear_has_bucket1();
}
inline ::google::protobuf::uint32 util_stats::bucket1() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.util_stats.bucket1)
  return bucket1_;
}
inline void util_stats::set_bucket1(::google::protobuf::uint32 value) {
  set_has_bucket1();
  bucket1_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.util_stats.bucket1)
}

// optional uint32 bucket2 = 3;
inline bool util_stats::has_bucket2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void util_stats::set_has_bucket2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void util_stats::clear_has_bucket2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void util_stats::clear_bucket2() {
  bucket2_ = 0u;
  clear_has_bucket2();
}
inline ::google::protobuf::uint32 util_stats::bucket2() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.util_stats.bucket2)
  return bucket2_;
}
inline void util_stats::set_bucket2(::google::protobuf::uint32 value) {
  set_has_bucket2();
  bucket2_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.util_stats.bucket2)
}

// optional uint32 bucket3 = 4;
inline bool util_stats::has_bucket3() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void util_stats::set_has_bucket3() {
  _has_bits_[0] |= 0x00000008u;
}
inline void util_stats::clear_has_bucket3() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void util_stats::clear_bucket3() {
  bucket3_ = 0u;
  clear_has_bucket3();
}
inline ::google::protobuf::uint32 util_stats::bucket3() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.util_stats.bucket3)
  return bucket3_;
}
inline void util_stats::set_bucket3(::google::protobuf::uint32 value) {
  set_has_bucket3();
  bucket3_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.util_stats.bucket3)
}

// optional uint32 bucket4 = 5;
inline bool util_stats::has_bucket4() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void util_stats::set_has_bucket4() {
  _has_bits_[0] |= 0x00000010u;
}
inline void util_stats::clear_has_bucket4() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void util_stats::clear_bucket4() {
  bucket4_ = 0u;
  clear_has_bucket4();
}
inline ::google::protobuf::uint32 util_stats::bucket4() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.util_stats.bucket4)
  return bucket4_;
}
inline void util_stats::set_bucket4(::google::protobuf::uint32 value) {
  set_has_bucket4();
  bucket4_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.util_stats.bucket4)
}

// optional uint32 bucket5 = 6;
inline bool util_stats::has_bucket5() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void util_stats::set_has_bucket5() {
  _has_bits_[0] |= 0x00000020u;
}
inline void util_stats::clear_has_bucket5() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void util_stats::clear_bucket5() {
  bucket5_ = 0u;
  clear_has_bucket5();
}
inline ::google::protobuf::uint32 util_stats::bucket5() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.util_stats.bucket5)
  return bucket5_;
}
inline void util_stats::set_bucket5(::google::protobuf::uint32 value) {
  set_has_bucket5();
  bucket5_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.util_stats.bucket5)
}

// optional uint32 max = 7;
inline bool util_stats::has_max() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void util_stats::set_has_max() {
  _has_bits_[0] |= 0x00000040u;
}
inline void util_stats::clear_has_max() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void util_stats::clear_max() {
  max_ = 0u;
  clear_has_max();
}
inline ::google::protobuf::uint32 util_stats::max() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.util_stats.max)
  return max_;
}
inline void util_stats::set_max(::google::protobuf::uint32 value) {
  set_has_max();
  max_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.util_stats.max)
}

// optional uint32 min = 8;
inline bool util_stats::has_min() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void util_stats::set_has_min() {
  _has_bits_[0] |= 0x00000080u;
}
inline void util_stats::clear_has_min() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void util_stats::clear_min() {
  min_ = 0u;
  clear_has_min();
}
inline ::google::protobuf::uint32 util_stats::min() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.util_stats.min)
  return min_;
}
inline void util_stats::set_min(::google::protobuf::uint32 value) {
  set_has_min();
  min_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.util_stats.min)
}

// optional uint32 curr = 9;
inline bool util_stats::has_curr() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void util_stats::set_has_curr() {
  _has_bits_[0] |= 0x00000200u;
}
inline void util_stats::clear_has_curr() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void util_stats::clear_curr() {
  curr_ = 0u;
  clear_has_curr();
}
inline ::google::protobuf::uint32 util_stats::curr() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.util_stats.curr)
  return curr_;
}
inline void util_stats::set_curr(::google::protobuf::uint32 value) {
  set_has_curr();
  curr_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.util_stats.curr)
}

// optional uint64 stat = 10;
inline bool util_stats::has_stat() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void util_stats::set_has_stat() {
  _has_bits_[0] |= 0x00000100u;
}
inline void util_stats::clear_has_stat() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void util_stats::clear_stat() {
  stat_ = GOOGLE_ULONGLONG(0);
  clear_has_stat();
}
inline ::google::protobuf::uint64 util_stats::stat() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.util_stats.stat)
  return stat_;
}
inline void util_stats::set_stat(::google::protobuf::uint64 value) {
  set_has_stat();
  stat_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.util_stats.stat)
}

// -------------------------------------------------------------------

// location_record

// required uint32 timestamp = 1;
inline bool location_record::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void location_record::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void location_record::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void location_record::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 location_record::timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.record.timestamp)
  return timestamp_;
}
inline void location_record::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.record.timestamp)
}

// required .ce.nbapi.mac_address radio_mac = 2;
inline bool location_record::has_radio_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void location_record::set_has_radio_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void location_record::clear_has_radio_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void location_record::clear_radio_mac() {
  if (radio_mac_ != NULL) radio_mac_->Clear();
  clear_has_radio_mac();
}
inline const ::ce::nbapi::mac_address& location_record::_internal_radio_mac() const {
  return *radio_mac_;
}
inline const ::ce::nbapi::mac_address& location_record::radio_mac() const {
  const ::ce::nbapi::mac_address* p = radio_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.location.record.radio_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* location_record::release_radio_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.location.record.radio_mac)
  clear_has_radio_mac();
  ::ce::nbapi::mac_address* temp = radio_mac_;
  radio_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* location_record::mutable_radio_mac() {
  set_has_radio_mac();
  if (radio_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    radio_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.location.record.radio_mac)
  return radio_mac_;
}
inline void location_record::set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radio_mac_;
  }
  if (radio_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radio_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radio_mac, submessage_arena);
    }
    set_has_radio_mac();
  } else {
    clear_has_radio_mac();
  }
  radio_mac_ = radio_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.location.record.radio_mac)
}

// required int32 rssi_val = 3;
inline bool location_record::has_rssi_val() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void location_record::set_has_rssi_val() {
  _has_bits_[0] |= 0x00000004u;
}
inline void location_record::clear_has_rssi_val() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void location_record::clear_rssi_val() {
  rssi_val_ = 0;
  clear_has_rssi_val();
}
inline ::google::protobuf::int32 location_record::rssi_val() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.record.rssi_val)
  return rssi_val_;
}
inline void location_record::set_rssi_val(::google::protobuf::int32 value) {
  set_has_rssi_val();
  rssi_val_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.record.rssi_val)
}

// optional uint32 channel = 4;
inline bool location_record::has_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void location_record::set_has_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void location_record::clear_has_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void location_record::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 location_record::channel() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.record.channel)
  return channel_;
}
inline void location_record::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.record.channel)
}

// -------------------------------------------------------------------

// location_rtls_tag

// optional uint32 battery = 1;
inline bool location_rtls_tag::has_battery() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void location_rtls_tag::set_has_battery() {
  _has_bits_[0] |= 0x00000002u;
}
inline void location_rtls_tag::clear_has_battery() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void location_rtls_tag::clear_battery() {
  battery_ = 0u;
  clear_has_battery();
}
inline ::google::protobuf::uint32 location_rtls_tag::battery() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.rtls_tag.battery)
  return battery_;
}
inline void location_rtls_tag::set_battery(::google::protobuf::uint32 value) {
  set_has_battery();
  battery_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.rtls_tag.battery)
}

// optional uint32 channel = 2;
inline bool location_rtls_tag::has_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void location_rtls_tag::set_has_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void location_rtls_tag::clear_has_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void location_rtls_tag::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 location_rtls_tag::channel() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.rtls_tag.channel)
  return channel_;
}
inline void location_rtls_tag::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.rtls_tag.channel)
}

// optional uint32 tx_power = 3;
inline bool location_rtls_tag::has_tx_power() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void location_rtls_tag::set_has_tx_power() {
  _has_bits_[0] |= 0x00000008u;
}
inline void location_rtls_tag::clear_has_tx_power() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void location_rtls_tag::clear_tx_power() {
  tx_power_ = 0u;
  clear_has_tx_power();
}
inline ::google::protobuf::uint32 location_rtls_tag::tx_power() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.rtls_tag.tx_power)
  return tx_power_;
}
inline void location_rtls_tag::set_tx_power(::google::protobuf::uint32 value) {
  set_has_tx_power();
  tx_power_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.rtls_tag.tx_power)
}

// optional uint32 data_rate = 4;
inline bool location_rtls_tag::has_data_rate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void location_rtls_tag::set_has_data_rate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void location_rtls_tag::clear_has_data_rate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void location_rtls_tag::clear_data_rate() {
  data_rate_ = 0u;
  clear_has_data_rate();
}
inline ::google::protobuf::uint32 location_rtls_tag::data_rate() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.rtls_tag.data_rate)
  return data_rate_;
}
inline void location_rtls_tag::set_data_rate(::google::protobuf::uint32 value) {
  set_has_data_rate();
  data_rate_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.rtls_tag.data_rate)
}

// optional bytes payload = 5;
inline bool location_rtls_tag::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void location_rtls_tag::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void location_rtls_tag::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void location_rtls_tag::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& location_rtls_tag::payload() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.rtls_tag.payload)
  return payload_.GetNoArena();
}
inline void location_rtls_tag::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.location.rtls_tag.payload)
}
#if LANG_CXX11
inline void location_rtls_tag::set_payload(::std::string&& value) {
  set_has_payload();
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.location.rtls_tag.payload)
}
#endif
inline void location_rtls_tag::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.location.rtls_tag.payload)
}
inline void location_rtls_tag::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.location.rtls_tag.payload)
}
inline ::std::string* location_rtls_tag::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.location.rtls_tag.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* location_rtls_tag::release_payload() {
  // @@protoc_insertion_point(field_release:ce.nbapi.location.rtls_tag.payload)
  if (!has_payload()) {
    return NULL;
  }
  clear_has_payload();
  return payload_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void location_rtls_tag::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.location.rtls_tag.payload)
}

// -------------------------------------------------------------------

// location

// optional .ce.nbapi.mac_address sta_eth_mac = 1;
inline bool location::has_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void location::set_has_sta_eth_mac() {
  _has_bits_[0] |= 0x00000010u;
}
inline void location::clear_has_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void location::clear_sta_eth_mac() {
  if (sta_eth_mac_ != NULL) sta_eth_mac_->Clear();
  clear_has_sta_eth_mac();
}
inline const ::ce::nbapi::mac_address& location::_internal_sta_eth_mac() const {
  return *sta_eth_mac_;
}
inline const ::ce::nbapi::mac_address& location::sta_eth_mac() const {
  const ::ce::nbapi::mac_address* p = sta_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.location.sta_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* location::release_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.location.sta_eth_mac)
  clear_has_sta_eth_mac();
  ::ce::nbapi::mac_address* temp = sta_eth_mac_;
  sta_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* location::mutable_sta_eth_mac() {
  set_has_sta_eth_mac();
  if (sta_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    sta_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.location.sta_eth_mac)
  return sta_eth_mac_;
}
inline void location::set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sta_eth_mac_;
  }
  if (sta_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sta_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sta_eth_mac, submessage_arena);
    }
    set_has_sta_eth_mac();
  } else {
    clear_has_sta_eth_mac();
  }
  sta_eth_mac_ = sta_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.location.sta_eth_mac)
}

// optional float sta_location_x = 2;
inline bool location::has_sta_location_x() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void location::set_has_sta_location_x() {
  _has_bits_[0] |= 0x00000020u;
}
inline void location::clear_has_sta_location_x() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void location::clear_sta_location_x() {
  sta_location_x_ = 0;
  clear_has_sta_location_x();
}
inline float location::sta_location_x() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.sta_location_x)
  return sta_location_x_;
}
inline void location::set_sta_location_x(float value) {
  set_has_sta_location_x();
  sta_location_x_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.sta_location_x)
}

// optional float sta_location_y = 3;
inline bool location::has_sta_location_y() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void location::set_has_sta_location_y() {
  _has_bits_[0] |= 0x00000040u;
}
inline void location::clear_has_sta_location_y() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void location::clear_sta_location_y() {
  sta_location_y_ = 0;
  clear_has_sta_location_y();
}
inline float location::sta_location_y() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.sta_location_y)
  return sta_location_y_;
}
inline void location::set_sta_location_y(float value) {
  set_has_sta_location_y();
  sta_location_y_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.sta_location_y)
}

// optional uint32 error_level = 7;
inline bool location::has_error_level() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void location::set_has_error_level() {
  _has_bits_[0] |= 0x00000080u;
}
inline void location::clear_has_error_level() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void location::clear_error_level() {
  error_level_ = 0u;
  clear_has_error_level();
}
inline ::google::protobuf::uint32 location::error_level() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.error_level)
  return error_level_;
}
inline void location::set_error_level(::google::protobuf::uint32 value) {
  set_has_error_level();
  error_level_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.error_level)
}

// optional bool associated = 8;
inline bool location::has_associated() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void location::set_has_associated() {
  _has_bits_[0] |= 0x00000800u;
}
inline void location::clear_has_associated() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void location::clear_associated() {
  associated_ = false;
  clear_has_associated();
}
inline bool location::associated() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.associated)
  return associated_;
}
inline void location::set_associated(bool value) {
  set_has_associated();
  associated_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.associated)
}

// optional bytes campus_id = 9;
inline bool location::has_campus_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void location::set_has_campus_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void location::clear_has_campus_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void location::clear_campus_id() {
  campus_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_campus_id();
}
inline const ::std::string& location::campus_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.campus_id)
  return campus_id_.GetNoArena();
}
inline void location::set_campus_id(const ::std::string& value) {
  set_has_campus_id();
  campus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.location.campus_id)
}
#if LANG_CXX11
inline void location::set_campus_id(::std::string&& value) {
  set_has_campus_id();
  campus_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.location.campus_id)
}
#endif
inline void location::set_campus_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_campus_id();
  campus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.location.campus_id)
}
inline void location::set_campus_id(const void* value, size_t size) {
  set_has_campus_id();
  campus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.location.campus_id)
}
inline ::std::string* location::mutable_campus_id() {
  set_has_campus_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.location.campus_id)
  return campus_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* location::release_campus_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.location.campus_id)
  if (!has_campus_id()) {
    return NULL;
  }
  clear_has_campus_id();
  return campus_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void location::set_allocated_campus_id(::std::string* campus_id) {
  if (campus_id != NULL) {
    set_has_campus_id();
  } else {
    clear_has_campus_id();
  }
  campus_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), campus_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.location.campus_id)
}

// optional bytes building_id = 10;
inline bool location::has_building_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void location::set_has_building_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void location::clear_has_building_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void location::clear_building_id() {
  building_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_building_id();
}
inline const ::std::string& location::building_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.building_id)
  return building_id_.GetNoArena();
}
inline void location::set_building_id(const ::std::string& value) {
  set_has_building_id();
  building_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.location.building_id)
}
#if LANG_CXX11
inline void location::set_building_id(::std::string&& value) {
  set_has_building_id();
  building_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.location.building_id)
}
#endif
inline void location::set_building_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_building_id();
  building_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.location.building_id)
}
inline void location::set_building_id(const void* value, size_t size) {
  set_has_building_id();
  building_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.location.building_id)
}
inline ::std::string* location::mutable_building_id() {
  set_has_building_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.location.building_id)
  return building_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* location::release_building_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.location.building_id)
  if (!has_building_id()) {
    return NULL;
  }
  clear_has_building_id();
  return building_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void location::set_allocated_building_id(::std::string* building_id) {
  if (building_id != NULL) {
    set_has_building_id();
  } else {
    clear_has_building_id();
  }
  building_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), building_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.location.building_id)
}

// optional bytes floor_id = 11;
inline bool location::has_floor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void location::set_has_floor_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void location::clear_has_floor_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void location::clear_floor_id() {
  floor_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_floor_id();
}
inline const ::std::string& location::floor_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.floor_id)
  return floor_id_.GetNoArena();
}
inline void location::set_floor_id(const ::std::string& value) {
  set_has_floor_id();
  floor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.location.floor_id)
}
#if LANG_CXX11
inline void location::set_floor_id(::std::string&& value) {
  set_has_floor_id();
  floor_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.location.floor_id)
}
#endif
inline void location::set_floor_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_floor_id();
  floor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.location.floor_id)
}
inline void location::set_floor_id(const void* value, size_t size) {
  set_has_floor_id();
  floor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.location.floor_id)
}
inline ::std::string* location::mutable_floor_id() {
  set_has_floor_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.location.floor_id)
  return floor_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* location::release_floor_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.location.floor_id)
  if (!has_floor_id()) {
    return NULL;
  }
  clear_has_floor_id();
  return floor_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void location::set_allocated_floor_id(::std::string* floor_id) {
  if (floor_id != NULL) {
    set_has_floor_id();
  } else {
    clear_has_floor_id();
  }
  floor_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), floor_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.location.floor_id)
}

// optional bytes hashed_sta_eth_mac = 12;
inline bool location::has_hashed_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void location::set_has_hashed_sta_eth_mac() {
  _has_bits_[0] |= 0x00000008u;
}
inline void location::clear_has_hashed_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void location::clear_hashed_sta_eth_mac() {
  hashed_sta_eth_mac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hashed_sta_eth_mac();
}
inline const ::std::string& location::hashed_sta_eth_mac() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.GetNoArena();
}
inline void location::set_hashed_sta_eth_mac(const ::std::string& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.location.hashed_sta_eth_mac)
}
#if LANG_CXX11
inline void location::set_hashed_sta_eth_mac(::std::string&& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.location.hashed_sta_eth_mac)
}
#endif
inline void location::set_hashed_sta_eth_mac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.location.hashed_sta_eth_mac)
}
inline void location::set_hashed_sta_eth_mac(const void* value, size_t size) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.location.hashed_sta_eth_mac)
}
inline ::std::string* location::mutable_hashed_sta_eth_mac() {
  set_has_hashed_sta_eth_mac();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.location.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* location::release_hashed_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.location.hashed_sta_eth_mac)
  if (!has_hashed_sta_eth_mac()) {
    return NULL;
  }
  clear_has_hashed_sta_eth_mac();
  return hashed_sta_eth_mac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void location::set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac) {
  if (hashed_sta_eth_mac != NULL) {
    set_has_hashed_sta_eth_mac();
  } else {
    clear_has_hashed_sta_eth_mac();
  }
  hashed_sta_eth_mac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashed_sta_eth_mac);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.location.hashed_sta_eth_mac)
}

// repeated bytes geofence_ids = 13;
inline int location::geofence_ids_size() const {
  return geofence_ids_.size();
}
inline void location::clear_geofence_ids() {
  geofence_ids_.Clear();
}
inline const ::std::string& location::geofence_ids(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.geofence_ids)
  return geofence_ids_.Get(index);
}
inline ::std::string* location::mutable_geofence_ids(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.location.geofence_ids)
  return geofence_ids_.Mutable(index);
}
inline void location::set_geofence_ids(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ce.nbapi.location.geofence_ids)
  geofence_ids_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void location::set_geofence_ids(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ce.nbapi.location.geofence_ids)
  geofence_ids_.Mutable(index)->assign(std::move(value));
}
#endif
inline void location::set_geofence_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  geofence_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ce.nbapi.location.geofence_ids)
}
inline void location::set_geofence_ids(int index, const void* value, size_t size) {
  geofence_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.location.geofence_ids)
}
inline ::std::string* location::add_geofence_ids() {
  // @@protoc_insertion_point(field_add_mutable:ce.nbapi.location.geofence_ids)
  return geofence_ids_.Add();
}
inline void location::add_geofence_ids(const ::std::string& value) {
  geofence_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ce.nbapi.location.geofence_ids)
}
#if LANG_CXX11
inline void location::add_geofence_ids(::std::string&& value) {
  geofence_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ce.nbapi.location.geofence_ids)
}
#endif
inline void location::add_geofence_ids(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  geofence_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ce.nbapi.location.geofence_ids)
}
inline void location::add_geofence_ids(const void* value, size_t size) {
  geofence_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ce.nbapi.location.geofence_ids)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
location::geofence_ids() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.location.geofence_ids)
  return geofence_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
location::mutable_geofence_ids() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.location.geofence_ids)
  return &geofence_ids_;
}

// optional .ce.nbapi.location.algorithm loc_algorithm = 14;
inline bool location::has_loc_algorithm() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void location::set_has_loc_algorithm() {
  _has_bits_[0] |= 0x00000100u;
}
inline void location::clear_has_loc_algorithm() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void location::clear_loc_algorithm() {
  loc_algorithm_ = 0;
  clear_has_loc_algorithm();
}
inline ::ce::nbapi::location_algorithm location::loc_algorithm() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.loc_algorithm)
  return static_cast< ::ce::nbapi::location_algorithm >(loc_algorithm_);
}
inline void location::set_loc_algorithm(::ce::nbapi::location_algorithm value) {
  assert(::ce::nbapi::location_algorithm_IsValid(value));
  set_has_loc_algorithm();
  loc_algorithm_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.loc_algorithm)
}

// optional uint32 rssi_val = 15;
inline bool location::has_rssi_val() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void location::set_has_rssi_val() {
  _has_bits_[0] |= 0x00000400u;
}
inline void location::clear_has_rssi_val() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void location::clear_rssi_val() {
  rssi_val_ = 0u;
  clear_has_rssi_val();
}
inline ::google::protobuf::uint32 location::rssi_val() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.rssi_val)
  return rssi_val_;
}
inline void location::set_rssi_val(::google::protobuf::uint32 value) {
  set_has_rssi_val();
  rssi_val_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.rssi_val)
}

// optional double longitude = 16;
inline bool location::has_longitude() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void location::set_has_longitude() {
  _has_bits_[0] |= 0x00000200u;
}
inline void location::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void location::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double location::longitude() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.longitude)
  return longitude_;
}
inline void location::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.longitude)
}

// optional double latitude = 17;
inline bool location::has_latitude() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void location::set_has_latitude() {
  _has_bits_[0] |= 0x00002000u;
}
inline void location::clear_has_latitude() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void location::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double location::latitude() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.latitude)
  return latitude_;
}
inline void location::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.latitude)
}

// optional double altitude = 18;
inline bool location::has_altitude() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void location::set_has_altitude() {
  _has_bits_[0] |= 0x00004000u;
}
inline void location::clear_has_altitude() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void location::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline double location::altitude() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.altitude)
  return altitude_;
}
inline void location::set_altitude(double value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.altitude)
}

// optional .ce.nbapi.measurement_unit unit = 19;
inline bool location::has_unit() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void location::set_has_unit() {
  _has_bits_[0] |= 0x00008000u;
}
inline void location::clear_has_unit() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void location::clear_unit() {
  unit_ = 0;
  clear_has_unit();
}
inline ::ce::nbapi::measurement_unit location::unit() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.unit)
  return static_cast< ::ce::nbapi::measurement_unit >(unit_);
}
inline void location::set_unit(::ce::nbapi::measurement_unit value) {
  assert(::ce::nbapi::measurement_unit_IsValid(value));
  set_has_unit();
  unit_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.unit)
}

// optional .ce.nbapi.target_dev_type target_type = 20 [default = TARGET_TYPE_STATION];
inline bool location::has_target_type() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void location::set_has_target_type() {
  _has_bits_[0] |= 0x00040000u;
}
inline void location::clear_has_target_type() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void location::clear_target_type() {
  target_type_ = 1;
  clear_has_target_type();
}
inline ::ce::nbapi::target_dev_type location::target_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.target_type)
  return static_cast< ::ce::nbapi::target_dev_type >(target_type_);
}
inline void location::set_target_type(::ce::nbapi::target_dev_type value) {
  assert(::ce::nbapi::target_dev_type_IsValid(value));
  set_has_target_type();
  target_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.target_type)
}

// optional .ce.nbapi.location.error_code err_code = 21;
inline bool location::has_err_code() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void location::set_has_err_code() {
  _has_bits_[0] |= 0x00010000u;
}
inline void location::clear_has_err_code() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void location::clear_err_code() {
  err_code_ = 0;
  clear_has_err_code();
}
inline ::ce::nbapi::location_error_code location::err_code() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.err_code)
  return static_cast< ::ce::nbapi::location_error_code >(err_code_);
}
inline void location::set_err_code(::ce::nbapi::location_error_code value) {
  assert(::ce::nbapi::location_error_code_IsValid(value));
  set_has_err_code();
  err_code_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.err_code)
}

// repeated .ce.nbapi.location.record records = 22;
inline int location::records_size() const {
  return records_.size();
}
inline void location::clear_records() {
  records_.Clear();
}
inline ::ce::nbapi::location_record* location::mutable_records(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.location.records)
  return records_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::location_record >*
location::mutable_records() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.location.records)
  return &records_;
}
inline const ::ce::nbapi::location_record& location::records(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.records)
  return records_.Get(index);
}
inline ::ce::nbapi::location_record* location::add_records() {
  // @@protoc_insertion_point(field_add:ce.nbapi.location.records)
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::location_record >&
location::records() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.location.records)
  return records_;
}

// repeated string geofence_names = 23;
inline int location::geofence_names_size() const {
  return geofence_names_.size();
}
inline void location::clear_geofence_names() {
  geofence_names_.Clear();
}
inline const ::std::string& location::geofence_names(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.geofence_names)
  return geofence_names_.Get(index);
}
inline ::std::string* location::mutable_geofence_names(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.location.geofence_names)
  return geofence_names_.Mutable(index);
}
inline void location::set_geofence_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:ce.nbapi.location.geofence_names)
  geofence_names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void location::set_geofence_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:ce.nbapi.location.geofence_names)
  geofence_names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void location::set_geofence_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  geofence_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:ce.nbapi.location.geofence_names)
}
inline void location::set_geofence_names(int index, const char* value, size_t size) {
  geofence_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.location.geofence_names)
}
inline ::std::string* location::add_geofence_names() {
  // @@protoc_insertion_point(field_add_mutable:ce.nbapi.location.geofence_names)
  return geofence_names_.Add();
}
inline void location::add_geofence_names(const ::std::string& value) {
  geofence_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:ce.nbapi.location.geofence_names)
}
#if LANG_CXX11
inline void location::add_geofence_names(::std::string&& value) {
  geofence_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:ce.nbapi.location.geofence_names)
}
#endif
inline void location::add_geofence_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  geofence_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:ce.nbapi.location.geofence_names)
}
inline void location::add_geofence_names(const char* value, size_t size) {
  geofence_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:ce.nbapi.location.geofence_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
location::geofence_names() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.location.geofence_names)
  return geofence_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
location::mutable_geofence_names() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.location.geofence_names)
  return &geofence_names_;
}

// repeated .ce.nbapi.location.rtls_tag rtls_tag_info = 24;
inline int location::rtls_tag_info_size() const {
  return rtls_tag_info_.size();
}
inline void location::clear_rtls_tag_info() {
  rtls_tag_info_.Clear();
}
inline ::ce::nbapi::location_rtls_tag* location::mutable_rtls_tag_info(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.location.rtls_tag_info)
  return rtls_tag_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::location_rtls_tag >*
location::mutable_rtls_tag_info() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.location.rtls_tag_info)
  return &rtls_tag_info_;
}
inline const ::ce::nbapi::location_rtls_tag& location::rtls_tag_info(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.rtls_tag_info)
  return rtls_tag_info_.Get(index);
}
inline ::ce::nbapi::location_rtls_tag* location::add_rtls_tag_info() {
  // @@protoc_insertion_point(field_add:ce.nbapi.location.rtls_tag_info)
  return rtls_tag_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::location_rtls_tag >&
location::rtls_tag_info() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.location.rtls_tag_info)
  return rtls_tag_info_;
}

// optional uint32 location_compute_timestamp = 25;
inline bool location::has_location_compute_timestamp() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void location::set_has_location_compute_timestamp() {
  _has_bits_[0] |= 0x00020000u;
}
inline void location::clear_has_location_compute_timestamp() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void location::clear_location_compute_timestamp() {
  location_compute_timestamp_ = 0u;
  clear_has_location_compute_timestamp();
}
inline ::google::protobuf::uint32 location::location_compute_timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.location_compute_timestamp)
  return location_compute_timestamp_;
}
inline void location::set_location_compute_timestamp(::google::protobuf::uint32 value) {
  set_has_location_compute_timestamp();
  location_compute_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.location_compute_timestamp)
}

// optional bool associated_to_valid_bssid = 26;
inline bool location::has_associated_to_valid_bssid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void location::set_has_associated_to_valid_bssid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void location::clear_has_associated_to_valid_bssid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void location::clear_associated_to_valid_bssid() {
  associated_to_valid_bssid_ = false;
  clear_has_associated_to_valid_bssid();
}
inline bool location::associated_to_valid_bssid() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.location.associated_to_valid_bssid)
  return associated_to_valid_bssid_;
}
inline void location::set_associated_to_valid_bssid(bool value) {
  set_has_associated_to_valid_bssid();
  associated_to_valid_bssid_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.location.associated_to_valid_bssid)
}

// -------------------------------------------------------------------

// presence

// optional .ce.nbapi.mac_address sta_eth_mac = 1;
inline bool presence::has_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void presence::set_has_sta_eth_mac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void presence::clear_has_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void presence::clear_sta_eth_mac() {
  if (sta_eth_mac_ != NULL) sta_eth_mac_->Clear();
  clear_has_sta_eth_mac();
}
inline const ::ce::nbapi::mac_address& presence::_internal_sta_eth_mac() const {
  return *sta_eth_mac_;
}
inline const ::ce::nbapi::mac_address& presence::sta_eth_mac() const {
  const ::ce::nbapi::mac_address* p = sta_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.presence.sta_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* presence::release_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.presence.sta_eth_mac)
  clear_has_sta_eth_mac();
  ::ce::nbapi::mac_address* temp = sta_eth_mac_;
  sta_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* presence::mutable_sta_eth_mac() {
  set_has_sta_eth_mac();
  if (sta_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    sta_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.presence.sta_eth_mac)
  return sta_eth_mac_;
}
inline void presence::set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sta_eth_mac_;
  }
  if (sta_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sta_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sta_eth_mac, submessage_arena);
    }
    set_has_sta_eth_mac();
  } else {
    clear_has_sta_eth_mac();
  }
  sta_eth_mac_ = sta_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.presence.sta_eth_mac)
}

// optional bool associated = 2;
inline bool presence::has_associated() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void presence::set_has_associated() {
  _has_bits_[0] |= 0x00000010u;
}
inline void presence::clear_has_associated() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void presence::clear_associated() {
  associated_ = false;
  clear_has_associated();
}
inline bool presence::associated() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.presence.associated)
  return associated_;
}
inline void presence::set_associated(bool value) {
  set_has_associated();
  associated_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.presence.associated)
}

// optional bytes hashed_sta_eth_mac = 3;
inline bool presence::has_hashed_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void presence::set_has_hashed_sta_eth_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void presence::clear_has_hashed_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void presence::clear_hashed_sta_eth_mac() {
  hashed_sta_eth_mac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hashed_sta_eth_mac();
}
inline const ::std::string& presence::hashed_sta_eth_mac() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.presence.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.GetNoArena();
}
inline void presence::set_hashed_sta_eth_mac(const ::std::string& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.presence.hashed_sta_eth_mac)
}
#if LANG_CXX11
inline void presence::set_hashed_sta_eth_mac(::std::string&& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.presence.hashed_sta_eth_mac)
}
#endif
inline void presence::set_hashed_sta_eth_mac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.presence.hashed_sta_eth_mac)
}
inline void presence::set_hashed_sta_eth_mac(const void* value, size_t size) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.presence.hashed_sta_eth_mac)
}
inline ::std::string* presence::mutable_hashed_sta_eth_mac() {
  set_has_hashed_sta_eth_mac();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.presence.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* presence::release_hashed_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.presence.hashed_sta_eth_mac)
  if (!has_hashed_sta_eth_mac()) {
    return NULL;
  }
  clear_has_hashed_sta_eth_mac();
  return hashed_sta_eth_mac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void presence::set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac) {
  if (hashed_sta_eth_mac != NULL) {
    set_has_hashed_sta_eth_mac();
  } else {
    clear_has_hashed_sta_eth_mac();
  }
  hashed_sta_eth_mac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashed_sta_eth_mac);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.presence.hashed_sta_eth_mac)
}

// optional string ap_name = 4;
inline bool presence::has_ap_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void presence::set_has_ap_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void presence::clear_has_ap_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void presence::clear_ap_name() {
  ap_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ap_name();
}
inline const ::std::string& presence::ap_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.presence.ap_name)
  return ap_name_.GetNoArena();
}
inline void presence::set_ap_name(const ::std::string& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.presence.ap_name)
}
#if LANG_CXX11
inline void presence::set_ap_name(::std::string&& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.presence.ap_name)
}
#endif
inline void presence::set_ap_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.presence.ap_name)
}
inline void presence::set_ap_name(const char* value, size_t size) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.presence.ap_name)
}
inline ::std::string* presence::mutable_ap_name() {
  set_has_ap_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.presence.ap_name)
  return ap_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* presence::release_ap_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.presence.ap_name)
  if (!has_ap_name()) {
    return NULL;
  }
  clear_has_ap_name();
  return ap_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void presence::set_allocated_ap_name(::std::string* ap_name) {
  if (ap_name != NULL) {
    set_has_ap_name();
  } else {
    clear_has_ap_name();
  }
  ap_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ap_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.presence.ap_name)
}

// optional .ce.nbapi.mac_address radio_mac = 5;
inline bool presence::has_radio_mac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void presence::set_has_radio_mac() {
  _has_bits_[0] |= 0x00000008u;
}
inline void presence::clear_has_radio_mac() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void presence::clear_radio_mac() {
  if (radio_mac_ != NULL) radio_mac_->Clear();
  clear_has_radio_mac();
}
inline const ::ce::nbapi::mac_address& presence::_internal_radio_mac() const {
  return *radio_mac_;
}
inline const ::ce::nbapi::mac_address& presence::radio_mac() const {
  const ::ce::nbapi::mac_address* p = radio_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.presence.radio_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* presence::release_radio_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.presence.radio_mac)
  clear_has_radio_mac();
  ::ce::nbapi::mac_address* temp = radio_mac_;
  radio_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* presence::mutable_radio_mac() {
  set_has_radio_mac();
  if (radio_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    radio_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.presence.radio_mac)
  return radio_mac_;
}
inline void presence::set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radio_mac_;
  }
  if (radio_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radio_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radio_mac, submessage_arena);
    }
    set_has_radio_mac();
  } else {
    clear_has_radio_mac();
  }
  radio_mac_ = radio_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.presence.radio_mac)
}

// optional .ce.nbapi.target_dev_type target_type = 6 [default = TARGET_TYPE_STATION];
inline bool presence::has_target_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void presence::set_has_target_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void presence::clear_has_target_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void presence::clear_target_type() {
  target_type_ = 1;
  clear_has_target_type();
}
inline ::ce::nbapi::target_dev_type presence::target_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.presence.target_type)
  return static_cast< ::ce::nbapi::target_dev_type >(target_type_);
}
inline void presence::set_target_type(::ce::nbapi::target_dev_type value) {
  assert(::ce::nbapi::target_dev_type_IsValid(value));
  set_has_target_type();
  target_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.presence.target_type)
}

// -------------------------------------------------------------------

// rssi

// optional .ce.nbapi.mac_address sta_eth_mac = 1;
inline bool rssi::has_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rssi::set_has_sta_eth_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rssi::clear_has_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rssi::clear_sta_eth_mac() {
  if (sta_eth_mac_ != NULL) sta_eth_mac_->Clear();
  clear_has_sta_eth_mac();
}
inline const ::ce::nbapi::mac_address& rssi::_internal_sta_eth_mac() const {
  return *sta_eth_mac_;
}
inline const ::ce::nbapi::mac_address& rssi::sta_eth_mac() const {
  const ::ce::nbapi::mac_address* p = sta_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.rssi.sta_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* rssi::release_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.rssi.sta_eth_mac)
  clear_has_sta_eth_mac();
  ::ce::nbapi::mac_address* temp = sta_eth_mac_;
  sta_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* rssi::mutable_sta_eth_mac() {
  set_has_sta_eth_mac();
  if (sta_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    sta_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.rssi.sta_eth_mac)
  return sta_eth_mac_;
}
inline void rssi::set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sta_eth_mac_;
  }
  if (sta_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sta_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sta_eth_mac, submessage_arena);
    }
    set_has_sta_eth_mac();
  } else {
    clear_has_sta_eth_mac();
  }
  sta_eth_mac_ = sta_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.rssi.sta_eth_mac)
}

// optional .ce.nbapi.mac_address radio_mac = 2;
inline bool rssi::has_radio_mac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void rssi::set_has_radio_mac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void rssi::clear_has_radio_mac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void rssi::clear_radio_mac() {
  if (radio_mac_ != NULL) radio_mac_->Clear();
  clear_has_radio_mac();
}
inline const ::ce::nbapi::mac_address& rssi::_internal_radio_mac() const {
  return *radio_mac_;
}
inline const ::ce::nbapi::mac_address& rssi::radio_mac() const {
  const ::ce::nbapi::mac_address* p = radio_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.rssi.radio_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* rssi::release_radio_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.rssi.radio_mac)
  clear_has_radio_mac();
  ::ce::nbapi::mac_address* temp = radio_mac_;
  radio_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* rssi::mutable_radio_mac() {
  set_has_radio_mac();
  if (radio_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    radio_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.rssi.radio_mac)
  return radio_mac_;
}
inline void rssi::set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radio_mac_;
  }
  if (radio_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radio_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radio_mac, submessage_arena);
    }
    set_has_radio_mac();
  } else {
    clear_has_radio_mac();
  }
  radio_mac_ = radio_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.rssi.radio_mac)
}

// optional uint32 rssi_val = 3;
inline bool rssi::has_rssi_val() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void rssi::set_has_rssi_val() {
  _has_bits_[0] |= 0x00000008u;
}
inline void rssi::clear_has_rssi_val() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void rssi::clear_rssi_val() {
  rssi_val_ = 0u;
  clear_has_rssi_val();
}
inline ::google::protobuf::uint32 rssi::rssi_val() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.rssi.rssi_val)
  return rssi_val_;
}
inline void rssi::set_rssi_val(::google::protobuf::uint32 value) {
  set_has_rssi_val();
  rssi_val_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.rssi.rssi_val)
}

// optional bool associated = 4;
inline bool rssi::has_associated() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void rssi::set_has_associated() {
  _has_bits_[0] |= 0x00000010u;
}
inline void rssi::clear_has_associated() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void rssi::clear_associated() {
  associated_ = false;
  clear_has_associated();
}
inline bool rssi::associated() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.rssi.associated)
  return associated_;
}
inline void rssi::set_associated(bool value) {
  set_has_associated();
  associated_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.rssi.associated)
}

// optional bytes hashed_sta_eth_mac = 5;
inline bool rssi::has_hashed_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rssi::set_has_hashed_sta_eth_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rssi::clear_has_hashed_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rssi::clear_hashed_sta_eth_mac() {
  hashed_sta_eth_mac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hashed_sta_eth_mac();
}
inline const ::std::string& rssi::hashed_sta_eth_mac() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.rssi.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.GetNoArena();
}
inline void rssi::set_hashed_sta_eth_mac(const ::std::string& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.rssi.hashed_sta_eth_mac)
}
#if LANG_CXX11
inline void rssi::set_hashed_sta_eth_mac(::std::string&& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.rssi.hashed_sta_eth_mac)
}
#endif
inline void rssi::set_hashed_sta_eth_mac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.rssi.hashed_sta_eth_mac)
}
inline void rssi::set_hashed_sta_eth_mac(const void* value, size_t size) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.rssi.hashed_sta_eth_mac)
}
inline ::std::string* rssi::mutable_hashed_sta_eth_mac() {
  set_has_hashed_sta_eth_mac();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.rssi.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* rssi::release_hashed_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.rssi.hashed_sta_eth_mac)
  if (!has_hashed_sta_eth_mac()) {
    return NULL;
  }
  clear_has_hashed_sta_eth_mac();
  return hashed_sta_eth_mac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void rssi::set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac) {
  if (hashed_sta_eth_mac != NULL) {
    set_has_hashed_sta_eth_mac();
  } else {
    clear_has_hashed_sta_eth_mac();
  }
  hashed_sta_eth_mac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashed_sta_eth_mac);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.rssi.hashed_sta_eth_mac)
}

// optional uint32 noise_floor = 6;
inline bool rssi::has_noise_floor() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void rssi::set_has_noise_floor() {
  _has_bits_[0] |= 0x00000040u;
}
inline void rssi::clear_has_noise_floor() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void rssi::clear_noise_floor() {
  noise_floor_ = 0u;
  clear_has_noise_floor();
}
inline ::google::protobuf::uint32 rssi::noise_floor() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.rssi.noise_floor)
  return noise_floor_;
}
inline void rssi::set_noise_floor(::google::protobuf::uint32 value) {
  set_has_noise_floor();
  noise_floor_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.rssi.noise_floor)
}

// optional bool is_ap = 7;
inline bool rssi::has_is_ap() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void rssi::set_has_is_ap() {
  _has_bits_[0] |= 0x00000020u;
}
inline void rssi::clear_has_is_ap() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void rssi::clear_is_ap() {
  is_ap_ = false;
  clear_has_is_ap();
}
inline bool rssi::is_ap() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.rssi.is_ap)
  return is_ap_;
}
inline void rssi::set_is_ap(bool value) {
  set_has_is_ap();
  is_ap_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.rssi.is_ap)
}

// optional uint32 age = 8;
inline bool rssi::has_age() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void rssi::set_has_age() {
  _has_bits_[0] |= 0x00000080u;
}
inline void rssi::clear_has_age() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void rssi::clear_age() {
  age_ = 0u;
  clear_has_age();
}
inline ::google::protobuf::uint32 rssi::age() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.rssi.age)
  return age_;
}
inline void rssi::set_age(::google::protobuf::uint32 value) {
  set_has_age();
  age_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.rssi.age)
}

// optional uint32 classification_type = 9;
inline bool rssi::has_classification_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void rssi::set_has_classification_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void rssi::clear_has_classification_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void rssi::clear_classification_type() {
  classification_type_ = 0u;
  clear_has_classification_type();
}
inline ::google::protobuf::uint32 rssi::classification_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.rssi.classification_type)
  return classification_type_;
}
inline void rssi::set_classification_type(::google::protobuf::uint32 value) {
  set_has_classification_type();
  classification_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.rssi.classification_type)
}

// -------------------------------------------------------------------

// sta_rssi

// optional .ce.nbapi.mac_address sta_eth_mac = 1;
inline bool sta_rssi::has_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void sta_rssi::set_has_sta_eth_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void sta_rssi::clear_has_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void sta_rssi::clear_sta_eth_mac() {
  if (sta_eth_mac_ != NULL) sta_eth_mac_->Clear();
  clear_has_sta_eth_mac();
}
inline const ::ce::nbapi::mac_address& sta_rssi::_internal_sta_eth_mac() const {
  return *sta_eth_mac_;
}
inline const ::ce::nbapi::mac_address& sta_rssi::sta_eth_mac() const {
  const ::ce::nbapi::mac_address* p = sta_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.sta_rssi.sta_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* sta_rssi::release_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.sta_rssi.sta_eth_mac)
  clear_has_sta_eth_mac();
  ::ce::nbapi::mac_address* temp = sta_eth_mac_;
  sta_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* sta_rssi::mutable_sta_eth_mac() {
  set_has_sta_eth_mac();
  if (sta_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    sta_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.sta_rssi.sta_eth_mac)
  return sta_eth_mac_;
}
inline void sta_rssi::set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sta_eth_mac_;
  }
  if (sta_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sta_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sta_eth_mac, submessage_arena);
    }
    set_has_sta_eth_mac();
  } else {
    clear_has_sta_eth_mac();
  }
  sta_eth_mac_ = sta_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.sta_rssi.sta_eth_mac)
}

// optional .ce.nbapi.mac_address radio_mac = 2;
inline bool sta_rssi::has_radio_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void sta_rssi::set_has_radio_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void sta_rssi::clear_has_radio_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void sta_rssi::clear_radio_mac() {
  if (radio_mac_ != NULL) radio_mac_->Clear();
  clear_has_radio_mac();
}
inline const ::ce::nbapi::mac_address& sta_rssi::_internal_radio_mac() const {
  return *radio_mac_;
}
inline const ::ce::nbapi::mac_address& sta_rssi::radio_mac() const {
  const ::ce::nbapi::mac_address* p = radio_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.sta_rssi.radio_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* sta_rssi::release_radio_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.sta_rssi.radio_mac)
  clear_has_radio_mac();
  ::ce::nbapi::mac_address* temp = radio_mac_;
  radio_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* sta_rssi::mutable_radio_mac() {
  set_has_radio_mac();
  if (radio_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    radio_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.sta_rssi.radio_mac)
  return radio_mac_;
}
inline void sta_rssi::set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radio_mac_;
  }
  if (radio_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radio_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radio_mac, submessage_arena);
    }
    set_has_radio_mac();
  } else {
    clear_has_radio_mac();
  }
  radio_mac_ = radio_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.sta_rssi.radio_mac)
}

// optional sint32 rssi_val = 3;
inline bool sta_rssi::has_rssi_val() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void sta_rssi::set_has_rssi_val() {
  _has_bits_[0] |= 0x00000008u;
}
inline void sta_rssi::clear_has_rssi_val() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void sta_rssi::clear_rssi_val() {
  rssi_val_ = 0;
  clear_has_rssi_val();
}
inline ::google::protobuf::int32 sta_rssi::rssi_val() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.sta_rssi.rssi_val)
  return rssi_val_;
}
inline void sta_rssi::set_rssi_val(::google::protobuf::int32 value) {
  set_has_rssi_val();
  rssi_val_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.sta_rssi.rssi_val)
}

// optional bool associated = 4;
inline bool sta_rssi::has_associated() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void sta_rssi::set_has_associated() {
  _has_bits_[0] |= 0x00000040u;
}
inline void sta_rssi::clear_has_associated() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void sta_rssi::clear_associated() {
  associated_ = false;
  clear_has_associated();
}
inline bool sta_rssi::associated() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.sta_rssi.associated)
  return associated_;
}
inline void sta_rssi::set_associated(bool value) {
  set_has_associated();
  associated_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.sta_rssi.associated)
}

// optional int32 age = 5;
inline bool sta_rssi::has_age() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void sta_rssi::set_has_age() {
  _has_bits_[0] |= 0x00000010u;
}
inline void sta_rssi::clear_has_age() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void sta_rssi::clear_age() {
  age_ = 0;
  clear_has_age();
}
inline ::google::protobuf::int32 sta_rssi::age() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.sta_rssi.age)
  return age_;
}
inline void sta_rssi::set_age(::google::protobuf::int32 value) {
  set_has_age();
  age_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.sta_rssi.age)
}

// optional int32 noise_floor = 6;
inline bool sta_rssi::has_noise_floor() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void sta_rssi::set_has_noise_floor() {
  _has_bits_[0] |= 0x00000020u;
}
inline void sta_rssi::clear_has_noise_floor() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void sta_rssi::clear_noise_floor() {
  noise_floor_ = 0;
  clear_has_noise_floor();
}
inline ::google::protobuf::int32 sta_rssi::noise_floor() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.sta_rssi.noise_floor)
  return noise_floor_;
}
inline void sta_rssi::set_noise_floor(::google::protobuf::int32 value) {
  set_has_noise_floor();
  noise_floor_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.sta_rssi.noise_floor)
}

// optional .ce.nbapi.mac_address assoc_bssid = 7;
inline bool sta_rssi::has_assoc_bssid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void sta_rssi::set_has_assoc_bssid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void sta_rssi::clear_has_assoc_bssid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void sta_rssi::clear_assoc_bssid() {
  if (assoc_bssid_ != NULL) assoc_bssid_->Clear();
  clear_has_assoc_bssid();
}
inline const ::ce::nbapi::mac_address& sta_rssi::_internal_assoc_bssid() const {
  return *assoc_bssid_;
}
inline const ::ce::nbapi::mac_address& sta_rssi::assoc_bssid() const {
  const ::ce::nbapi::mac_address* p = assoc_bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.sta_rssi.assoc_bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* sta_rssi::release_assoc_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.sta_rssi.assoc_bssid)
  clear_has_assoc_bssid();
  ::ce::nbapi::mac_address* temp = assoc_bssid_;
  assoc_bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* sta_rssi::mutable_assoc_bssid() {
  set_has_assoc_bssid();
  if (assoc_bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    assoc_bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.sta_rssi.assoc_bssid)
  return assoc_bssid_;
}
inline void sta_rssi::set_allocated_assoc_bssid(::ce::nbapi::mac_address* assoc_bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete assoc_bssid_;
  }
  if (assoc_bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      assoc_bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, assoc_bssid, submessage_arena);
    }
    set_has_assoc_bssid();
  } else {
    clear_has_assoc_bssid();
  }
  assoc_bssid_ = assoc_bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.sta_rssi.assoc_bssid)
}

// optional uint32 classification_type = 8;
inline bool sta_rssi::has_classification_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void sta_rssi::set_has_classification_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void sta_rssi::clear_has_classification_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void sta_rssi::clear_classification_type() {
  classification_type_ = 0u;
  clear_has_classification_type();
}
inline ::google::protobuf::uint32 sta_rssi::classification_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.sta_rssi.classification_type)
  return classification_type_;
}
inline void sta_rssi::set_classification_type(::google::protobuf::uint32 value) {
  set_has_classification_type();
  classification_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.sta_rssi.classification_type)
}

// optional bool associated_to_valid_bssid = 9;
inline bool sta_rssi::has_associated_to_valid_bssid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void sta_rssi::set_has_associated_to_valid_bssid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void sta_rssi::clear_has_associated_to_valid_bssid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void sta_rssi::clear_associated_to_valid_bssid() {
  associated_to_valid_bssid_ = false;
  clear_has_associated_to_valid_bssid();
}
inline bool sta_rssi::associated_to_valid_bssid() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.sta_rssi.associated_to_valid_bssid)
  return associated_to_valid_bssid_;
}
inline void sta_rssi::set_associated_to_valid_bssid(bool value) {
  set_has_associated_to_valid_bssid();
  associated_to_valid_bssid_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.sta_rssi.associated_to_valid_bssid)
}

// -------------------------------------------------------------------

// tag_rssi

// optional .ce.nbapi.mac_address tag_mac = 1;
inline bool tag_rssi::has_tag_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tag_rssi::set_has_tag_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tag_rssi::clear_has_tag_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tag_rssi::clear_tag_mac() {
  if (tag_mac_ != NULL) tag_mac_->Clear();
  clear_has_tag_mac();
}
inline const ::ce::nbapi::mac_address& tag_rssi::_internal_tag_mac() const {
  return *tag_mac_;
}
inline const ::ce::nbapi::mac_address& tag_rssi::tag_mac() const {
  const ::ce::nbapi::mac_address* p = tag_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.tag_rssi.tag_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* tag_rssi::release_tag_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.tag_rssi.tag_mac)
  clear_has_tag_mac();
  ::ce::nbapi::mac_address* temp = tag_mac_;
  tag_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* tag_rssi::mutable_tag_mac() {
  set_has_tag_mac();
  if (tag_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    tag_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.tag_rssi.tag_mac)
  return tag_mac_;
}
inline void tag_rssi::set_allocated_tag_mac(::ce::nbapi::mac_address* tag_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tag_mac_;
  }
  if (tag_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tag_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tag_mac, submessage_arena);
    }
    set_has_tag_mac();
  } else {
    clear_has_tag_mac();
  }
  tag_mac_ = tag_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.tag_rssi.tag_mac)
}

// optional .ce.nbapi.mac_address radio_mac = 2;
inline bool tag_rssi::has_radio_mac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tag_rssi::set_has_radio_mac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tag_rssi::clear_has_radio_mac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tag_rssi::clear_radio_mac() {
  if (radio_mac_ != NULL) radio_mac_->Clear();
  clear_has_radio_mac();
}
inline const ::ce::nbapi::mac_address& tag_rssi::_internal_radio_mac() const {
  return *radio_mac_;
}
inline const ::ce::nbapi::mac_address& tag_rssi::radio_mac() const {
  const ::ce::nbapi::mac_address* p = radio_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.tag_rssi.radio_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* tag_rssi::release_radio_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.tag_rssi.radio_mac)
  clear_has_radio_mac();
  ::ce::nbapi::mac_address* temp = radio_mac_;
  radio_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* tag_rssi::mutable_radio_mac() {
  set_has_radio_mac();
  if (radio_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    radio_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.tag_rssi.radio_mac)
  return radio_mac_;
}
inline void tag_rssi::set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radio_mac_;
  }
  if (radio_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radio_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radio_mac, submessage_arena);
    }
    set_has_radio_mac();
  } else {
    clear_has_radio_mac();
  }
  radio_mac_ = radio_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.tag_rssi.radio_mac)
}

// optional sint32 rssi_val = 3;
inline bool tag_rssi::has_rssi_val() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void tag_rssi::set_has_rssi_val() {
  _has_bits_[0] |= 0x00000008u;
}
inline void tag_rssi::clear_has_rssi_val() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void tag_rssi::clear_rssi_val() {
  rssi_val_ = 0;
  clear_has_rssi_val();
}
inline ::google::protobuf::int32 tag_rssi::rssi_val() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.tag_rssi.rssi_val)
  return rssi_val_;
}
inline void tag_rssi::set_rssi_val(::google::protobuf::int32 value) {
  set_has_rssi_val();
  rssi_val_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.tag_rssi.rssi_val)
}

// optional int32 noise_floor = 4;
inline bool tag_rssi::has_noise_floor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void tag_rssi::set_has_noise_floor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void tag_rssi::clear_has_noise_floor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void tag_rssi::clear_noise_floor() {
  noise_floor_ = 0;
  clear_has_noise_floor();
}
inline ::google::protobuf::int32 tag_rssi::noise_floor() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.tag_rssi.noise_floor)
  return noise_floor_;
}
inline void tag_rssi::set_noise_floor(::google::protobuf::int32 value) {
  set_has_noise_floor();
  noise_floor_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.tag_rssi.noise_floor)
}

// optional uint32 battery = 5;
inline bool tag_rssi::has_battery() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void tag_rssi::set_has_battery() {
  _has_bits_[0] |= 0x00000020u;
}
inline void tag_rssi::clear_has_battery() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void tag_rssi::clear_battery() {
  battery_ = 0u;
  clear_has_battery();
}
inline ::google::protobuf::uint32 tag_rssi::battery() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.tag_rssi.battery)
  return battery_;
}
inline void tag_rssi::set_battery(::google::protobuf::uint32 value) {
  set_has_battery();
  battery_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.tag_rssi.battery)
}

// optional uint32 channel = 6;
inline bool tag_rssi::has_channel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void tag_rssi::set_has_channel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void tag_rssi::clear_has_channel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void tag_rssi::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 tag_rssi::channel() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.tag_rssi.channel)
  return channel_;
}
inline void tag_rssi::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.tag_rssi.channel)
}

// optional uint32 tx_power = 7;
inline bool tag_rssi::has_tx_power() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void tag_rssi::set_has_tx_power() {
  _has_bits_[0] |= 0x00000080u;
}
inline void tag_rssi::clear_has_tx_power() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void tag_rssi::clear_tx_power() {
  tx_power_ = 0u;
  clear_has_tx_power();
}
inline ::google::protobuf::uint32 tag_rssi::tx_power() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.tag_rssi.tx_power)
  return tx_power_;
}
inline void tag_rssi::set_tx_power(::google::protobuf::uint32 value) {
  set_has_tx_power();
  tx_power_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.tag_rssi.tx_power)
}

// optional uint32 data_rate = 8;
inline bool tag_rssi::has_data_rate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void tag_rssi::set_has_data_rate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void tag_rssi::clear_has_data_rate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void tag_rssi::clear_data_rate() {
  data_rate_ = 0u;
  clear_has_data_rate();
}
inline ::google::protobuf::uint32 tag_rssi::data_rate() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.tag_rssi.data_rate)
  return data_rate_;
}
inline void tag_rssi::set_data_rate(::google::protobuf::uint32 value) {
  set_has_data_rate();
  data_rate_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.tag_rssi.data_rate)
}

// optional bytes payload = 9;
inline bool tag_rssi::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tag_rssi::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tag_rssi::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tag_rssi::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_payload();
}
inline const ::std::string& tag_rssi::payload() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.tag_rssi.payload)
  return payload_.GetNoArena();
}
inline void tag_rssi::set_payload(const ::std::string& value) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.tag_rssi.payload)
}
#if LANG_CXX11
inline void tag_rssi::set_payload(::std::string&& value) {
  set_has_payload();
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.tag_rssi.payload)
}
#endif
inline void tag_rssi::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.tag_rssi.payload)
}
inline void tag_rssi::set_payload(const void* value, size_t size) {
  set_has_payload();
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.tag_rssi.payload)
}
inline ::std::string* tag_rssi::mutable_payload() {
  set_has_payload();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.tag_rssi.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* tag_rssi::release_payload() {
  // @@protoc_insertion_point(field_release:ce.nbapi.tag_rssi.payload)
  if (!has_payload()) {
    return NULL;
  }
  clear_has_payload();
  return payload_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void tag_rssi::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    set_has_payload();
  } else {
    clear_has_payload();
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.tag_rssi.payload)
}

// -------------------------------------------------------------------

// ap_rssi

// optional .ce.nbapi.mac_address ap_eth_mac = 1;
inline bool ap_rssi::has_ap_eth_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ap_rssi::set_has_ap_eth_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ap_rssi::clear_has_ap_eth_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ap_rssi::clear_ap_eth_mac() {
  if (ap_eth_mac_ != NULL) ap_eth_mac_->Clear();
  clear_has_ap_eth_mac();
}
inline const ::ce::nbapi::mac_address& ap_rssi::_internal_ap_eth_mac() const {
  return *ap_eth_mac_;
}
inline const ::ce::nbapi::mac_address& ap_rssi::ap_eth_mac() const {
  const ::ce::nbapi::mac_address* p = ap_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_rssi.ap_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* ap_rssi::release_ap_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.ap_rssi.ap_eth_mac)
  clear_has_ap_eth_mac();
  ::ce::nbapi::mac_address* temp = ap_eth_mac_;
  ap_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* ap_rssi::mutable_ap_eth_mac() {
  set_has_ap_eth_mac();
  if (ap_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ap_rssi.ap_eth_mac)
  return ap_eth_mac_;
}
inline void ap_rssi::set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_eth_mac_;
  }
  if (ap_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_eth_mac, submessage_arena);
    }
    set_has_ap_eth_mac();
  } else {
    clear_has_ap_eth_mac();
  }
  ap_eth_mac_ = ap_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.ap_rssi.ap_eth_mac)
}

// optional .ce.nbapi.mac_address neighbor_bssid = 2;
inline bool ap_rssi::has_neighbor_bssid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ap_rssi::set_has_neighbor_bssid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ap_rssi::clear_has_neighbor_bssid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ap_rssi::clear_neighbor_bssid() {
  if (neighbor_bssid_ != NULL) neighbor_bssid_->Clear();
  clear_has_neighbor_bssid();
}
inline const ::ce::nbapi::mac_address& ap_rssi::_internal_neighbor_bssid() const {
  return *neighbor_bssid_;
}
inline const ::ce::nbapi::mac_address& ap_rssi::neighbor_bssid() const {
  const ::ce::nbapi::mac_address* p = neighbor_bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_rssi.neighbor_bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* ap_rssi::release_neighbor_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.ap_rssi.neighbor_bssid)
  clear_has_neighbor_bssid();
  ::ce::nbapi::mac_address* temp = neighbor_bssid_;
  neighbor_bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* ap_rssi::mutable_neighbor_bssid() {
  set_has_neighbor_bssid();
  if (neighbor_bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    neighbor_bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ap_rssi.neighbor_bssid)
  return neighbor_bssid_;
}
inline void ap_rssi::set_allocated_neighbor_bssid(::ce::nbapi::mac_address* neighbor_bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete neighbor_bssid_;
  }
  if (neighbor_bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      neighbor_bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, neighbor_bssid, submessage_arena);
    }
    set_has_neighbor_bssid();
  } else {
    clear_has_neighbor_bssid();
  }
  neighbor_bssid_ = neighbor_bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.ap_rssi.neighbor_bssid)
}

// optional string ssid = 3;
inline bool ap_rssi::has_ssid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ap_rssi::set_has_ssid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ap_rssi::clear_has_ssid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ap_rssi::clear_ssid() {
  ssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ssid();
}
inline const ::std::string& ap_rssi::ssid() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_rssi.ssid)
  return ssid_.GetNoArena();
}
inline void ap_rssi::set_ssid(const ::std::string& value) {
  set_has_ssid();
  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_rssi.ssid)
}
#if LANG_CXX11
inline void ap_rssi::set_ssid(::std::string&& value) {
  set_has_ssid();
  ssid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.ap_rssi.ssid)
}
#endif
inline void ap_rssi::set_ssid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ssid();
  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.ap_rssi.ssid)
}
inline void ap_rssi::set_ssid(const char* value, size_t size) {
  set_has_ssid();
  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.ap_rssi.ssid)
}
inline ::std::string* ap_rssi::mutable_ssid() {
  set_has_ssid();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ap_rssi.ssid)
  return ssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ap_rssi::release_ssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.ap_rssi.ssid)
  if (!has_ssid()) {
    return NULL;
  }
  clear_has_ssid();
  return ssid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ap_rssi::set_allocated_ssid(::std::string* ssid) {
  if (ssid != NULL) {
    set_has_ssid();
  } else {
    clear_has_ssid();
  }
  ssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssid);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.ap_rssi.ssid)
}

// optional sint32 rssi_val = 4;
inline bool ap_rssi::has_rssi_val() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ap_rssi::set_has_rssi_val() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ap_rssi::clear_has_rssi_val() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ap_rssi::clear_rssi_val() {
  rssi_val_ = 0;
  clear_has_rssi_val();
}
inline ::google::protobuf::int32 ap_rssi::rssi_val() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_rssi.rssi_val)
  return rssi_val_;
}
inline void ap_rssi::set_rssi_val(::google::protobuf::int32 value) {
  set_has_rssi_val();
  rssi_val_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_rssi.rssi_val)
}

// optional uint32 phy_type = 5;
inline bool ap_rssi::has_phy_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ap_rssi::set_has_phy_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ap_rssi::clear_has_phy_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ap_rssi::clear_phy_type() {
  phy_type_ = 0u;
  clear_has_phy_type();
}
inline ::google::protobuf::uint32 ap_rssi::phy_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_rssi.phy_type)
  return phy_type_;
}
inline void ap_rssi::set_phy_type(::google::protobuf::uint32 value) {
  set_has_phy_type();
  phy_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_rssi.phy_type)
}

// optional uint32 ht_mode = 6;
inline bool ap_rssi::has_ht_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ap_rssi::set_has_ht_mode() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ap_rssi::clear_has_ht_mode() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ap_rssi::clear_ht_mode() {
  ht_mode_ = 0u;
  clear_has_ht_mode();
}
inline ::google::protobuf::uint32 ap_rssi::ht_mode() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_rssi.ht_mode)
  return ht_mode_;
}
inline void ap_rssi::set_ht_mode(::google::protobuf::uint32 value) {
  set_has_ht_mode();
  ht_mode_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_rssi.ht_mode)
}

// optional uint32 channel = 7;
inline bool ap_rssi::has_channel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ap_rssi::set_has_channel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ap_rssi::clear_has_channel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ap_rssi::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 ap_rssi::channel() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_rssi.channel)
  return channel_;
}
inline void ap_rssi::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_rssi.channel)
}

// optional uint32 tx_power = 8;
inline bool ap_rssi::has_tx_power() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ap_rssi::set_has_tx_power() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ap_rssi::clear_has_tx_power() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ap_rssi::clear_tx_power() {
  tx_power_ = 0u;
  clear_has_tx_power();
}
inline ::google::protobuf::uint32 ap_rssi::tx_power() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_rssi.tx_power)
  return tx_power_;
}
inline void ap_rssi::set_tx_power(::google::protobuf::uint32 value) {
  set_has_tx_power();
  tx_power_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_rssi.tx_power)
}

// optional int64 bw_rate = 9;
inline bool ap_rssi::has_bw_rate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ap_rssi::set_has_bw_rate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ap_rssi::clear_has_bw_rate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ap_rssi::clear_bw_rate() {
  bw_rate_ = GOOGLE_LONGLONG(0);
  clear_has_bw_rate();
}
inline ::google::protobuf::int64 ap_rssi::bw_rate() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_rssi.bw_rate)
  return bw_rate_;
}
inline void ap_rssi::set_bw_rate(::google::protobuf::int64 value) {
  set_has_bw_rate();
  bw_rate_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_rssi.bw_rate)
}

// optional .ce.nbapi.mac_address bssid = 10;
inline bool ap_rssi::has_bssid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ap_rssi::set_has_bssid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ap_rssi::clear_has_bssid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ap_rssi::clear_bssid() {
  if (bssid_ != NULL) bssid_->Clear();
  clear_has_bssid();
}
inline const ::ce::nbapi::mac_address& ap_rssi::_internal_bssid() const {
  return *bssid_;
}
inline const ::ce::nbapi::mac_address& ap_rssi::bssid() const {
  const ::ce::nbapi::mac_address* p = bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_rssi.bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* ap_rssi::release_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.ap_rssi.bssid)
  clear_has_bssid();
  ::ce::nbapi::mac_address* temp = bssid_;
  bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* ap_rssi::mutable_bssid() {
  set_has_bssid();
  if (bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ap_rssi.bssid)
  return bssid_;
}
inline void ap_rssi::set_allocated_bssid(::ce::nbapi::mac_address* bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bssid_;
  }
  if (bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bssid, submessage_arena);
    }
    set_has_bssid();
  } else {
    clear_has_bssid();
  }
  bssid_ = bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.ap_rssi.bssid)
}

// optional uint32 classification_type = 11;
inline bool ap_rssi::has_classification_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ap_rssi::set_has_classification_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ap_rssi::clear_has_classification_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ap_rssi::clear_classification_type() {
  classification_type_ = 0u;
  clear_has_classification_type();
}
inline ::google::protobuf::uint32 ap_rssi::classification_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_rssi.classification_type)
  return classification_type_;
}
inline void ap_rssi::set_classification_type(::google::protobuf::uint32 value) {
  set_has_classification_type();
  classification_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_rssi.classification_type)
}

// -------------------------------------------------------------------

// station

// optional .ce.nbapi.mac_address sta_eth_mac = 1;
inline bool station::has_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void station::set_has_sta_eth_mac() {
  _has_bits_[0] |= 0x00000040u;
}
inline void station::clear_has_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void station::clear_sta_eth_mac() {
  if (sta_eth_mac_ != NULL) sta_eth_mac_->Clear();
  clear_has_sta_eth_mac();
}
inline const ::ce::nbapi::mac_address& station::_internal_sta_eth_mac() const {
  return *sta_eth_mac_;
}
inline const ::ce::nbapi::mac_address& station::sta_eth_mac() const {
  const ::ce::nbapi::mac_address* p = sta_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.station.sta_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* station::release_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.station.sta_eth_mac)
  clear_has_sta_eth_mac();
  ::ce::nbapi::mac_address* temp = sta_eth_mac_;
  sta_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* station::mutable_sta_eth_mac() {
  set_has_sta_eth_mac();
  if (sta_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    sta_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.station.sta_eth_mac)
  return sta_eth_mac_;
}
inline void station::set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sta_eth_mac_;
  }
  if (sta_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sta_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sta_eth_mac, submessage_arena);
    }
    set_has_sta_eth_mac();
  } else {
    clear_has_sta_eth_mac();
  }
  sta_eth_mac_ = sta_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.station.sta_eth_mac)
}

// optional string username = 2;
inline bool station::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void station::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void station::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void station::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& station::username() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.station.username)
  return username_.GetNoArena();
}
inline void station::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.station.username)
}
#if LANG_CXX11
inline void station::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.station.username)
}
#endif
inline void station::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.station.username)
}
inline void station::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.station.username)
}
inline ::std::string* station::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.station.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* station::release_username() {
  // @@protoc_insertion_point(field_release:ce.nbapi.station.username)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void station::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.station.username)
}

// optional string role = 3;
inline bool station::has_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void station::set_has_role() {
  _has_bits_[0] |= 0x00000002u;
}
inline void station::clear_has_role() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void station::clear_role() {
  role_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_role();
}
inline const ::std::string& station::role() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.station.role)
  return role_.GetNoArena();
}
inline void station::set_role(const ::std::string& value) {
  set_has_role();
  role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.station.role)
}
#if LANG_CXX11
inline void station::set_role(::std::string&& value) {
  set_has_role();
  role_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.station.role)
}
#endif
inline void station::set_role(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_role();
  role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.station.role)
}
inline void station::set_role(const char* value, size_t size) {
  set_has_role();
  role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.station.role)
}
inline ::std::string* station::mutable_role() {
  set_has_role();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.station.role)
  return role_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* station::release_role() {
  // @@protoc_insertion_point(field_release:ce.nbapi.station.role)
  if (!has_role()) {
    return NULL;
  }
  clear_has_role();
  return role_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void station::set_allocated_role(::std::string* role) {
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), role);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.station.role)
}

// optional .ce.nbapi.mac_address bssid = 4;
inline bool station::has_bssid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void station::set_has_bssid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void station::clear_has_bssid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void station::clear_bssid() {
  if (bssid_ != NULL) bssid_->Clear();
  clear_has_bssid();
}
inline const ::ce::nbapi::mac_address& station::_internal_bssid() const {
  return *bssid_;
}
inline const ::ce::nbapi::mac_address& station::bssid() const {
  const ::ce::nbapi::mac_address* p = bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.station.bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* station::release_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.station.bssid)
  clear_has_bssid();
  ::ce::nbapi::mac_address* temp = bssid_;
  bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* station::mutable_bssid() {
  set_has_bssid();
  if (bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.station.bssid)
  return bssid_;
}
inline void station::set_allocated_bssid(::ce::nbapi::mac_address* bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bssid_;
  }
  if (bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bssid, submessage_arena);
    }
    set_has_bssid();
  } else {
    clear_has_bssid();
  }
  bssid_ = bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.station.bssid)
}

// optional string device_type = 5;
inline bool station::has_device_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void station::set_has_device_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void station::clear_has_device_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void station::clear_device_type() {
  device_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_device_type();
}
inline const ::std::string& station::device_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.station.device_type)
  return device_type_.GetNoArena();
}
inline void station::set_device_type(const ::std::string& value) {
  set_has_device_type();
  device_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.station.device_type)
}
#if LANG_CXX11
inline void station::set_device_type(::std::string&& value) {
  set_has_device_type();
  device_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.station.device_type)
}
#endif
inline void station::set_device_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_device_type();
  device_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.station.device_type)
}
inline void station::set_device_type(const char* value, size_t size) {
  set_has_device_type();
  device_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.station.device_type)
}
inline ::std::string* station::mutable_device_type() {
  set_has_device_type();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.station.device_type)
  return device_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* station::release_device_type() {
  // @@protoc_insertion_point(field_release:ce.nbapi.station.device_type)
  if (!has_device_type()) {
    return NULL;
  }
  clear_has_device_type();
  return device_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void station::set_allocated_device_type(::std::string* device_type) {
  if (device_type != NULL) {
    set_has_device_type();
  } else {
    clear_has_device_type();
  }
  device_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device_type);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.station.device_type)
}

// optional .ce.nbapi.ip_address sta_ip_address = 6;
inline bool station::has_sta_ip_address() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void station::set_has_sta_ip_address() {
  _has_bits_[0] |= 0x00000100u;
}
inline void station::clear_has_sta_ip_address() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void station::clear_sta_ip_address() {
  if (sta_ip_address_ != NULL) sta_ip_address_->Clear();
  clear_has_sta_ip_address();
}
inline const ::ce::nbapi::ip_address& station::_internal_sta_ip_address() const {
  return *sta_ip_address_;
}
inline const ::ce::nbapi::ip_address& station::sta_ip_address() const {
  const ::ce::nbapi::ip_address* p = sta_ip_address_;
  // @@protoc_insertion_point(field_get:ce.nbapi.station.sta_ip_address)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* station::release_sta_ip_address() {
  // @@protoc_insertion_point(field_release:ce.nbapi.station.sta_ip_address)
  clear_has_sta_ip_address();
  ::ce::nbapi::ip_address* temp = sta_ip_address_;
  sta_ip_address_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* station::mutable_sta_ip_address() {
  set_has_sta_ip_address();
  if (sta_ip_address_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    sta_ip_address_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.station.sta_ip_address)
  return sta_ip_address_;
}
inline void station::set_allocated_sta_ip_address(::ce::nbapi::ip_address* sta_ip_address) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sta_ip_address_;
  }
  if (sta_ip_address) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sta_ip_address = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sta_ip_address, submessage_arena);
    }
    set_has_sta_ip_address();
  } else {
    clear_has_sta_ip_address();
  }
  sta_ip_address_ = sta_ip_address;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.station.sta_ip_address)
}

// optional bytes hashed_sta_eth_mac = 7;
inline bool station::has_hashed_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void station::set_has_hashed_sta_eth_mac() {
  _has_bits_[0] |= 0x00000008u;
}
inline void station::clear_has_hashed_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void station::clear_hashed_sta_eth_mac() {
  hashed_sta_eth_mac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hashed_sta_eth_mac();
}
inline const ::std::string& station::hashed_sta_eth_mac() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.station.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.GetNoArena();
}
inline void station::set_hashed_sta_eth_mac(const ::std::string& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.station.hashed_sta_eth_mac)
}
#if LANG_CXX11
inline void station::set_hashed_sta_eth_mac(::std::string&& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.station.hashed_sta_eth_mac)
}
#endif
inline void station::set_hashed_sta_eth_mac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.station.hashed_sta_eth_mac)
}
inline void station::set_hashed_sta_eth_mac(const void* value, size_t size) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.station.hashed_sta_eth_mac)
}
inline ::std::string* station::mutable_hashed_sta_eth_mac() {
  set_has_hashed_sta_eth_mac();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.station.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* station::release_hashed_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.station.hashed_sta_eth_mac)
  if (!has_hashed_sta_eth_mac()) {
    return NULL;
  }
  clear_has_hashed_sta_eth_mac();
  return hashed_sta_eth_mac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void station::set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac) {
  if (hashed_sta_eth_mac != NULL) {
    set_has_hashed_sta_eth_mac();
  } else {
    clear_has_hashed_sta_eth_mac();
  }
  hashed_sta_eth_mac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashed_sta_eth_mac);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.station.hashed_sta_eth_mac)
}

// optional bytes hashed_sta_ip_address = 8;
inline bool station::has_hashed_sta_ip_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void station::set_has_hashed_sta_ip_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void station::clear_has_hashed_sta_ip_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void station::clear_hashed_sta_ip_address() {
  hashed_sta_ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hashed_sta_ip_address();
}
inline const ::std::string& station::hashed_sta_ip_address() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.station.hashed_sta_ip_address)
  return hashed_sta_ip_address_.GetNoArena();
}
inline void station::set_hashed_sta_ip_address(const ::std::string& value) {
  set_has_hashed_sta_ip_address();
  hashed_sta_ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.station.hashed_sta_ip_address)
}
#if LANG_CXX11
inline void station::set_hashed_sta_ip_address(::std::string&& value) {
  set_has_hashed_sta_ip_address();
  hashed_sta_ip_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.station.hashed_sta_ip_address)
}
#endif
inline void station::set_hashed_sta_ip_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hashed_sta_ip_address();
  hashed_sta_ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.station.hashed_sta_ip_address)
}
inline void station::set_hashed_sta_ip_address(const void* value, size_t size) {
  set_has_hashed_sta_ip_address();
  hashed_sta_ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.station.hashed_sta_ip_address)
}
inline ::std::string* station::mutable_hashed_sta_ip_address() {
  set_has_hashed_sta_ip_address();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.station.hashed_sta_ip_address)
  return hashed_sta_ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* station::release_hashed_sta_ip_address() {
  // @@protoc_insertion_point(field_release:ce.nbapi.station.hashed_sta_ip_address)
  if (!has_hashed_sta_ip_address()) {
    return NULL;
  }
  clear_has_hashed_sta_ip_address();
  return hashed_sta_ip_address_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void station::set_allocated_hashed_sta_ip_address(::std::string* hashed_sta_ip_address) {
  if (hashed_sta_ip_address != NULL) {
    set_has_hashed_sta_ip_address();
  } else {
    clear_has_hashed_sta_ip_address();
  }
  hashed_sta_ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashed_sta_ip_address);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.station.hashed_sta_ip_address)
}

// optional uint32 vlan = 9;
inline bool station::has_vlan() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void station::set_has_vlan() {
  _has_bits_[0] |= 0x00000200u;
}
inline void station::clear_has_vlan() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void station::clear_vlan() {
  vlan_ = 0u;
  clear_has_vlan();
}
inline ::google::protobuf::uint32 station::vlan() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.station.vlan)
  return vlan_;
}
inline void station::set_vlan(::google::protobuf::uint32 value) {
  set_has_vlan();
  vlan_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.station.vlan)
}

// optional .ce.nbapi.ht_type ht = 10;
inline bool station::has_ht() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void station::set_has_ht() {
  _has_bits_[0] |= 0x00000400u;
}
inline void station::clear_has_ht() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void station::clear_ht() {
  ht_ = 0;
  clear_has_ht();
}
inline ::ce::nbapi::ht_type station::ht() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.station.ht)
  return static_cast< ::ce::nbapi::ht_type >(ht_);
}
inline void station::set_ht(::ce::nbapi::ht_type value) {
  assert(::ce::nbapi::ht_type_IsValid(value));
  set_has_ht();
  ht_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.station.ht)
}

// optional string ap_name = 11;
inline bool station::has_ap_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void station::set_has_ap_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void station::clear_has_ap_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void station::clear_ap_name() {
  ap_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ap_name();
}
inline const ::std::string& station::ap_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.station.ap_name)
  return ap_name_.GetNoArena();
}
inline void station::set_ap_name(const ::std::string& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.station.ap_name)
}
#if LANG_CXX11
inline void station::set_ap_name(::std::string&& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.station.ap_name)
}
#endif
inline void station::set_ap_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.station.ap_name)
}
inline void station::set_ap_name(const char* value, size_t size) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.station.ap_name)
}
inline ::std::string* station::mutable_ap_name() {
  set_has_ap_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.station.ap_name)
  return ap_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* station::release_ap_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.station.ap_name)
  if (!has_ap_name()) {
    return NULL;
  }
  clear_has_ap_name();
  return ap_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void station::set_allocated_ap_name(::std::string* ap_name) {
  if (ap_name != NULL) {
    set_has_ap_name();
  } else {
    clear_has_ap_name();
  }
  ap_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ap_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.station.ap_name)
}

// -------------------------------------------------------------------

// access_point

// required .ce.nbapi.mac_address ap_eth_mac = 1;
inline bool access_point::has_ap_eth_mac() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void access_point::set_has_ap_eth_mac() {
  _has_bits_[0] |= 0x00000020u;
}
inline void access_point::clear_has_ap_eth_mac() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void access_point::clear_ap_eth_mac() {
  if (ap_eth_mac_ != NULL) ap_eth_mac_->Clear();
  clear_has_ap_eth_mac();
}
inline const ::ce::nbapi::mac_address& access_point::_internal_ap_eth_mac() const {
  return *ap_eth_mac_;
}
inline const ::ce::nbapi::mac_address& access_point::ap_eth_mac() const {
  const ::ce::nbapi::mac_address* p = ap_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.ap_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* access_point::release_ap_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.access_point.ap_eth_mac)
  clear_has_ap_eth_mac();
  ::ce::nbapi::mac_address* temp = ap_eth_mac_;
  ap_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* access_point::mutable_ap_eth_mac() {
  set_has_ap_eth_mac();
  if (ap_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.access_point.ap_eth_mac)
  return ap_eth_mac_;
}
inline void access_point::set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_eth_mac_;
  }
  if (ap_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_eth_mac, submessage_arena);
    }
    set_has_ap_eth_mac();
  } else {
    clear_has_ap_eth_mac();
  }
  ap_eth_mac_ = ap_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.access_point.ap_eth_mac)
}

// optional string ap_name = 2;
inline bool access_point::has_ap_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void access_point::set_has_ap_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void access_point::clear_has_ap_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void access_point::clear_ap_name() {
  ap_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ap_name();
}
inline const ::std::string& access_point::ap_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.ap_name)
  return ap_name_.GetNoArena();
}
inline void access_point::set_ap_name(const ::std::string& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.access_point.ap_name)
}
#if LANG_CXX11
inline void access_point::set_ap_name(::std::string&& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.access_point.ap_name)
}
#endif
inline void access_point::set_ap_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.access_point.ap_name)
}
inline void access_point::set_ap_name(const char* value, size_t size) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.access_point.ap_name)
}
inline ::std::string* access_point::mutable_ap_name() {
  set_has_ap_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.access_point.ap_name)
  return ap_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* access_point::release_ap_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.access_point.ap_name)
  if (!has_ap_name()) {
    return NULL;
  }
  clear_has_ap_name();
  return ap_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void access_point::set_allocated_ap_name(::std::string* ap_name) {
  if (ap_name != NULL) {
    set_has_ap_name();
  } else {
    clear_has_ap_name();
  }
  ap_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ap_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.access_point.ap_name)
}

// optional string ap_group = 3;
inline bool access_point::has_ap_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void access_point::set_has_ap_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void access_point::clear_has_ap_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void access_point::clear_ap_group() {
  ap_group_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ap_group();
}
inline const ::std::string& access_point::ap_group() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.ap_group)
  return ap_group_.GetNoArena();
}
inline void access_point::set_ap_group(const ::std::string& value) {
  set_has_ap_group();
  ap_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.access_point.ap_group)
}
#if LANG_CXX11
inline void access_point::set_ap_group(::std::string&& value) {
  set_has_ap_group();
  ap_group_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.access_point.ap_group)
}
#endif
inline void access_point::set_ap_group(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ap_group();
  ap_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.access_point.ap_group)
}
inline void access_point::set_ap_group(const char* value, size_t size) {
  set_has_ap_group();
  ap_group_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.access_point.ap_group)
}
inline ::std::string* access_point::mutable_ap_group() {
  set_has_ap_group();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.access_point.ap_group)
  return ap_group_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* access_point::release_ap_group() {
  // @@protoc_insertion_point(field_release:ce.nbapi.access_point.ap_group)
  if (!has_ap_group()) {
    return NULL;
  }
  clear_has_ap_group();
  return ap_group_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void access_point::set_allocated_ap_group(::std::string* ap_group) {
  if (ap_group != NULL) {
    set_has_ap_group();
  } else {
    clear_has_ap_group();
  }
  ap_group_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ap_group);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.access_point.ap_group)
}

// optional string ap_model = 4;
inline bool access_point::has_ap_model() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void access_point::set_has_ap_model() {
  _has_bits_[0] |= 0x00000004u;
}
inline void access_point::clear_has_ap_model() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void access_point::clear_ap_model() {
  ap_model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ap_model();
}
inline const ::std::string& access_point::ap_model() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.ap_model)
  return ap_model_.GetNoArena();
}
inline void access_point::set_ap_model(const ::std::string& value) {
  set_has_ap_model();
  ap_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.access_point.ap_model)
}
#if LANG_CXX11
inline void access_point::set_ap_model(::std::string&& value) {
  set_has_ap_model();
  ap_model_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.access_point.ap_model)
}
#endif
inline void access_point::set_ap_model(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ap_model();
  ap_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.access_point.ap_model)
}
inline void access_point::set_ap_model(const char* value, size_t size) {
  set_has_ap_model();
  ap_model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.access_point.ap_model)
}
inline ::std::string* access_point::mutable_ap_model() {
  set_has_ap_model();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.access_point.ap_model)
  return ap_model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* access_point::release_ap_model() {
  // @@protoc_insertion_point(field_release:ce.nbapi.access_point.ap_model)
  if (!has_ap_model()) {
    return NULL;
  }
  clear_has_ap_model();
  return ap_model_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void access_point::set_allocated_ap_model(::std::string* ap_model) {
  if (ap_model != NULL) {
    set_has_ap_model();
  } else {
    clear_has_ap_model();
  }
  ap_model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ap_model);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.access_point.ap_model)
}

// optional .ce.nbapi.access_point.deployment_mode depl_mode = 5;
inline bool access_point::has_depl_mode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void access_point::set_has_depl_mode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void access_point::clear_has_depl_mode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void access_point::clear_depl_mode() {
  depl_mode_ = 0;
  clear_has_depl_mode();
}
inline ::ce::nbapi::access_point_deployment_mode access_point::depl_mode() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.depl_mode)
  return static_cast< ::ce::nbapi::access_point_deployment_mode >(depl_mode_);
}
inline void access_point::set_depl_mode(::ce::nbapi::access_point_deployment_mode value) {
  assert(::ce::nbapi::access_point_deployment_mode_IsValid(value));
  set_has_depl_mode();
  depl_mode_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.access_point.depl_mode)
}

// optional .ce.nbapi.ip_address ap_ip_address = 6;
inline bool access_point::has_ap_ip_address() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void access_point::set_has_ap_ip_address() {
  _has_bits_[0] |= 0x00000040u;
}
inline void access_point::clear_has_ap_ip_address() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void access_point::clear_ap_ip_address() {
  if (ap_ip_address_ != NULL) ap_ip_address_->Clear();
  clear_has_ap_ip_address();
}
inline const ::ce::nbapi::ip_address& access_point::_internal_ap_ip_address() const {
  return *ap_ip_address_;
}
inline const ::ce::nbapi::ip_address& access_point::ap_ip_address() const {
  const ::ce::nbapi::ip_address* p = ap_ip_address_;
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.ap_ip_address)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* access_point::release_ap_ip_address() {
  // @@protoc_insertion_point(field_release:ce.nbapi.access_point.ap_ip_address)
  clear_has_ap_ip_address();
  ::ce::nbapi::ip_address* temp = ap_ip_address_;
  ap_ip_address_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* access_point::mutable_ap_ip_address() {
  set_has_ap_ip_address();
  if (ap_ip_address_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    ap_ip_address_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.access_point.ap_ip_address)
  return ap_ip_address_;
}
inline void access_point::set_allocated_ap_ip_address(::ce::nbapi::ip_address* ap_ip_address) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_ip_address_;
  }
  if (ap_ip_address) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_ip_address = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_ip_address, submessage_arena);
    }
    set_has_ap_ip_address();
  } else {
    clear_has_ap_ip_address();
  }
  ap_ip_address_ = ap_ip_address;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.access_point.ap_ip_address)
}

// optional uint32 reboots = 7;
inline bool access_point::has_reboots() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void access_point::set_has_reboots() {
  _has_bits_[0] |= 0x00000400u;
}
inline void access_point::clear_has_reboots() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void access_point::clear_reboots() {
  reboots_ = 0u;
  clear_has_reboots();
}
inline ::google::protobuf::uint32 access_point::reboots() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.reboots)
  return reboots_;
}
inline void access_point::set_reboots(::google::protobuf::uint32 value) {
  set_has_reboots();
  reboots_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.access_point.reboots)
}

// optional uint32 rebootstraps = 8;
inline bool access_point::has_rebootstraps() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void access_point::set_has_rebootstraps() {
  _has_bits_[0] |= 0x00000800u;
}
inline void access_point::clear_has_rebootstraps() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void access_point::clear_rebootstraps() {
  rebootstraps_ = 0u;
  clear_has_rebootstraps();
}
inline ::google::protobuf::uint32 access_point::rebootstraps() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.rebootstraps)
  return rebootstraps_;
}
inline void access_point::set_rebootstraps(::google::protobuf::uint32 value) {
  set_has_rebootstraps();
  rebootstraps_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.access_point.rebootstraps)
}

// optional .ce.nbapi.ip_address managed_by = 9;
inline bool access_point::has_managed_by() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void access_point::set_has_managed_by() {
  _has_bits_[0] |= 0x00000080u;
}
inline void access_point::clear_has_managed_by() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void access_point::clear_managed_by() {
  if (managed_by_ != NULL) managed_by_->Clear();
  clear_has_managed_by();
}
inline const ::ce::nbapi::ip_address& access_point::_internal_managed_by() const {
  return *managed_by_;
}
inline const ::ce::nbapi::ip_address& access_point::managed_by() const {
  const ::ce::nbapi::ip_address* p = managed_by_;
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.managed_by)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* access_point::release_managed_by() {
  // @@protoc_insertion_point(field_release:ce.nbapi.access_point.managed_by)
  clear_has_managed_by();
  ::ce::nbapi::ip_address* temp = managed_by_;
  managed_by_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* access_point::mutable_managed_by() {
  set_has_managed_by();
  if (managed_by_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    managed_by_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.access_point.managed_by)
  return managed_by_;
}
inline void access_point::set_allocated_managed_by(::ce::nbapi::ip_address* managed_by) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete managed_by_;
  }
  if (managed_by) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      managed_by = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, managed_by, submessage_arena);
    }
    set_has_managed_by();
  } else {
    clear_has_managed_by();
  }
  managed_by_ = managed_by;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.access_point.managed_by)
}

// optional string managed_by_key = 10;
inline bool access_point::has_managed_by_key() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void access_point::set_has_managed_by_key() {
  _has_bits_[0] |= 0x00000008u;
}
inline void access_point::clear_has_managed_by_key() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void access_point::clear_managed_by_key() {
  managed_by_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_managed_by_key();
}
inline const ::std::string& access_point::managed_by_key() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.managed_by_key)
  return managed_by_key_.GetNoArena();
}
inline void access_point::set_managed_by_key(const ::std::string& value) {
  set_has_managed_by_key();
  managed_by_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.access_point.managed_by_key)
}
#if LANG_CXX11
inline void access_point::set_managed_by_key(::std::string&& value) {
  set_has_managed_by_key();
  managed_by_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.access_point.managed_by_key)
}
#endif
inline void access_point::set_managed_by_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_managed_by_key();
  managed_by_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.access_point.managed_by_key)
}
inline void access_point::set_managed_by_key(const char* value, size_t size) {
  set_has_managed_by_key();
  managed_by_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.access_point.managed_by_key)
}
inline ::std::string* access_point::mutable_managed_by_key() {
  set_has_managed_by_key();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.access_point.managed_by_key)
  return managed_by_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* access_point::release_managed_by_key() {
  // @@protoc_insertion_point(field_release:ce.nbapi.access_point.managed_by_key)
  if (!has_managed_by_key()) {
    return NULL;
  }
  clear_has_managed_by_key();
  return managed_by_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void access_point::set_allocated_managed_by_key(::std::string* managed_by_key) {
  if (managed_by_key != NULL) {
    set_has_managed_by_key();
  } else {
    clear_has_managed_by_key();
  }
  managed_by_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), managed_by_key);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.access_point.managed_by_key)
}

// repeated .ce.nbapi.radio radios = 11;
inline int access_point::radios_size() const {
  return radios_.size();
}
inline void access_point::clear_radios() {
  radios_.Clear();
}
inline ::ce::nbapi::radio* access_point::mutable_radios(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.access_point.radios)
  return radios_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::radio >*
access_point::mutable_radios() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.access_point.radios)
  return &radios_;
}
inline const ::ce::nbapi::radio& access_point::radios(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.radios)
  return radios_.Get(index);
}
inline ::ce::nbapi::radio* access_point::add_radios() {
  // @@protoc_insertion_point(field_add:ce.nbapi.access_point.radios)
  return radios_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::radio >&
access_point::radios() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.access_point.radios)
  return radios_;
}

// optional bool is_master = 12 [deprecated = true];
inline bool access_point::has_is_master() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void access_point::set_has_is_master() {
  _has_bits_[0] |= 0x00001000u;
}
inline void access_point::clear_has_is_master() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void access_point::clear_is_master() {
  is_master_ = false;
  clear_has_is_master();
}
inline bool access_point::is_master() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.is_master)
  return is_master_;
}
inline void access_point::set_is_master(bool value) {
  set_has_is_master();
  is_master_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.access_point.is_master)
}

// optional string reboot_reason = 13;
inline bool access_point::has_reboot_reason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void access_point::set_has_reboot_reason() {
  _has_bits_[0] |= 0x00000010u;
}
inline void access_point::clear_has_reboot_reason() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void access_point::clear_reboot_reason() {
  reboot_reason_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_reboot_reason();
}
inline const ::std::string& access_point::reboot_reason() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.reboot_reason)
  return reboot_reason_.GetNoArena();
}
inline void access_point::set_reboot_reason(const ::std::string& value) {
  set_has_reboot_reason();
  reboot_reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.access_point.reboot_reason)
}
#if LANG_CXX11
inline void access_point::set_reboot_reason(::std::string&& value) {
  set_has_reboot_reason();
  reboot_reason_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.access_point.reboot_reason)
}
#endif
inline void access_point::set_reboot_reason(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_reboot_reason();
  reboot_reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.access_point.reboot_reason)
}
inline void access_point::set_reboot_reason(const char* value, size_t size) {
  set_has_reboot_reason();
  reboot_reason_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.access_point.reboot_reason)
}
inline ::std::string* access_point::mutable_reboot_reason() {
  set_has_reboot_reason();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.access_point.reboot_reason)
  return reboot_reason_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* access_point::release_reboot_reason() {
  // @@protoc_insertion_point(field_release:ce.nbapi.access_point.reboot_reason)
  if (!has_reboot_reason()) {
    return NULL;
  }
  clear_has_reboot_reason();
  return reboot_reason_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void access_point::set_allocated_reboot_reason(::std::string* reboot_reason) {
  if (reboot_reason != NULL) {
    set_has_reboot_reason();
  } else {
    clear_has_reboot_reason();
  }
  reboot_reason_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), reboot_reason);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.access_point.reboot_reason)
}

// optional .ce.nbapi.ap_location ap_location = 14;
inline bool access_point::has_ap_location() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void access_point::set_has_ap_location() {
  _has_bits_[0] |= 0x00000100u;
}
inline void access_point::clear_has_ap_location() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void access_point::clear_ap_location() {
  if (ap_location_ != NULL) ap_location_->Clear();
  clear_has_ap_location();
}
inline const ::ce::nbapi::ap_location& access_point::_internal_ap_location() const {
  return *ap_location_;
}
inline const ::ce::nbapi::ap_location& access_point::ap_location() const {
  const ::ce::nbapi::ap_location* p = ap_location_;
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.ap_location)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ap_location*>(
      &::ce::nbapi::_ap_location_default_instance_);
}
inline ::ce::nbapi::ap_location* access_point::release_ap_location() {
  // @@protoc_insertion_point(field_release:ce.nbapi.access_point.ap_location)
  clear_has_ap_location();
  ::ce::nbapi::ap_location* temp = ap_location_;
  ap_location_ = NULL;
  return temp;
}
inline ::ce::nbapi::ap_location* access_point::mutable_ap_location() {
  set_has_ap_location();
  if (ap_location_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ap_location>(GetArenaNoVirtual());
    ap_location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.access_point.ap_location)
  return ap_location_;
}
inline void access_point::set_allocated_ap_location(::ce::nbapi::ap_location* ap_location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_location_;
  }
  if (ap_location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_location, submessage_arena);
    }
    set_has_ap_location();
  } else {
    clear_has_ap_location();
  }
  ap_location_ = ap_location;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.access_point.ap_location)
}

// optional bool is_conductor = 15;
inline bool access_point::has_is_conductor() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void access_point::set_has_is_conductor() {
  _has_bits_[0] |= 0x00002000u;
}
inline void access_point::clear_has_is_conductor() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void access_point::clear_is_conductor() {
  is_conductor_ = false;
  clear_has_is_conductor();
}
inline bool access_point::is_conductor() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.access_point.is_conductor)
  return is_conductor_;
}
inline void access_point::set_is_conductor(bool value) {
  set_has_is_conductor();
  is_conductor_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.access_point.is_conductor)
}

// -------------------------------------------------------------------

// state_access_point

// optional .ce.nbapi.mac_address ap_mac = 1;
inline bool state_access_point::has_ap_mac() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void state_access_point::set_has_ap_mac() {
  _has_bits_[0] |= 0x00000020u;
}
inline void state_access_point::clear_has_ap_mac() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void state_access_point::clear_ap_mac() {
  if (ap_mac_ != NULL) ap_mac_->Clear();
  clear_has_ap_mac();
}
inline const ::ce::nbapi::mac_address& state_access_point::_internal_ap_mac() const {
  return *ap_mac_;
}
inline const ::ce::nbapi::mac_address& state_access_point::ap_mac() const {
  const ::ce::nbapi::mac_address* p = ap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.ap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* state_access_point::release_ap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.state_access_point.ap_mac)
  clear_has_ap_mac();
  ::ce::nbapi::mac_address* temp = ap_mac_;
  ap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* state_access_point::mutable_ap_mac() {
  set_has_ap_mac();
  if (ap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.state_access_point.ap_mac)
  return ap_mac_;
}
inline void state_access_point::set_allocated_ap_mac(::ce::nbapi::mac_address* ap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_mac_;
  }
  if (ap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_mac, submessage_arena);
    }
    set_has_ap_mac();
  } else {
    clear_has_ap_mac();
  }
  ap_mac_ = ap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.state_access_point.ap_mac)
}

// optional string serial_number = 2;
inline bool state_access_point::has_serial_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void state_access_point::set_has_serial_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void state_access_point::clear_has_serial_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void state_access_point::clear_serial_number() {
  serial_number_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_serial_number();
}
inline const ::std::string& state_access_point::serial_number() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.serial_number)
  return serial_number_.GetNoArena();
}
inline void state_access_point::set_serial_number(const ::std::string& value) {
  set_has_serial_number();
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.serial_number)
}
#if LANG_CXX11
inline void state_access_point::set_serial_number(::std::string&& value) {
  set_has_serial_number();
  serial_number_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.state_access_point.serial_number)
}
#endif
inline void state_access_point::set_serial_number(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_serial_number();
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.state_access_point.serial_number)
}
inline void state_access_point::set_serial_number(const char* value, size_t size) {
  set_has_serial_number();
  serial_number_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.state_access_point.serial_number)
}
inline ::std::string* state_access_point::mutable_serial_number() {
  set_has_serial_number();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.state_access_point.serial_number)
  return serial_number_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* state_access_point::release_serial_number() {
  // @@protoc_insertion_point(field_release:ce.nbapi.state_access_point.serial_number)
  if (!has_serial_number()) {
    return NULL;
  }
  clear_has_serial_number();
  return serial_number_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void state_access_point::set_allocated_serial_number(::std::string* serial_number) {
  if (serial_number != NULL) {
    set_has_serial_number();
  } else {
    clear_has_serial_number();
  }
  serial_number_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), serial_number);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.state_access_point.serial_number)
}

// optional string ap_name = 3;
inline bool state_access_point::has_ap_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void state_access_point::set_has_ap_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void state_access_point::clear_has_ap_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void state_access_point::clear_ap_name() {
  ap_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ap_name();
}
inline const ::std::string& state_access_point::ap_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.ap_name)
  return ap_name_.GetNoArena();
}
inline void state_access_point::set_ap_name(const ::std::string& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.ap_name)
}
#if LANG_CXX11
inline void state_access_point::set_ap_name(::std::string&& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.state_access_point.ap_name)
}
#endif
inline void state_access_point::set_ap_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.state_access_point.ap_name)
}
inline void state_access_point::set_ap_name(const char* value, size_t size) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.state_access_point.ap_name)
}
inline ::std::string* state_access_point::mutable_ap_name() {
  set_has_ap_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.state_access_point.ap_name)
  return ap_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* state_access_point::release_ap_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.state_access_point.ap_name)
  if (!has_ap_name()) {
    return NULL;
  }
  clear_has_ap_name();
  return ap_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void state_access_point::set_allocated_ap_name(::std::string* ap_name) {
  if (ap_name != NULL) {
    set_has_ap_name();
  } else {
    clear_has_ap_name();
  }
  ap_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ap_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.state_access_point.ap_name)
}

// optional string model = 4;
inline bool state_access_point::has_model() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void state_access_point::set_has_model() {
  _has_bits_[0] |= 0x00000004u;
}
inline void state_access_point::clear_has_model() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void state_access_point::clear_model() {
  model_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_model();
}
inline const ::std::string& state_access_point::model() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.model)
  return model_.GetNoArena();
}
inline void state_access_point::set_model(const ::std::string& value) {
  set_has_model();
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.model)
}
#if LANG_CXX11
inline void state_access_point::set_model(::std::string&& value) {
  set_has_model();
  model_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.state_access_point.model)
}
#endif
inline void state_access_point::set_model(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_model();
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.state_access_point.model)
}
inline void state_access_point::set_model(const char* value, size_t size) {
  set_has_model();
  model_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.state_access_point.model)
}
inline ::std::string* state_access_point::mutable_model() {
  set_has_model();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.state_access_point.model)
  return model_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* state_access_point::release_model() {
  // @@protoc_insertion_point(field_release:ce.nbapi.state_access_point.model)
  if (!has_model()) {
    return NULL;
  }
  clear_has_model();
  return model_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void state_access_point::set_allocated_model(::std::string* model) {
  if (model != NULL) {
    set_has_model();
  } else {
    clear_has_model();
  }
  model_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), model);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.state_access_point.model)
}

// optional string mode = 5;
inline bool state_access_point::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void state_access_point::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void state_access_point::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void state_access_point::clear_mode() {
  mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_mode();
}
inline const ::std::string& state_access_point::mode() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.mode)
  return mode_.GetNoArena();
}
inline void state_access_point::set_mode(const ::std::string& value) {
  set_has_mode();
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.mode)
}
#if LANG_CXX11
inline void state_access_point::set_mode(::std::string&& value) {
  set_has_mode();
  mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.state_access_point.mode)
}
#endif
inline void state_access_point::set_mode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_mode();
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.state_access_point.mode)
}
inline void state_access_point::set_mode(const char* value, size_t size) {
  set_has_mode();
  mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.state_access_point.mode)
}
inline ::std::string* state_access_point::mutable_mode() {
  set_has_mode();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.state_access_point.mode)
  return mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* state_access_point::release_mode() {
  // @@protoc_insertion_point(field_release:ce.nbapi.state_access_point.mode)
  if (!has_mode()) {
    return NULL;
  }
  clear_has_mode();
  return mode_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void state_access_point::set_allocated_mode(::std::string* mode) {
  if (mode != NULL) {
    set_has_mode();
  } else {
    clear_has_mode();
  }
  mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), mode);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.state_access_point.mode)
}

// optional .ce.nbapi.ip_address ap_ip = 6;
inline bool state_access_point::has_ap_ip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void state_access_point::set_has_ap_ip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void state_access_point::clear_has_ap_ip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void state_access_point::clear_ap_ip() {
  if (ap_ip_ != NULL) ap_ip_->Clear();
  clear_has_ap_ip();
}
inline const ::ce::nbapi::ip_address& state_access_point::_internal_ap_ip() const {
  return *ap_ip_;
}
inline const ::ce::nbapi::ip_address& state_access_point::ap_ip() const {
  const ::ce::nbapi::ip_address* p = ap_ip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.ap_ip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* state_access_point::release_ap_ip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.state_access_point.ap_ip)
  clear_has_ap_ip();
  ::ce::nbapi::ip_address* temp = ap_ip_;
  ap_ip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* state_access_point::mutable_ap_ip() {
  set_has_ap_ip();
  if (ap_ip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    ap_ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.state_access_point.ap_ip)
  return ap_ip_;
}
inline void state_access_point::set_allocated_ap_ip(::ce::nbapi::ip_address* ap_ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_ip_;
  }
  if (ap_ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_ip, submessage_arena);
    }
    set_has_ap_ip();
  } else {
    clear_has_ap_ip();
  }
  ap_ip_ = ap_ip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.state_access_point.ap_ip)
}

// optional uint32 cpu_usage = 7;
inline bool state_access_point::has_cpu_usage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void state_access_point::set_has_cpu_usage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void state_access_point::clear_has_cpu_usage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void state_access_point::clear_cpu_usage() {
  cpu_usage_ = 0u;
  clear_has_cpu_usage();
}
inline ::google::protobuf::uint32 state_access_point::cpu_usage() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.cpu_usage)
  return cpu_usage_;
}
inline void state_access_point::set_cpu_usage(::google::protobuf::uint32 value) {
  set_has_cpu_usage();
  cpu_usage_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.cpu_usage)
}

// optional uint32 memory_total = 8;
inline bool state_access_point::has_memory_total() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void state_access_point::set_has_memory_total() {
  _has_bits_[0] |= 0x00000100u;
}
inline void state_access_point::clear_has_memory_total() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void state_access_point::clear_memory_total() {
  memory_total_ = 0u;
  clear_has_memory_total();
}
inline ::google::protobuf::uint32 state_access_point::memory_total() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.memory_total)
  return memory_total_;
}
inline void state_access_point::set_memory_total(::google::protobuf::uint32 value) {
  set_has_memory_total();
  memory_total_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.memory_total)
}

// optional uint32 memory_free = 9;
inline bool state_access_point::has_memory_free() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void state_access_point::set_has_memory_free() {
  _has_bits_[0] |= 0x00000200u;
}
inline void state_access_point::clear_has_memory_free() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void state_access_point::clear_memory_free() {
  memory_free_ = 0u;
  clear_has_memory_free();
}
inline ::google::protobuf::uint32 state_access_point::memory_free() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.memory_free)
  return memory_free_;
}
inline void state_access_point::set_memory_free(::google::protobuf::uint32 value) {
  set_has_memory_free();
  memory_free_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.memory_free)
}

// optional uint32 is_master = 10 [deprecated = true];
inline bool state_access_point::has_is_master() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void state_access_point::set_has_is_master() {
  _has_bits_[0] |= 0x00000400u;
}
inline void state_access_point::clear_has_is_master() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void state_access_point::clear_is_master() {
  is_master_ = 0u;
  clear_has_is_master();
}
inline ::google::protobuf::uint32 state_access_point::is_master() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.is_master)
  return is_master_;
}
inline void state_access_point::set_is_master(::google::protobuf::uint32 value) {
  set_has_is_master();
  is_master_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.is_master)
}

// optional uint32 uptime = 11;
inline bool state_access_point::has_uptime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void state_access_point::set_has_uptime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void state_access_point::clear_has_uptime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void state_access_point::clear_uptime() {
  uptime_ = 0u;
  clear_has_uptime();
}
inline ::google::protobuf::uint32 state_access_point::uptime() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.uptime)
  return uptime_;
}
inline void state_access_point::set_uptime(::google::protobuf::uint32 value) {
  set_has_uptime();
  uptime_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.uptime)
}

// optional uint32 mesh_mode = 12;
inline bool state_access_point::has_mesh_mode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void state_access_point::set_has_mesh_mode() {
  _has_bits_[0] |= 0x00001000u;
}
inline void state_access_point::clear_has_mesh_mode() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void state_access_point::clear_mesh_mode() {
  mesh_mode_ = 0u;
  clear_has_mesh_mode();
}
inline ::google::protobuf::uint32 state_access_point::mesh_mode() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.mesh_mode)
  return mesh_mode_;
}
inline void state_access_point::set_mesh_mode(::google::protobuf::uint32 value) {
  set_has_mesh_mode();
  mesh_mode_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.mesh_mode)
}

// optional uint32 led_status = 13;
inline bool state_access_point::has_led_status() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void state_access_point::set_has_led_status() {
  _has_bits_[0] |= 0x00002000u;
}
inline void state_access_point::clear_has_led_status() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void state_access_point::clear_led_status() {
  led_status_ = 0u;
  clear_has_led_status();
}
inline ::google::protobuf::uint32 state_access_point::led_status() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.led_status)
  return led_status_;
}
inline void state_access_point::set_led_status(::google::protobuf::uint32 value) {
  set_has_led_status();
  led_status_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.led_status)
}

// optional uint32 ext_ssid_state = 16;
inline bool state_access_point::has_ext_ssid_state() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void state_access_point::set_has_ext_ssid_state() {
  _has_bits_[0] |= 0x00004000u;
}
inline void state_access_point::clear_has_ext_ssid_state() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void state_access_point::clear_ext_ssid_state() {
  ext_ssid_state_ = 0u;
  clear_has_ext_ssid_state();
}
inline ::google::protobuf::uint32 state_access_point::ext_ssid_state() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.ext_ssid_state)
  return ext_ssid_state_;
}
inline void state_access_point::set_ext_ssid_state(::google::protobuf::uint32 value) {
  set_has_ext_ssid_state();
  ext_ssid_state_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.ext_ssid_state)
}

// optional string service_tag = 17;
inline bool state_access_point::has_service_tag() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void state_access_point::set_has_service_tag() {
  _has_bits_[0] |= 0x00000010u;
}
inline void state_access_point::clear_has_service_tag() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void state_access_point::clear_service_tag() {
  service_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_service_tag();
}
inline const ::std::string& state_access_point::service_tag() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.service_tag)
  return service_tag_.GetNoArena();
}
inline void state_access_point::set_service_tag(const ::std::string& value) {
  set_has_service_tag();
  service_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.service_tag)
}
#if LANG_CXX11
inline void state_access_point::set_service_tag(::std::string&& value) {
  set_has_service_tag();
  service_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.state_access_point.service_tag)
}
#endif
inline void state_access_point::set_service_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_service_tag();
  service_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.state_access_point.service_tag)
}
inline void state_access_point::set_service_tag(const char* value, size_t size) {
  set_has_service_tag();
  service_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.state_access_point.service_tag)
}
inline ::std::string* state_access_point::mutable_service_tag() {
  set_has_service_tag();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.state_access_point.service_tag)
  return service_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* state_access_point::release_service_tag() {
  // @@protoc_insertion_point(field_release:ce.nbapi.state_access_point.service_tag)
  if (!has_service_tag()) {
    return NULL;
  }
  clear_has_service_tag();
  return service_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void state_access_point::set_allocated_service_tag(::std::string* service_tag) {
  if (service_tag != NULL) {
    set_has_service_tag();
  } else {
    clear_has_service_tag();
  }
  service_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), service_tag);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.state_access_point.service_tag)
}

// optional uint32 modem_status = 18;
inline bool state_access_point::has_modem_status() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void state_access_point::set_has_modem_status() {
  _has_bits_[0] |= 0x00008000u;
}
inline void state_access_point::clear_has_modem_status() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void state_access_point::clear_modem_status() {
  modem_status_ = 0u;
  clear_has_modem_status();
}
inline ::google::protobuf::uint32 state_access_point::modem_status() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.modem_status)
  return modem_status_;
}
inline void state_access_point::set_modem_status(::google::protobuf::uint32 value) {
  set_has_modem_status();
  modem_status_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.modem_status)
}

// optional uint32 modem_simpin_status = 19;
inline bool state_access_point::has_modem_simpin_status() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void state_access_point::set_has_modem_simpin_status() {
  _has_bits_[0] |= 0x00010000u;
}
inline void state_access_point::clear_has_modem_simpin_status() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void state_access_point::clear_modem_simpin_status() {
  modem_simpin_status_ = 0u;
  clear_has_modem_simpin_status();
}
inline ::google::protobuf::uint32 state_access_point::modem_simpin_status() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.modem_simpin_status)
  return modem_simpin_status_;
}
inline void state_access_point::set_modem_simpin_status(::google::protobuf::uint32 value) {
  set_has_modem_simpin_status();
  modem_simpin_status_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.modem_simpin_status)
}

// optional uint32 current_uplink_inuse = 20;
inline bool state_access_point::has_current_uplink_inuse() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void state_access_point::set_has_current_uplink_inuse() {
  _has_bits_[0] |= 0x00020000u;
}
inline void state_access_point::clear_has_current_uplink_inuse() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void state_access_point::clear_current_uplink_inuse() {
  current_uplink_inuse_ = 0u;
  clear_has_current_uplink_inuse();
}
inline ::google::protobuf::uint32 state_access_point::current_uplink_inuse() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.current_uplink_inuse)
  return current_uplink_inuse_;
}
inline void state_access_point::set_current_uplink_inuse(::google::protobuf::uint32 value) {
  set_has_current_uplink_inuse();
  current_uplink_inuse_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.current_uplink_inuse)
}

// optional uint32 is_conductor = 21;
inline bool state_access_point::has_is_conductor() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void state_access_point::set_has_is_conductor() {
  _has_bits_[0] |= 0x00040000u;
}
inline void state_access_point::clear_has_is_conductor() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void state_access_point::clear_is_conductor() {
  is_conductor_ = 0u;
  clear_has_is_conductor();
}
inline ::google::protobuf::uint32 state_access_point::is_conductor() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_access_point.is_conductor)
  return is_conductor_;
}
inline void state_access_point::set_is_conductor(::google::protobuf::uint32 value) {
  set_has_is_conductor();
  is_conductor_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_access_point.is_conductor)
}

// -------------------------------------------------------------------

// stats_modem

// optional .ce.nbapi.mac_address iap_mac = 1;
inline bool stats_modem::has_iap_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stats_modem::set_has_iap_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stats_modem::clear_has_iap_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stats_modem::clear_iap_mac() {
  if (iap_mac_ != NULL) iap_mac_->Clear();
  clear_has_iap_mac();
}
inline const ::ce::nbapi::mac_address& stats_modem::_internal_iap_mac() const {
  return *iap_mac_;
}
inline const ::ce::nbapi::mac_address& stats_modem::iap_mac() const {
  const ::ce::nbapi::mac_address* p = iap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_modem.iap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_modem::release_iap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_modem.iap_mac)
  clear_has_iap_mac();
  ::ce::nbapi::mac_address* temp = iap_mac_;
  iap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_modem::mutable_iap_mac() {
  set_has_iap_mac();
  if (iap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    iap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_modem.iap_mac)
  return iap_mac_;
}
inline void stats_modem::set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete iap_mac_;
  }
  if (iap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      iap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, iap_mac, submessage_arena);
    }
    set_has_iap_mac();
  } else {
    clear_has_iap_mac();
  }
  iap_mac_ = iap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_modem.iap_mac)
}

// optional uint64 tx_data_bytes = 2;
inline bool stats_modem::has_tx_data_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stats_modem::set_has_tx_data_bytes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stats_modem::clear_has_tx_data_bytes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stats_modem::clear_tx_data_bytes() {
  tx_data_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_data_bytes();
}
inline ::google::protobuf::uint64 stats_modem::tx_data_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_modem.tx_data_bytes)
  return tx_data_bytes_;
}
inline void stats_modem::set_tx_data_bytes(::google::protobuf::uint64 value) {
  set_has_tx_data_bytes();
  tx_data_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_modem.tx_data_bytes)
}

// optional uint64 rx_data_bytes = 3;
inline bool stats_modem::has_rx_data_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void stats_modem::set_has_rx_data_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void stats_modem::clear_has_rx_data_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void stats_modem::clear_rx_data_bytes() {
  rx_data_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_data_bytes();
}
inline ::google::protobuf::uint64 stats_modem::rx_data_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_modem.rx_data_bytes)
  return rx_data_bytes_;
}
inline void stats_modem::set_rx_data_bytes(::google::protobuf::uint64 value) {
  set_has_rx_data_bytes();
  rx_data_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_modem.rx_data_bytes)
}

// -------------------------------------------------------------------

// radio

// optional .ce.nbapi.mac_address ap_eth_mac = 1;
inline bool radio::has_ap_eth_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void radio::set_has_ap_eth_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void radio::clear_has_ap_eth_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void radio::clear_ap_eth_mac() {
  if (ap_eth_mac_ != NULL) ap_eth_mac_->Clear();
  clear_has_ap_eth_mac();
}
inline const ::ce::nbapi::mac_address& radio::_internal_ap_eth_mac() const {
  return *ap_eth_mac_;
}
inline const ::ce::nbapi::mac_address& radio::ap_eth_mac() const {
  const ::ce::nbapi::mac_address* p = ap_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.radio.ap_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* radio::release_ap_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.radio.ap_eth_mac)
  clear_has_ap_eth_mac();
  ::ce::nbapi::mac_address* temp = ap_eth_mac_;
  ap_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* radio::mutable_ap_eth_mac() {
  set_has_ap_eth_mac();
  if (ap_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.radio.ap_eth_mac)
  return ap_eth_mac_;
}
inline void radio::set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_eth_mac_;
  }
  if (ap_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_eth_mac, submessage_arena);
    }
    set_has_ap_eth_mac();
  } else {
    clear_has_ap_eth_mac();
  }
  ap_eth_mac_ = ap_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.radio.ap_eth_mac)
}

// required .ce.nbapi.mac_address radio_bssid = 2;
inline bool radio::has_radio_bssid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void radio::set_has_radio_bssid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void radio::clear_has_radio_bssid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void radio::clear_radio_bssid() {
  if (radio_bssid_ != NULL) radio_bssid_->Clear();
  clear_has_radio_bssid();
}
inline const ::ce::nbapi::mac_address& radio::_internal_radio_bssid() const {
  return *radio_bssid_;
}
inline const ::ce::nbapi::mac_address& radio::radio_bssid() const {
  const ::ce::nbapi::mac_address* p = radio_bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.radio.radio_bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* radio::release_radio_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.radio.radio_bssid)
  clear_has_radio_bssid();
  ::ce::nbapi::mac_address* temp = radio_bssid_;
  radio_bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* radio::mutable_radio_bssid() {
  set_has_radio_bssid();
  if (radio_bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    radio_bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.radio.radio_bssid)
  return radio_bssid_;
}
inline void radio::set_allocated_radio_bssid(::ce::nbapi::mac_address* radio_bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radio_bssid_;
  }
  if (radio_bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radio_bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radio_bssid, submessage_arena);
    }
    set_has_radio_bssid();
  } else {
    clear_has_radio_bssid();
  }
  radio_bssid_ = radio_bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.radio.radio_bssid)
}

// optional .ce.nbapi.radio.radio_mode mode = 4;
inline bool radio::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void radio::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void radio::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void radio::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::ce::nbapi::radio_radio_mode radio::mode() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.radio.mode)
  return static_cast< ::ce::nbapi::radio_radio_mode >(mode_);
}
inline void radio::set_mode(::ce::nbapi::radio_radio_mode value) {
  assert(::ce::nbapi::radio_radio_mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.radio.mode)
}

// optional .ce.nbapi.phy_type phy = 5;
inline bool radio::has_phy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void radio::set_has_phy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void radio::clear_has_phy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void radio::clear_phy() {
  phy_ = 0;
  clear_has_phy();
}
inline ::ce::nbapi::phy_type radio::phy() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.radio.phy)
  return static_cast< ::ce::nbapi::phy_type >(phy_);
}
inline void radio::set_phy(::ce::nbapi::phy_type value) {
  assert(::ce::nbapi::phy_type_IsValid(value));
  set_has_phy();
  phy_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.radio.phy)
}

// optional .ce.nbapi.ht_type ht = 6;
inline bool radio::has_ht() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void radio::set_has_ht() {
  _has_bits_[0] |= 0x00000010u;
}
inline void radio::clear_has_ht() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void radio::clear_ht() {
  ht_ = 0;
  clear_has_ht();
}
inline ::ce::nbapi::ht_type radio::ht() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.radio.ht)
  return static_cast< ::ce::nbapi::ht_type >(ht_);
}
inline void radio::set_ht(::ce::nbapi::ht_type value) {
  assert(::ce::nbapi::ht_type_IsValid(value));
  set_has_ht();
  ht_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.radio.ht)
}

// repeated .ce.nbapi.virtual_access_point virtual_access_points = 7;
inline int radio::virtual_access_points_size() const {
  return virtual_access_points_.size();
}
inline void radio::clear_virtual_access_points() {
  virtual_access_points_.Clear();
}
inline ::ce::nbapi::virtual_access_point* radio::mutable_virtual_access_points(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.radio.virtual_access_points)
  return virtual_access_points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::virtual_access_point >*
radio::mutable_virtual_access_points() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.radio.virtual_access_points)
  return &virtual_access_points_;
}
inline const ::ce::nbapi::virtual_access_point& radio::virtual_access_points(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.radio.virtual_access_points)
  return virtual_access_points_.Get(index);
}
inline ::ce::nbapi::virtual_access_point* radio::add_virtual_access_points() {
  // @@protoc_insertion_point(field_add:ce.nbapi.radio.virtual_access_points)
  return virtual_access_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::virtual_access_point >&
radio::virtual_access_points() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.radio.virtual_access_points)
  return virtual_access_points_;
}

// optional uint32 radio_num = 8;
inline bool radio::has_radio_num() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void radio::set_has_radio_num() {
  _has_bits_[0] |= 0x00000020u;
}
inline void radio::clear_has_radio_num() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void radio::clear_radio_num() {
  radio_num_ = 0u;
  clear_has_radio_num();
}
inline ::google::protobuf::uint32 radio::radio_num() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.radio.radio_num)
  return radio_num_;
}
inline void radio::set_radio_num(::google::protobuf::uint32 value) {
  set_has_radio_num();
  radio_num_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.radio.radio_num)
}

// -------------------------------------------------------------------

// virtual_access_point

// required .ce.nbapi.mac_address bssid = 1;
inline bool virtual_access_point::has_bssid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void virtual_access_point::set_has_bssid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void virtual_access_point::clear_has_bssid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void virtual_access_point::clear_bssid() {
  if (bssid_ != NULL) bssid_->Clear();
  clear_has_bssid();
}
inline const ::ce::nbapi::mac_address& virtual_access_point::_internal_bssid() const {
  return *bssid_;
}
inline const ::ce::nbapi::mac_address& virtual_access_point::bssid() const {
  const ::ce::nbapi::mac_address* p = bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.virtual_access_point.bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* virtual_access_point::release_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.virtual_access_point.bssid)
  clear_has_bssid();
  ::ce::nbapi::mac_address* temp = bssid_;
  bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* virtual_access_point::mutable_bssid() {
  set_has_bssid();
  if (bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.virtual_access_point.bssid)
  return bssid_;
}
inline void virtual_access_point::set_allocated_bssid(::ce::nbapi::mac_address* bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bssid_;
  }
  if (bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bssid, submessage_arena);
    }
    set_has_bssid();
  } else {
    clear_has_bssid();
  }
  bssid_ = bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.virtual_access_point.bssid)
}

// optional string ssid = 2;
inline bool virtual_access_point::has_ssid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void virtual_access_point::set_has_ssid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void virtual_access_point::clear_has_ssid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void virtual_access_point::clear_ssid() {
  ssid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ssid();
}
inline const ::std::string& virtual_access_point::ssid() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.virtual_access_point.ssid)
  return ssid_.GetNoArena();
}
inline void virtual_access_point::set_ssid(const ::std::string& value) {
  set_has_ssid();
  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.virtual_access_point.ssid)
}
#if LANG_CXX11
inline void virtual_access_point::set_ssid(::std::string&& value) {
  set_has_ssid();
  ssid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.virtual_access_point.ssid)
}
#endif
inline void virtual_access_point::set_ssid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ssid();
  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.virtual_access_point.ssid)
}
inline void virtual_access_point::set_ssid(const char* value, size_t size) {
  set_has_ssid();
  ssid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.virtual_access_point.ssid)
}
inline ::std::string* virtual_access_point::mutable_ssid() {
  set_has_ssid();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.virtual_access_point.ssid)
  return ssid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* virtual_access_point::release_ssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.virtual_access_point.ssid)
  if (!has_ssid()) {
    return NULL;
  }
  clear_has_ssid();
  return ssid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void virtual_access_point::set_allocated_ssid(::std::string* ssid) {
  if (ssid != NULL) {
    set_has_ssid();
  } else {
    clear_has_ssid();
  }
  ssid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ssid);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.virtual_access_point.ssid)
}

// optional .ce.nbapi.mac_address radio_bssid = 3;
inline bool virtual_access_point::has_radio_bssid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void virtual_access_point::set_has_radio_bssid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void virtual_access_point::clear_has_radio_bssid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void virtual_access_point::clear_radio_bssid() {
  if (radio_bssid_ != NULL) radio_bssid_->Clear();
  clear_has_radio_bssid();
}
inline const ::ce::nbapi::mac_address& virtual_access_point::_internal_radio_bssid() const {
  return *radio_bssid_;
}
inline const ::ce::nbapi::mac_address& virtual_access_point::radio_bssid() const {
  const ::ce::nbapi::mac_address* p = radio_bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.virtual_access_point.radio_bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* virtual_access_point::release_radio_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.virtual_access_point.radio_bssid)
  clear_has_radio_bssid();
  ::ce::nbapi::mac_address* temp = radio_bssid_;
  radio_bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* virtual_access_point::mutable_radio_bssid() {
  set_has_radio_bssid();
  if (radio_bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    radio_bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.virtual_access_point.radio_bssid)
  return radio_bssid_;
}
inline void virtual_access_point::set_allocated_radio_bssid(::ce::nbapi::mac_address* radio_bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radio_bssid_;
  }
  if (radio_bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radio_bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radio_bssid, submessage_arena);
    }
    set_has_radio_bssid();
  } else {
    clear_has_radio_bssid();
  }
  radio_bssid_ = radio_bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.virtual_access_point.radio_bssid)
}

// -------------------------------------------------------------------

// destination

// optional .ce.nbapi.ip_address dest_ip = 1;
inline bool destination::has_dest_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void destination::set_has_dest_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void destination::clear_has_dest_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void destination::clear_dest_ip() {
  if (dest_ip_ != NULL) dest_ip_->Clear();
  clear_has_dest_ip();
}
inline const ::ce::nbapi::ip_address& destination::_internal_dest_ip() const {
  return *dest_ip_;
}
inline const ::ce::nbapi::ip_address& destination::dest_ip() const {
  const ::ce::nbapi::ip_address* p = dest_ip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.destination.dest_ip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* destination::release_dest_ip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.destination.dest_ip)
  clear_has_dest_ip();
  ::ce::nbapi::ip_address* temp = dest_ip_;
  dest_ip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* destination::mutable_dest_ip() {
  set_has_dest_ip();
  if (dest_ip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    dest_ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.destination.dest_ip)
  return dest_ip_;
}
inline void destination::set_allocated_dest_ip(::ce::nbapi::ip_address* dest_ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dest_ip_;
  }
  if (dest_ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dest_ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dest_ip, submessage_arena);
    }
    set_has_dest_ip();
  } else {
    clear_has_dest_ip();
  }
  dest_ip_ = dest_ip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.destination.dest_ip)
}

// optional string dest_name = 2;
inline bool destination::has_dest_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void destination::set_has_dest_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void destination::clear_has_dest_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void destination::clear_dest_name() {
  dest_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dest_name();
}
inline const ::std::string& destination::dest_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.destination.dest_name)
  return dest_name_.GetNoArena();
}
inline void destination::set_dest_name(const ::std::string& value) {
  set_has_dest_name();
  dest_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.destination.dest_name)
}
#if LANG_CXX11
inline void destination::set_dest_name(::std::string&& value) {
  set_has_dest_name();
  dest_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.destination.dest_name)
}
#endif
inline void destination::set_dest_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dest_name();
  dest_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.destination.dest_name)
}
inline void destination::set_dest_name(const char* value, size_t size) {
  set_has_dest_name();
  dest_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.destination.dest_name)
}
inline ::std::string* destination::mutable_dest_name() {
  set_has_dest_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.destination.dest_name)
  return dest_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* destination::release_dest_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.destination.dest_name)
  if (!has_dest_name()) {
    return NULL;
  }
  clear_has_dest_name();
  return dest_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void destination::set_allocated_dest_name(::std::string* dest_name) {
  if (dest_name != NULL) {
    set_has_dest_name();
  } else {
    clear_has_dest_name();
  }
  dest_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.destination.dest_name)
}

// optional string dest_alias_name = 3;
inline bool destination::has_dest_alias_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void destination::set_has_dest_alias_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void destination::clear_has_dest_alias_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void destination::clear_dest_alias_name() {
  dest_alias_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_dest_alias_name();
}
inline const ::std::string& destination::dest_alias_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.destination.dest_alias_name)
  return dest_alias_name_.GetNoArena();
}
inline void destination::set_dest_alias_name(const ::std::string& value) {
  set_has_dest_alias_name();
  dest_alias_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.destination.dest_alias_name)
}
#if LANG_CXX11
inline void destination::set_dest_alias_name(::std::string&& value) {
  set_has_dest_alias_name();
  dest_alias_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.destination.dest_alias_name)
}
#endif
inline void destination::set_dest_alias_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_dest_alias_name();
  dest_alias_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.destination.dest_alias_name)
}
inline void destination::set_dest_alias_name(const char* value, size_t size) {
  set_has_dest_alias_name();
  dest_alias_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.destination.dest_alias_name)
}
inline ::std::string* destination::mutable_dest_alias_name() {
  set_has_dest_alias_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.destination.dest_alias_name)
  return dest_alias_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* destination::release_dest_alias_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.destination.dest_alias_name)
  if (!has_dest_alias_name()) {
    return NULL;
  }
  clear_has_dest_alias_name();
  return dest_alias_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void destination::set_allocated_dest_alias_name(::std::string* dest_alias_name) {
  if (dest_alias_name != NULL) {
    set_has_dest_alias_name();
  } else {
    clear_has_dest_alias_name();
  }
  dest_alias_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dest_alias_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.destination.dest_alias_name)
}

// -------------------------------------------------------------------

// application

// optional uint32 app_id = 1;
inline bool application::has_app_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void application::set_has_app_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void application::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void application::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 application::app_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.application.app_id)
  return app_id_;
}
inline void application::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.application.app_id)
}

// optional string app_name = 2;
inline bool application::has_app_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void application::set_has_app_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void application::clear_has_app_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void application::clear_app_name() {
  app_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_app_name();
}
inline const ::std::string& application::app_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.application.app_name)
  return app_name_.GetNoArena();
}
inline void application::set_app_name(const ::std::string& value) {
  set_has_app_name();
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.application.app_name)
}
#if LANG_CXX11
inline void application::set_app_name(::std::string&& value) {
  set_has_app_name();
  app_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.application.app_name)
}
#endif
inline void application::set_app_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_app_name();
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.application.app_name)
}
inline void application::set_app_name(const char* value, size_t size) {
  set_has_app_name();
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.application.app_name)
}
inline ::std::string* application::mutable_app_name() {
  set_has_app_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.application.app_name)
  return app_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* application::release_app_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.application.app_name)
  if (!has_app_name()) {
    return NULL;
  }
  clear_has_app_name();
  return app_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void application::set_allocated_app_name(::std::string* app_name) {
  if (app_name != NULL) {
    set_has_app_name();
  } else {
    clear_has_app_name();
  }
  app_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.application.app_name)
}

// optional string app_family = 3;
inline bool application::has_app_family() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void application::set_has_app_family() {
  _has_bits_[0] |= 0x00000002u;
}
inline void application::clear_has_app_family() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void application::clear_app_family() {
  app_family_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_app_family();
}
inline const ::std::string& application::app_family() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.application.app_family)
  return app_family_.GetNoArena();
}
inline void application::set_app_family(const ::std::string& value) {
  set_has_app_family();
  app_family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.application.app_family)
}
#if LANG_CXX11
inline void application::set_app_family(::std::string&& value) {
  set_has_app_family();
  app_family_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.application.app_family)
}
#endif
inline void application::set_app_family(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_app_family();
  app_family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.application.app_family)
}
inline void application::set_app_family(const char* value, size_t size) {
  set_has_app_family();
  app_family_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.application.app_family)
}
inline ::std::string* application::mutable_app_family() {
  set_has_app_family();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.application.app_family)
  return app_family_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* application::release_app_family() {
  // @@protoc_insertion_point(field_release:ce.nbapi.application.app_family)
  if (!has_app_family()) {
    return NULL;
  }
  clear_has_app_family();
  return app_family_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void application::set_allocated_app_family(::std::string* app_family) {
  if (app_family != NULL) {
    set_has_app_family();
  } else {
    clear_has_app_family();
  }
  app_family_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_family);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.application.app_family)
}

// optional string app_long_name = 4;
inline bool application::has_app_long_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void application::set_has_app_long_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void application::clear_has_app_long_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void application::clear_app_long_name() {
  app_long_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_app_long_name();
}
inline const ::std::string& application::app_long_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.application.app_long_name)
  return app_long_name_.GetNoArena();
}
inline void application::set_app_long_name(const ::std::string& value) {
  set_has_app_long_name();
  app_long_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.application.app_long_name)
}
#if LANG_CXX11
inline void application::set_app_long_name(::std::string&& value) {
  set_has_app_long_name();
  app_long_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.application.app_long_name)
}
#endif
inline void application::set_app_long_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_app_long_name();
  app_long_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.application.app_long_name)
}
inline void application::set_app_long_name(const char* value, size_t size) {
  set_has_app_long_name();
  app_long_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.application.app_long_name)
}
inline ::std::string* application::mutable_app_long_name() {
  set_has_app_long_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.application.app_long_name)
  return app_long_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* application::release_app_long_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.application.app_long_name)
  if (!has_app_long_name()) {
    return NULL;
  }
  clear_has_app_long_name();
  return app_long_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void application::set_allocated_app_long_name(::std::string* app_long_name) {
  if (app_long_name != NULL) {
    set_has_app_long_name();
  } else {
    clear_has_app_long_name();
  }
  app_long_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_long_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.application.app_long_name)
}

// -------------------------------------------------------------------

// webcc_category

// optional uint32 cat_id = 1;
inline bool webcc_category::has_cat_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void webcc_category::set_has_cat_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void webcc_category::clear_has_cat_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void webcc_category::clear_cat_id() {
  cat_id_ = 0u;
  clear_has_cat_id();
}
inline ::google::protobuf::uint32 webcc_category::cat_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.webcc_category.cat_id)
  return cat_id_;
}
inline void webcc_category::set_cat_id(::google::protobuf::uint32 value) {
  set_has_cat_id();
  cat_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.webcc_category.cat_id)
}

// optional string category = 2;
inline bool webcc_category::has_category() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void webcc_category::set_has_category() {
  _has_bits_[0] |= 0x00000001u;
}
inline void webcc_category::clear_has_category() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void webcc_category::clear_category() {
  category_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_category();
}
inline const ::std::string& webcc_category::category() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.webcc_category.category)
  return category_.GetNoArena();
}
inline void webcc_category::set_category(const ::std::string& value) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.webcc_category.category)
}
#if LANG_CXX11
inline void webcc_category::set_category(::std::string&& value) {
  set_has_category();
  category_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.webcc_category.category)
}
#endif
inline void webcc_category::set_category(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.webcc_category.category)
}
inline void webcc_category::set_category(const char* value, size_t size) {
  set_has_category();
  category_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.webcc_category.category)
}
inline ::std::string* webcc_category::mutable_category() {
  set_has_category();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.webcc_category.category)
  return category_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* webcc_category::release_category() {
  // @@protoc_insertion_point(field_release:ce.nbapi.webcc_category.category)
  if (!has_category()) {
    return NULL;
  }
  clear_has_category();
  return category_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void webcc_category::set_allocated_category(::std::string* category) {
  if (category != NULL) {
    set_has_category();
  } else {
    clear_has_category();
  }
  category_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), category);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.webcc_category.category)
}

// -------------------------------------------------------------------

// webcc_info

// optional bytes webcc_md5 = 1;
inline bool webcc_info::has_webcc_md5() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void webcc_info::set_has_webcc_md5() {
  _has_bits_[0] |= 0x00000001u;
}
inline void webcc_info::clear_has_webcc_md5() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void webcc_info::clear_webcc_md5() {
  webcc_md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_webcc_md5();
}
inline const ::std::string& webcc_info::webcc_md5() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.webcc_info.webcc_md5)
  return webcc_md5_.GetNoArena();
}
inline void webcc_info::set_webcc_md5(const ::std::string& value) {
  set_has_webcc_md5();
  webcc_md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.webcc_info.webcc_md5)
}
#if LANG_CXX11
inline void webcc_info::set_webcc_md5(::std::string&& value) {
  set_has_webcc_md5();
  webcc_md5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.webcc_info.webcc_md5)
}
#endif
inline void webcc_info::set_webcc_md5(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_webcc_md5();
  webcc_md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.webcc_info.webcc_md5)
}
inline void webcc_info::set_webcc_md5(const void* value, size_t size) {
  set_has_webcc_md5();
  webcc_md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.webcc_info.webcc_md5)
}
inline ::std::string* webcc_info::mutable_webcc_md5() {
  set_has_webcc_md5();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.webcc_info.webcc_md5)
  return webcc_md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* webcc_info::release_webcc_md5() {
  // @@protoc_insertion_point(field_release:ce.nbapi.webcc_info.webcc_md5)
  if (!has_webcc_md5()) {
    return NULL;
  }
  clear_has_webcc_md5();
  return webcc_md5_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void webcc_info::set_allocated_webcc_md5(::std::string* webcc_md5) {
  if (webcc_md5 != NULL) {
    set_has_webcc_md5();
  } else {
    clear_has_webcc_md5();
  }
  webcc_md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), webcc_md5);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.webcc_info.webcc_md5)
}

// optional uint32 webcc_cat_id = 2;
inline bool webcc_info::has_webcc_cat_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void webcc_info::set_has_webcc_cat_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void webcc_info::clear_has_webcc_cat_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void webcc_info::clear_webcc_cat_id() {
  webcc_cat_id_ = 0u;
  clear_has_webcc_cat_id();
}
inline ::google::protobuf::uint32 webcc_info::webcc_cat_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.webcc_info.webcc_cat_id)
  return webcc_cat_id_;
}
inline void webcc_info::set_webcc_cat_id(::google::protobuf::uint32 value) {
  set_has_webcc_cat_id();
  webcc_cat_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.webcc_info.webcc_cat_id)
}

// optional uint32 webcc_rep_score = 3;
inline bool webcc_info::has_webcc_rep_score() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void webcc_info::set_has_webcc_rep_score() {
  _has_bits_[0] |= 0x00000008u;
}
inline void webcc_info::clear_has_webcc_rep_score() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void webcc_info::clear_webcc_rep_score() {
  webcc_rep_score_ = 0u;
  clear_has_webcc_rep_score();
}
inline ::google::protobuf::uint32 webcc_info::webcc_rep_score() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.webcc_info.webcc_rep_score)
  return webcc_rep_score_;
}
inline void webcc_info::set_webcc_rep_score(::google::protobuf::uint32 value) {
  set_has_webcc_rep_score();
  webcc_rep_score_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.webcc_info.webcc_rep_score)
}

// optional string webcc_url_prefix = 4;
inline bool webcc_info::has_webcc_url_prefix() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void webcc_info::set_has_webcc_url_prefix() {
  _has_bits_[0] |= 0x00000002u;
}
inline void webcc_info::clear_has_webcc_url_prefix() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void webcc_info::clear_webcc_url_prefix() {
  webcc_url_prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_webcc_url_prefix();
}
inline const ::std::string& webcc_info::webcc_url_prefix() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.webcc_info.webcc_url_prefix)
  return webcc_url_prefix_.GetNoArena();
}
inline void webcc_info::set_webcc_url_prefix(const ::std::string& value) {
  set_has_webcc_url_prefix();
  webcc_url_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.webcc_info.webcc_url_prefix)
}
#if LANG_CXX11
inline void webcc_info::set_webcc_url_prefix(::std::string&& value) {
  set_has_webcc_url_prefix();
  webcc_url_prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.webcc_info.webcc_url_prefix)
}
#endif
inline void webcc_info::set_webcc_url_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_webcc_url_prefix();
  webcc_url_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.webcc_info.webcc_url_prefix)
}
inline void webcc_info::set_webcc_url_prefix(const char* value, size_t size) {
  set_has_webcc_url_prefix();
  webcc_url_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.webcc_info.webcc_url_prefix)
}
inline ::std::string* webcc_info::mutable_webcc_url_prefix() {
  set_has_webcc_url_prefix();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.webcc_info.webcc_url_prefix)
  return webcc_url_prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* webcc_info::release_webcc_url_prefix() {
  // @@protoc_insertion_point(field_release:ce.nbapi.webcc_info.webcc_url_prefix)
  if (!has_webcc_url_prefix()) {
    return NULL;
  }
  clear_has_webcc_url_prefix();
  return webcc_url_prefix_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void webcc_info::set_allocated_webcc_url_prefix(::std::string* webcc_url_prefix) {
  if (webcc_url_prefix != NULL) {
    set_has_webcc_url_prefix();
  } else {
    clear_has_webcc_url_prefix();
  }
  webcc_url_prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), webcc_url_prefix);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.webcc_info.webcc_url_prefix)
}

// optional bool webcc_not_supported = 5;
inline bool webcc_info::has_webcc_not_supported() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void webcc_info::set_has_webcc_not_supported() {
  _has_bits_[0] |= 0x00000010u;
}
inline void webcc_info::clear_has_webcc_not_supported() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void webcc_info::clear_webcc_not_supported() {
  webcc_not_supported_ = false;
  clear_has_webcc_not_supported();
}
inline bool webcc_info::webcc_not_supported() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.webcc_info.webcc_not_supported)
  return webcc_not_supported_;
}
inline void webcc_info::set_webcc_not_supported(bool value) {
  set_has_webcc_not_supported();
  webcc_not_supported_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.webcc_info.webcc_not_supported)
}

// -------------------------------------------------------------------

// visibility_rec

// optional .ce.nbapi.ip_address client_ip = 1;
inline bool visibility_rec::has_client_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void visibility_rec::set_has_client_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void visibility_rec::clear_has_client_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void visibility_rec::clear_client_ip() {
  if (client_ip_ != NULL) client_ip_->Clear();
  clear_has_client_ip();
}
inline const ::ce::nbapi::ip_address& visibility_rec::_internal_client_ip() const {
  return *client_ip_;
}
inline const ::ce::nbapi::ip_address& visibility_rec::client_ip() const {
  const ::ce::nbapi::ip_address* p = client_ip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.client_ip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* visibility_rec::release_client_ip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.visibility_rec.client_ip)
  clear_has_client_ip();
  ::ce::nbapi::ip_address* temp = client_ip_;
  client_ip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* visibility_rec::mutable_client_ip() {
  set_has_client_ip();
  if (client_ip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    client_ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.visibility_rec.client_ip)
  return client_ip_;
}
inline void visibility_rec::set_allocated_client_ip(::ce::nbapi::ip_address* client_ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete client_ip_;
  }
  if (client_ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_ip, submessage_arena);
    }
    set_has_client_ip();
  } else {
    clear_has_client_ip();
  }
  client_ip_ = client_ip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.visibility_rec.client_ip)
}

// optional .ce.nbapi.ip_address dest_ip = 2;
inline bool visibility_rec::has_dest_ip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void visibility_rec::set_has_dest_ip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void visibility_rec::clear_has_dest_ip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void visibility_rec::clear_dest_ip() {
  if (dest_ip_ != NULL) dest_ip_->Clear();
  clear_has_dest_ip();
}
inline const ::ce::nbapi::ip_address& visibility_rec::_internal_dest_ip() const {
  return *dest_ip_;
}
inline const ::ce::nbapi::ip_address& visibility_rec::dest_ip() const {
  const ::ce::nbapi::ip_address* p = dest_ip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.dest_ip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* visibility_rec::release_dest_ip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.visibility_rec.dest_ip)
  clear_has_dest_ip();
  ::ce::nbapi::ip_address* temp = dest_ip_;
  dest_ip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* visibility_rec::mutable_dest_ip() {
  set_has_dest_ip();
  if (dest_ip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    dest_ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.visibility_rec.dest_ip)
  return dest_ip_;
}
inline void visibility_rec::set_allocated_dest_ip(::ce::nbapi::ip_address* dest_ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dest_ip_;
  }
  if (dest_ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dest_ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dest_ip, submessage_arena);
    }
    set_has_dest_ip();
  } else {
    clear_has_dest_ip();
  }
  dest_ip_ = dest_ip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.visibility_rec.dest_ip)
}

// optional .ce.nbapi.visibility_rec.ip_protocol ip_proto = 3;
inline bool visibility_rec::has_ip_proto() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void visibility_rec::set_has_ip_proto() {
  _has_bits_[0] |= 0x00010000u;
}
inline void visibility_rec::clear_has_ip_proto() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void visibility_rec::clear_ip_proto() {
  ip_proto_ = 6;
  clear_has_ip_proto();
}
inline ::ce::nbapi::visibility_rec_ip_protocol visibility_rec::ip_proto() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.ip_proto)
  return static_cast< ::ce::nbapi::visibility_rec_ip_protocol >(ip_proto_);
}
inline void visibility_rec::set_ip_proto(::ce::nbapi::visibility_rec_ip_protocol value) {
  assert(::ce::nbapi::visibility_rec_ip_protocol_IsValid(value));
  set_has_ip_proto();
  ip_proto_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.ip_proto)
}

// optional uint32 app_id = 4;
inline bool visibility_rec::has_app_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void visibility_rec::set_has_app_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void visibility_rec::clear_has_app_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void visibility_rec::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 visibility_rec::app_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.app_id)
  return app_id_;
}
inline void visibility_rec::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.app_id)
}

// optional uint64 tx_pkts = 5;
inline bool visibility_rec::has_tx_pkts() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void visibility_rec::set_has_tx_pkts() {
  _has_bits_[0] |= 0x00000200u;
}
inline void visibility_rec::clear_has_tx_pkts() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void visibility_rec::clear_tx_pkts() {
  tx_pkts_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_pkts();
}
inline ::google::protobuf::uint64 visibility_rec::tx_pkts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.tx_pkts)
  return tx_pkts_;
}
inline void visibility_rec::set_tx_pkts(::google::protobuf::uint64 value) {
  set_has_tx_pkts();
  tx_pkts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.tx_pkts)
}

// optional uint64 tx_bytes = 6;
inline bool visibility_rec::has_tx_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void visibility_rec::set_has_tx_bytes() {
  _has_bits_[0] |= 0x00000400u;
}
inline void visibility_rec::clear_has_tx_bytes() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void visibility_rec::clear_tx_bytes() {
  tx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_bytes();
}
inline ::google::protobuf::uint64 visibility_rec::tx_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.tx_bytes)
  return tx_bytes_;
}
inline void visibility_rec::set_tx_bytes(::google::protobuf::uint64 value) {
  set_has_tx_bytes();
  tx_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.tx_bytes)
}

// optional uint64 rx_pkts = 7;
inline bool visibility_rec::has_rx_pkts() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void visibility_rec::set_has_rx_pkts() {
  _has_bits_[0] |= 0x00000800u;
}
inline void visibility_rec::clear_has_rx_pkts() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void visibility_rec::clear_rx_pkts() {
  rx_pkts_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_pkts();
}
inline ::google::protobuf::uint64 visibility_rec::rx_pkts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.rx_pkts)
  return rx_pkts_;
}
inline void visibility_rec::set_rx_pkts(::google::protobuf::uint64 value) {
  set_has_rx_pkts();
  rx_pkts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.rx_pkts)
}

// optional uint64 rx_bytes = 8;
inline bool visibility_rec::has_rx_bytes() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void visibility_rec::set_has_rx_bytes() {
  _has_bits_[0] |= 0x00001000u;
}
inline void visibility_rec::clear_has_rx_bytes() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void visibility_rec::clear_rx_bytes() {
  rx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_bytes();
}
inline ::google::protobuf::uint64 visibility_rec::rx_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.rx_bytes)
  return rx_bytes_;
}
inline void visibility_rec::set_rx_bytes(::google::protobuf::uint64 value) {
  set_has_rx_bytes();
  rx_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.rx_bytes)
}

// optional bytes hashed_client_ip = 9;
inline bool visibility_rec::has_hashed_client_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void visibility_rec::set_has_hashed_client_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void visibility_rec::clear_has_hashed_client_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void visibility_rec::clear_hashed_client_ip() {
  hashed_client_ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hashed_client_ip();
}
inline const ::std::string& visibility_rec::hashed_client_ip() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.hashed_client_ip)
  return hashed_client_ip_.GetNoArena();
}
inline void visibility_rec::set_hashed_client_ip(const ::std::string& value) {
  set_has_hashed_client_ip();
  hashed_client_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.hashed_client_ip)
}
#if LANG_CXX11
inline void visibility_rec::set_hashed_client_ip(::std::string&& value) {
  set_has_hashed_client_ip();
  hashed_client_ip_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.visibility_rec.hashed_client_ip)
}
#endif
inline void visibility_rec::set_hashed_client_ip(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hashed_client_ip();
  hashed_client_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.visibility_rec.hashed_client_ip)
}
inline void visibility_rec::set_hashed_client_ip(const void* value, size_t size) {
  set_has_hashed_client_ip();
  hashed_client_ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.visibility_rec.hashed_client_ip)
}
inline ::std::string* visibility_rec::mutable_hashed_client_ip() {
  set_has_hashed_client_ip();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.visibility_rec.hashed_client_ip)
  return hashed_client_ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* visibility_rec::release_hashed_client_ip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.visibility_rec.hashed_client_ip)
  if (!has_hashed_client_ip()) {
    return NULL;
  }
  clear_has_hashed_client_ip();
  return hashed_client_ip_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void visibility_rec::set_allocated_hashed_client_ip(::std::string* hashed_client_ip) {
  if (hashed_client_ip != NULL) {
    set_has_hashed_client_ip();
  } else {
    clear_has_hashed_client_ip();
  }
  hashed_client_ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashed_client_ip);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.visibility_rec.hashed_client_ip)
}

// optional .ce.nbapi.mac_address device_mac = 10;
inline bool visibility_rec::has_device_mac() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void visibility_rec::set_has_device_mac() {
  _has_bits_[0] |= 0x00000080u;
}
inline void visibility_rec::clear_has_device_mac() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void visibility_rec::clear_device_mac() {
  if (device_mac_ != NULL) device_mac_->Clear();
  clear_has_device_mac();
}
inline const ::ce::nbapi::mac_address& visibility_rec::_internal_device_mac() const {
  return *device_mac_;
}
inline const ::ce::nbapi::mac_address& visibility_rec::device_mac() const {
  const ::ce::nbapi::mac_address* p = device_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.device_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* visibility_rec::release_device_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.visibility_rec.device_mac)
  clear_has_device_mac();
  ::ce::nbapi::mac_address* temp = device_mac_;
  device_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* visibility_rec::mutable_device_mac() {
  set_has_device_mac();
  if (device_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    device_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.visibility_rec.device_mac)
  return device_mac_;
}
inline void visibility_rec::set_allocated_device_mac(::ce::nbapi::mac_address* device_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete device_mac_;
  }
  if (device_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      device_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device_mac, submessage_arena);
    }
    set_has_device_mac();
  } else {
    clear_has_device_mac();
  }
  device_mac_ = device_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.visibility_rec.device_mac)
}

// optional bytes hashed_device_mac = 11;
inline bool visibility_rec::has_hashed_device_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void visibility_rec::set_has_hashed_device_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void visibility_rec::clear_has_hashed_device_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void visibility_rec::clear_hashed_device_mac() {
  hashed_device_mac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hashed_device_mac();
}
inline const ::std::string& visibility_rec::hashed_device_mac() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.hashed_device_mac)
  return hashed_device_mac_.GetNoArena();
}
inline void visibility_rec::set_hashed_device_mac(const ::std::string& value) {
  set_has_hashed_device_mac();
  hashed_device_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.hashed_device_mac)
}
#if LANG_CXX11
inline void visibility_rec::set_hashed_device_mac(::std::string&& value) {
  set_has_hashed_device_mac();
  hashed_device_mac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.visibility_rec.hashed_device_mac)
}
#endif
inline void visibility_rec::set_hashed_device_mac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hashed_device_mac();
  hashed_device_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.visibility_rec.hashed_device_mac)
}
inline void visibility_rec::set_hashed_device_mac(const void* value, size_t size) {
  set_has_hashed_device_mac();
  hashed_device_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.visibility_rec.hashed_device_mac)
}
inline ::std::string* visibility_rec::mutable_hashed_device_mac() {
  set_has_hashed_device_mac();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.visibility_rec.hashed_device_mac)
  return hashed_device_mac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* visibility_rec::release_hashed_device_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.visibility_rec.hashed_device_mac)
  if (!has_hashed_device_mac()) {
    return NULL;
  }
  clear_has_hashed_device_mac();
  return hashed_device_mac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void visibility_rec::set_allocated_hashed_device_mac(::std::string* hashed_device_mac) {
  if (hashed_device_mac != NULL) {
    set_has_hashed_device_mac();
  } else {
    clear_has_hashed_device_mac();
  }
  hashed_device_mac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashed_device_mac);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.visibility_rec.hashed_device_mac)
}

// optional string app_name = 12;
inline bool visibility_rec::has_app_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void visibility_rec::set_has_app_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void visibility_rec::clear_has_app_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void visibility_rec::clear_app_name() {
  app_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_app_name();
}
inline const ::std::string& visibility_rec::app_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.app_name)
  return app_name_.GetNoArena();
}
inline void visibility_rec::set_app_name(const ::std::string& value) {
  set_has_app_name();
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.app_name)
}
#if LANG_CXX11
inline void visibility_rec::set_app_name(::std::string&& value) {
  set_has_app_name();
  app_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.visibility_rec.app_name)
}
#endif
inline void visibility_rec::set_app_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_app_name();
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.visibility_rec.app_name)
}
inline void visibility_rec::set_app_name(const char* value, size_t size) {
  set_has_app_name();
  app_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.visibility_rec.app_name)
}
inline ::std::string* visibility_rec::mutable_app_name() {
  set_has_app_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.visibility_rec.app_name)
  return app_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* visibility_rec::release_app_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.visibility_rec.app_name)
  if (!has_app_name()) {
    return NULL;
  }
  clear_has_app_name();
  return app_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void visibility_rec::set_allocated_app_name(::std::string* app_name) {
  if (app_name != NULL) {
    set_has_app_name();
  } else {
    clear_has_app_name();
  }
  app_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), app_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.visibility_rec.app_name)
}

// optional uint32 cc_cat_id = 13;
inline bool visibility_rec::has_cc_cat_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void visibility_rec::set_has_cc_cat_id() {
  _has_bits_[0] |= 0x00004000u;
}
inline void visibility_rec::clear_has_cc_cat_id() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void visibility_rec::clear_cc_cat_id() {
  cc_cat_id_ = 0u;
  clear_has_cc_cat_id();
}
inline ::google::protobuf::uint32 visibility_rec::cc_cat_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.cc_cat_id)
  return cc_cat_id_;
}
inline void visibility_rec::set_cc_cat_id(::google::protobuf::uint32 value) {
  set_has_cc_cat_id();
  cc_cat_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.cc_cat_id)
}

// optional uint32 cc_rep_score = 14;
inline bool visibility_rec::has_cc_rep_score() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void visibility_rec::set_has_cc_rep_score() {
  _has_bits_[0] |= 0x00008000u;
}
inline void visibility_rec::clear_has_cc_rep_score() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void visibility_rec::clear_cc_rep_score() {
  cc_rep_score_ = 0u;
  clear_has_cc_rep_score();
}
inline ::google::protobuf::uint32 visibility_rec::cc_rep_score() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.cc_rep_score)
  return cc_rep_score_;
}
inline void visibility_rec::set_cc_rep_score(::google::protobuf::uint32 value) {
  set_has_cc_rep_score();
  cc_rep_score_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.cc_rep_score)
}

// optional string cc_url_prefix = 15;
inline bool visibility_rec::has_cc_url_prefix() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void visibility_rec::set_has_cc_url_prefix() {
  _has_bits_[0] |= 0x00000008u;
}
inline void visibility_rec::clear_has_cc_url_prefix() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void visibility_rec::clear_cc_url_prefix() {
  cc_url_prefix_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cc_url_prefix();
}
inline const ::std::string& visibility_rec::cc_url_prefix() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.cc_url_prefix)
  return cc_url_prefix_.GetNoArena();
}
inline void visibility_rec::set_cc_url_prefix(const ::std::string& value) {
  set_has_cc_url_prefix();
  cc_url_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.cc_url_prefix)
}
#if LANG_CXX11
inline void visibility_rec::set_cc_url_prefix(::std::string&& value) {
  set_has_cc_url_prefix();
  cc_url_prefix_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.visibility_rec.cc_url_prefix)
}
#endif
inline void visibility_rec::set_cc_url_prefix(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cc_url_prefix();
  cc_url_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.visibility_rec.cc_url_prefix)
}
inline void visibility_rec::set_cc_url_prefix(const char* value, size_t size) {
  set_has_cc_url_prefix();
  cc_url_prefix_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.visibility_rec.cc_url_prefix)
}
inline ::std::string* visibility_rec::mutable_cc_url_prefix() {
  set_has_cc_url_prefix();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.visibility_rec.cc_url_prefix)
  return cc_url_prefix_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* visibility_rec::release_cc_url_prefix() {
  // @@protoc_insertion_point(field_release:ce.nbapi.visibility_rec.cc_url_prefix)
  if (!has_cc_url_prefix()) {
    return NULL;
  }
  clear_has_cc_url_prefix();
  return cc_url_prefix_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void visibility_rec::set_allocated_cc_url_prefix(::std::string* cc_url_prefix) {
  if (cc_url_prefix != NULL) {
    set_has_cc_url_prefix();
  } else {
    clear_has_cc_url_prefix();
  }
  cc_url_prefix_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cc_url_prefix);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.visibility_rec.cc_url_prefix)
}

// optional bytes cc_md5 = 16;
inline bool visibility_rec::has_cc_md5() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void visibility_rec::set_has_cc_md5() {
  _has_bits_[0] |= 0x00000010u;
}
inline void visibility_rec::clear_has_cc_md5() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void visibility_rec::clear_cc_md5() {
  cc_md5_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cc_md5();
}
inline const ::std::string& visibility_rec::cc_md5() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.cc_md5)
  return cc_md5_.GetNoArena();
}
inline void visibility_rec::set_cc_md5(const ::std::string& value) {
  set_has_cc_md5();
  cc_md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.cc_md5)
}
#if LANG_CXX11
inline void visibility_rec::set_cc_md5(::std::string&& value) {
  set_has_cc_md5();
  cc_md5_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.visibility_rec.cc_md5)
}
#endif
inline void visibility_rec::set_cc_md5(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cc_md5();
  cc_md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.visibility_rec.cc_md5)
}
inline void visibility_rec::set_cc_md5(const void* value, size_t size) {
  set_has_cc_md5();
  cc_md5_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.visibility_rec.cc_md5)
}
inline ::std::string* visibility_rec::mutable_cc_md5() {
  set_has_cc_md5();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.visibility_rec.cc_md5)
  return cc_md5_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* visibility_rec::release_cc_md5() {
  // @@protoc_insertion_point(field_release:ce.nbapi.visibility_rec.cc_md5)
  if (!has_cc_md5()) {
    return NULL;
  }
  clear_has_cc_md5();
  return cc_md5_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void visibility_rec::set_allocated_cc_md5(::std::string* cc_md5) {
  if (cc_md5 != NULL) {
    set_has_cc_md5();
  } else {
    clear_has_cc_md5();
  }
  cc_md5_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cc_md5);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.visibility_rec.cc_md5)
}

// optional .ce.nbapi.mac_address ap_mac = 17;
inline bool visibility_rec::has_ap_mac() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void visibility_rec::set_has_ap_mac() {
  _has_bits_[0] |= 0x00000100u;
}
inline void visibility_rec::clear_has_ap_mac() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void visibility_rec::clear_ap_mac() {
  if (ap_mac_ != NULL) ap_mac_->Clear();
  clear_has_ap_mac();
}
inline const ::ce::nbapi::mac_address& visibility_rec::_internal_ap_mac() const {
  return *ap_mac_;
}
inline const ::ce::nbapi::mac_address& visibility_rec::ap_mac() const {
  const ::ce::nbapi::mac_address* p = ap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.ap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* visibility_rec::release_ap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.visibility_rec.ap_mac)
  clear_has_ap_mac();
  ::ce::nbapi::mac_address* temp = ap_mac_;
  ap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* visibility_rec::mutable_ap_mac() {
  set_has_ap_mac();
  if (ap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.visibility_rec.ap_mac)
  return ap_mac_;
}
inline void visibility_rec::set_allocated_ap_mac(::ce::nbapi::mac_address* ap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_mac_;
  }
  if (ap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_mac, submessage_arena);
    }
    set_has_ap_mac();
  } else {
    clear_has_ap_mac();
  }
  ap_mac_ = ap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.visibility_rec.ap_mac)
}

// optional .ce.nbapi.visibility_rec.IapAppEnforcementStatus session_flags = 18;
inline bool visibility_rec::has_session_flags() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void visibility_rec::set_has_session_flags() {
  _has_bits_[0] |= 0x00020000u;
}
inline void visibility_rec::clear_has_session_flags() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void visibility_rec::clear_session_flags() {
  session_flags_ = 1;
  clear_has_session_flags();
}
inline ::ce::nbapi::visibility_rec_IapAppEnforcementStatus visibility_rec::session_flags() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.visibility_rec.session_flags)
  return static_cast< ::ce::nbapi::visibility_rec_IapAppEnforcementStatus >(session_flags_);
}
inline void visibility_rec::set_session_flags(::ce::nbapi::visibility_rec_IapAppEnforcementStatus value) {
  assert(::ce::nbapi::visibility_rec_IapAppEnforcementStatus_IsValid(value));
  set_has_session_flags();
  session_flags_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.visibility_rec.session_flags)
}

// -------------------------------------------------------------------

// campus

// optional bytes campus_id = 1;
inline bool campus::has_campus_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void campus::set_has_campus_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void campus::clear_has_campus_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void campus::clear_campus_id() {
  campus_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_campus_id();
}
inline const ::std::string& campus::campus_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.campus.campus_id)
  return campus_id_.GetNoArena();
}
inline void campus::set_campus_id(const ::std::string& value) {
  set_has_campus_id();
  campus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.campus.campus_id)
}
#if LANG_CXX11
inline void campus::set_campus_id(::std::string&& value) {
  set_has_campus_id();
  campus_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.campus.campus_id)
}
#endif
inline void campus::set_campus_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_campus_id();
  campus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.campus.campus_id)
}
inline void campus::set_campus_id(const void* value, size_t size) {
  set_has_campus_id();
  campus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.campus.campus_id)
}
inline ::std::string* campus::mutable_campus_id() {
  set_has_campus_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.campus.campus_id)
  return campus_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* campus::release_campus_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.campus.campus_id)
  if (!has_campus_id()) {
    return NULL;
  }
  clear_has_campus_id();
  return campus_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void campus::set_allocated_campus_id(::std::string* campus_id) {
  if (campus_id != NULL) {
    set_has_campus_id();
  } else {
    clear_has_campus_id();
  }
  campus_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), campus_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.campus.campus_id)
}

// optional string campus_name = 2;
inline bool campus::has_campus_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void campus::set_has_campus_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void campus::clear_has_campus_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void campus::clear_campus_name() {
  campus_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_campus_name();
}
inline const ::std::string& campus::campus_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.campus.campus_name)
  return campus_name_.GetNoArena();
}
inline void campus::set_campus_name(const ::std::string& value) {
  set_has_campus_name();
  campus_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.campus.campus_name)
}
#if LANG_CXX11
inline void campus::set_campus_name(::std::string&& value) {
  set_has_campus_name();
  campus_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.campus.campus_name)
}
#endif
inline void campus::set_campus_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_campus_name();
  campus_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.campus.campus_name)
}
inline void campus::set_campus_name(const char* value, size_t size) {
  set_has_campus_name();
  campus_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.campus.campus_name)
}
inline ::std::string* campus::mutable_campus_name() {
  set_has_campus_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.campus.campus_name)
  return campus_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* campus::release_campus_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.campus.campus_name)
  if (!has_campus_name()) {
    return NULL;
  }
  clear_has_campus_name();
  return campus_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void campus::set_allocated_campus_name(::std::string* campus_name) {
  if (campus_name != NULL) {
    set_has_campus_name();
  } else {
    clear_has_campus_name();
  }
  campus_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), campus_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.campus.campus_name)
}

// -------------------------------------------------------------------

// building

// optional bytes building_id = 1;
inline bool building::has_building_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void building::set_has_building_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void building::clear_has_building_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void building::clear_building_id() {
  building_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_building_id();
}
inline const ::std::string& building::building_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.building.building_id)
  return building_id_.GetNoArena();
}
inline void building::set_building_id(const ::std::string& value) {
  set_has_building_id();
  building_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.building.building_id)
}
#if LANG_CXX11
inline void building::set_building_id(::std::string&& value) {
  set_has_building_id();
  building_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.building.building_id)
}
#endif
inline void building::set_building_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_building_id();
  building_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.building.building_id)
}
inline void building::set_building_id(const void* value, size_t size) {
  set_has_building_id();
  building_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.building.building_id)
}
inline ::std::string* building::mutable_building_id() {
  set_has_building_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.building.building_id)
  return building_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* building::release_building_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.building.building_id)
  if (!has_building_id()) {
    return NULL;
  }
  clear_has_building_id();
  return building_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void building::set_allocated_building_id(::std::string* building_id) {
  if (building_id != NULL) {
    set_has_building_id();
  } else {
    clear_has_building_id();
  }
  building_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), building_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.building.building_id)
}

// optional string building_name = 2;
inline bool building::has_building_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void building::set_has_building_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void building::clear_has_building_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void building::clear_building_name() {
  building_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_building_name();
}
inline const ::std::string& building::building_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.building.building_name)
  return building_name_.GetNoArena();
}
inline void building::set_building_name(const ::std::string& value) {
  set_has_building_name();
  building_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.building.building_name)
}
#if LANG_CXX11
inline void building::set_building_name(::std::string&& value) {
  set_has_building_name();
  building_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.building.building_name)
}
#endif
inline void building::set_building_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_building_name();
  building_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.building.building_name)
}
inline void building::set_building_name(const char* value, size_t size) {
  set_has_building_name();
  building_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.building.building_name)
}
inline ::std::string* building::mutable_building_name() {
  set_has_building_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.building.building_name)
  return building_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* building::release_building_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.building.building_name)
  if (!has_building_name()) {
    return NULL;
  }
  clear_has_building_name();
  return building_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void building::set_allocated_building_name(::std::string* building_name) {
  if (building_name != NULL) {
    set_has_building_name();
  } else {
    clear_has_building_name();
  }
  building_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), building_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.building.building_name)
}

// optional bytes campus_id = 3;
inline bool building::has_campus_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void building::set_has_campus_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void building::clear_has_campus_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void building::clear_campus_id() {
  campus_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_campus_id();
}
inline const ::std::string& building::campus_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.building.campus_id)
  return campus_id_.GetNoArena();
}
inline void building::set_campus_id(const ::std::string& value) {
  set_has_campus_id();
  campus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.building.campus_id)
}
#if LANG_CXX11
inline void building::set_campus_id(::std::string&& value) {
  set_has_campus_id();
  campus_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.building.campus_id)
}
#endif
inline void building::set_campus_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_campus_id();
  campus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.building.campus_id)
}
inline void building::set_campus_id(const void* value, size_t size) {
  set_has_campus_id();
  campus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.building.campus_id)
}
inline ::std::string* building::mutable_campus_id() {
  set_has_campus_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.building.campus_id)
  return campus_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* building::release_campus_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.building.campus_id)
  if (!has_campus_id()) {
    return NULL;
  }
  clear_has_campus_id();
  return campus_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void building::set_allocated_campus_id(::std::string* campus_id) {
  if (campus_id != NULL) {
    set_has_campus_id();
  } else {
    clear_has_campus_id();
  }
  campus_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), campus_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.building.campus_id)
}

// -------------------------------------------------------------------

// floor

// optional bytes floor_id = 1;
inline bool floor::has_floor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void floor::set_has_floor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void floor::clear_has_floor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void floor::clear_floor_id() {
  floor_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_floor_id();
}
inline const ::std::string& floor::floor_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.floor.floor_id)
  return floor_id_.GetNoArena();
}
inline void floor::set_floor_id(const ::std::string& value) {
  set_has_floor_id();
  floor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.floor.floor_id)
}
#if LANG_CXX11
inline void floor::set_floor_id(::std::string&& value) {
  set_has_floor_id();
  floor_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.floor.floor_id)
}
#endif
inline void floor::set_floor_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_floor_id();
  floor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.floor.floor_id)
}
inline void floor::set_floor_id(const void* value, size_t size) {
  set_has_floor_id();
  floor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.floor.floor_id)
}
inline ::std::string* floor::mutable_floor_id() {
  set_has_floor_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.floor.floor_id)
  return floor_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* floor::release_floor_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.floor.floor_id)
  if (!has_floor_id()) {
    return NULL;
  }
  clear_has_floor_id();
  return floor_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void floor::set_allocated_floor_id(::std::string* floor_id) {
  if (floor_id != NULL) {
    set_has_floor_id();
  } else {
    clear_has_floor_id();
  }
  floor_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), floor_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.floor.floor_id)
}

// optional string floor_name = 2;
inline bool floor::has_floor_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void floor::set_has_floor_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void floor::clear_has_floor_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void floor::clear_floor_name() {
  floor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_floor_name();
}
inline const ::std::string& floor::floor_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.floor.floor_name)
  return floor_name_.GetNoArena();
}
inline void floor::set_floor_name(const ::std::string& value) {
  set_has_floor_name();
  floor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.floor.floor_name)
}
#if LANG_CXX11
inline void floor::set_floor_name(::std::string&& value) {
  set_has_floor_name();
  floor_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.floor.floor_name)
}
#endif
inline void floor::set_floor_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_floor_name();
  floor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.floor.floor_name)
}
inline void floor::set_floor_name(const char* value, size_t size) {
  set_has_floor_name();
  floor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.floor.floor_name)
}
inline ::std::string* floor::mutable_floor_name() {
  set_has_floor_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.floor.floor_name)
  return floor_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* floor::release_floor_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.floor.floor_name)
  if (!has_floor_name()) {
    return NULL;
  }
  clear_has_floor_name();
  return floor_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void floor::set_allocated_floor_name(::std::string* floor_name) {
  if (floor_name != NULL) {
    set_has_floor_name();
  } else {
    clear_has_floor_name();
  }
  floor_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), floor_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.floor.floor_name)
}

// optional float floor_latitude = 3;
inline bool floor::has_floor_latitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void floor::set_has_floor_latitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void floor::clear_has_floor_latitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void floor::clear_floor_latitude() {
  floor_latitude_ = 0;
  clear_has_floor_latitude();
}
inline float floor::floor_latitude() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.floor.floor_latitude)
  return floor_latitude_;
}
inline void floor::set_floor_latitude(float value) {
  set_has_floor_latitude();
  floor_latitude_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.floor.floor_latitude)
}

// optional float floor_longitude = 4;
inline bool floor::has_floor_longitude() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void floor::set_has_floor_longitude() {
  _has_bits_[0] |= 0x00000040u;
}
inline void floor::clear_has_floor_longitude() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void floor::clear_floor_longitude() {
  floor_longitude_ = 0;
  clear_has_floor_longitude();
}
inline float floor::floor_longitude() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.floor.floor_longitude)
  return floor_longitude_;
}
inline void floor::set_floor_longitude(float value) {
  set_has_floor_longitude();
  floor_longitude_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.floor.floor_longitude)
}

// optional string floor_img_path = 5;
inline bool floor::has_floor_img_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void floor::set_has_floor_img_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void floor::clear_has_floor_img_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void floor::clear_floor_img_path() {
  floor_img_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_floor_img_path();
}
inline const ::std::string& floor::floor_img_path() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.floor.floor_img_path)
  return floor_img_path_.GetNoArena();
}
inline void floor::set_floor_img_path(const ::std::string& value) {
  set_has_floor_img_path();
  floor_img_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.floor.floor_img_path)
}
#if LANG_CXX11
inline void floor::set_floor_img_path(::std::string&& value) {
  set_has_floor_img_path();
  floor_img_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.floor.floor_img_path)
}
#endif
inline void floor::set_floor_img_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_floor_img_path();
  floor_img_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.floor.floor_img_path)
}
inline void floor::set_floor_img_path(const char* value, size_t size) {
  set_has_floor_img_path();
  floor_img_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.floor.floor_img_path)
}
inline ::std::string* floor::mutable_floor_img_path() {
  set_has_floor_img_path();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.floor.floor_img_path)
  return floor_img_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* floor::release_floor_img_path() {
  // @@protoc_insertion_point(field_release:ce.nbapi.floor.floor_img_path)
  if (!has_floor_img_path()) {
    return NULL;
  }
  clear_has_floor_img_path();
  return floor_img_path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void floor::set_allocated_floor_img_path(::std::string* floor_img_path) {
  if (floor_img_path != NULL) {
    set_has_floor_img_path();
  } else {
    clear_has_floor_img_path();
  }
  floor_img_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), floor_img_path);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.floor.floor_img_path)
}

// optional float floor_img_width = 6;
inline bool floor::has_floor_img_width() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void floor::set_has_floor_img_width() {
  _has_bits_[0] |= 0x00000080u;
}
inline void floor::clear_has_floor_img_width() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void floor::clear_floor_img_width() {
  floor_img_width_ = 0;
  clear_has_floor_img_width();
}
inline float floor::floor_img_width() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.floor.floor_img_width)
  return floor_img_width_;
}
inline void floor::set_floor_img_width(float value) {
  set_has_floor_img_width();
  floor_img_width_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.floor.floor_img_width)
}

// optional float floor_img_length = 7;
inline bool floor::has_floor_img_length() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void floor::set_has_floor_img_length() {
  _has_bits_[0] |= 0x00000100u;
}
inline void floor::clear_has_floor_img_length() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void floor::clear_floor_img_length() {
  floor_img_length_ = 0;
  clear_has_floor_img_length();
}
inline float floor::floor_img_length() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.floor.floor_img_length)
  return floor_img_length_;
}
inline void floor::set_floor_img_length(float value) {
  set_has_floor_img_length();
  floor_img_length_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.floor.floor_img_length)
}

// optional bytes building_id = 8;
inline bool floor::has_building_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void floor::set_has_building_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void floor::clear_has_building_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void floor::clear_building_id() {
  building_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_building_id();
}
inline const ::std::string& floor::building_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.floor.building_id)
  return building_id_.GetNoArena();
}
inline void floor::set_building_id(const ::std::string& value) {
  set_has_building_id();
  building_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.floor.building_id)
}
#if LANG_CXX11
inline void floor::set_building_id(::std::string&& value) {
  set_has_building_id();
  building_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.floor.building_id)
}
#endif
inline void floor::set_building_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_building_id();
  building_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.floor.building_id)
}
inline void floor::set_building_id(const void* value, size_t size) {
  set_has_building_id();
  building_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.floor.building_id)
}
inline ::std::string* floor::mutable_building_id() {
  set_has_building_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.floor.building_id)
  return building_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* floor::release_building_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.floor.building_id)
  if (!has_building_id()) {
    return NULL;
  }
  clear_has_building_id();
  return building_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void floor::set_allocated_building_id(::std::string* building_id) {
  if (building_id != NULL) {
    set_has_building_id();
  } else {
    clear_has_building_id();
  }
  building_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), building_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.floor.building_id)
}

// optional float floor_level = 9;
inline bool floor::has_floor_level() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void floor::set_has_floor_level() {
  _has_bits_[0] |= 0x00000200u;
}
inline void floor::clear_has_floor_level() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void floor::clear_floor_level() {
  floor_level_ = 0;
  clear_has_floor_level();
}
inline float floor::floor_level() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.floor.floor_level)
  return floor_level_;
}
inline void floor::set_floor_level(float value) {
  set_has_floor_level();
  floor_level_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.floor.floor_level)
}

// optional string units = 10;
inline bool floor::has_units() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void floor::set_has_units() {
  _has_bits_[0] |= 0x00000010u;
}
inline void floor::clear_has_units() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void floor::clear_units() {
  units_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_units();
}
inline const ::std::string& floor::units() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.floor.units)
  return units_.GetNoArena();
}
inline void floor::set_units(const ::std::string& value) {
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.floor.units)
}
#if LANG_CXX11
inline void floor::set_units(::std::string&& value) {
  set_has_units();
  units_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.floor.units)
}
#endif
inline void floor::set_units(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.floor.units)
}
inline void floor::set_units(const char* value, size_t size) {
  set_has_units();
  units_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.floor.units)
}
inline ::std::string* floor::mutable_units() {
  set_has_units();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.floor.units)
  return units_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* floor::release_units() {
  // @@protoc_insertion_point(field_release:ce.nbapi.floor.units)
  if (!has_units()) {
    return NULL;
  }
  clear_has_units();
  return units_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void floor::set_allocated_units(::std::string* units) {
  if (units != NULL) {
    set_has_units();
  } else {
    clear_has_units();
  }
  units_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), units);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.floor.units)
}

// optional float grid_size = 11;
inline bool floor::has_grid_size() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void floor::set_has_grid_size() {
  _has_bits_[0] |= 0x00000400u;
}
inline void floor::clear_has_grid_size() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void floor::clear_grid_size() {
  grid_size_ = 0;
  clear_has_grid_size();
}
inline float floor::grid_size() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.floor.grid_size)
  return grid_size_;
}
inline void floor::set_grid_size(float value) {
  set_has_grid_size();
  grid_size_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.floor.grid_size)
}

// -------------------------------------------------------------------

// point

// optional float x = 1;
inline bool point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float point::x() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.point.x)
  return x_;
}
inline void point::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.point.x)
}

// optional float y = 2;
inline bool point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float point::y() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.point.y)
  return y_;
}
inline void point::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.point.y)
}

// -------------------------------------------------------------------

// geofence

// optional bytes floor_id = 1;
inline bool geofence::has_floor_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void geofence::set_has_floor_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void geofence::clear_has_floor_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void geofence::clear_floor_id() {
  floor_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_floor_id();
}
inline const ::std::string& geofence::floor_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence.floor_id)
  return floor_id_.GetNoArena();
}
inline void geofence::set_floor_id(const ::std::string& value) {
  set_has_floor_id();
  floor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.geofence.floor_id)
}
#if LANG_CXX11
inline void geofence::set_floor_id(::std::string&& value) {
  set_has_floor_id();
  floor_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.geofence.floor_id)
}
#endif
inline void geofence::set_floor_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_floor_id();
  floor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.geofence.floor_id)
}
inline void geofence::set_floor_id(const void* value, size_t size) {
  set_has_floor_id();
  floor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.geofence.floor_id)
}
inline ::std::string* geofence::mutable_floor_id() {
  set_has_floor_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.geofence.floor_id)
  return floor_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* geofence::release_floor_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.geofence.floor_id)
  if (!has_floor_id()) {
    return NULL;
  }
  clear_has_floor_id();
  return floor_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void geofence::set_allocated_floor_id(::std::string* floor_id) {
  if (floor_id != NULL) {
    set_has_floor_id();
  } else {
    clear_has_floor_id();
  }
  floor_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), floor_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.geofence.floor_id)
}

// optional bytes geofence_id = 2;
inline bool geofence::has_geofence_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void geofence::set_has_geofence_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void geofence::clear_has_geofence_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void geofence::clear_geofence_id() {
  geofence_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_geofence_id();
}
inline const ::std::string& geofence::geofence_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence.geofence_id)
  return geofence_id_.GetNoArena();
}
inline void geofence::set_geofence_id(const ::std::string& value) {
  set_has_geofence_id();
  geofence_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.geofence.geofence_id)
}
#if LANG_CXX11
inline void geofence::set_geofence_id(::std::string&& value) {
  set_has_geofence_id();
  geofence_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.geofence.geofence_id)
}
#endif
inline void geofence::set_geofence_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_geofence_id();
  geofence_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.geofence.geofence_id)
}
inline void geofence::set_geofence_id(const void* value, size_t size) {
  set_has_geofence_id();
  geofence_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.geofence.geofence_id)
}
inline ::std::string* geofence::mutable_geofence_id() {
  set_has_geofence_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.geofence.geofence_id)
  return geofence_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* geofence::release_geofence_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.geofence.geofence_id)
  if (!has_geofence_id()) {
    return NULL;
  }
  clear_has_geofence_id();
  return geofence_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void geofence::set_allocated_geofence_id(::std::string* geofence_id) {
  if (geofence_id != NULL) {
    set_has_geofence_id();
  } else {
    clear_has_geofence_id();
  }
  geofence_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), geofence_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.geofence.geofence_id)
}

// optional string geofence_name = 3;
inline bool geofence::has_geofence_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void geofence::set_has_geofence_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void geofence::clear_has_geofence_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void geofence::clear_geofence_name() {
  geofence_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_geofence_name();
}
inline const ::std::string& geofence::geofence_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence.geofence_name)
  return geofence_name_.GetNoArena();
}
inline void geofence::set_geofence_name(const ::std::string& value) {
  set_has_geofence_name();
  geofence_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.geofence.geofence_name)
}
#if LANG_CXX11
inline void geofence::set_geofence_name(::std::string&& value) {
  set_has_geofence_name();
  geofence_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.geofence.geofence_name)
}
#endif
inline void geofence::set_geofence_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_geofence_name();
  geofence_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.geofence.geofence_name)
}
inline void geofence::set_geofence_name(const char* value, size_t size) {
  set_has_geofence_name();
  geofence_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.geofence.geofence_name)
}
inline ::std::string* geofence::mutable_geofence_name() {
  set_has_geofence_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.geofence.geofence_name)
  return geofence_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* geofence::release_geofence_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.geofence.geofence_name)
  if (!has_geofence_name()) {
    return NULL;
  }
  clear_has_geofence_name();
  return geofence_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void geofence::set_allocated_geofence_name(::std::string* geofence_name) {
  if (geofence_name != NULL) {
    set_has_geofence_name();
  } else {
    clear_has_geofence_name();
  }
  geofence_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), geofence_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.geofence.geofence_name)
}

// optional string type = 4;
inline bool geofence::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void geofence::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void geofence::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void geofence::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_type();
}
inline const ::std::string& geofence::type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence.type)
  return type_.GetNoArena();
}
inline void geofence::set_type(const ::std::string& value) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.geofence.type)
}
#if LANG_CXX11
inline void geofence::set_type(::std::string&& value) {
  set_has_type();
  type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.geofence.type)
}
#endif
inline void geofence::set_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.geofence.type)
}
inline void geofence::set_type(const char* value, size_t size) {
  set_has_type();
  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.geofence.type)
}
inline ::std::string* geofence::mutable_type() {
  set_has_type();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.geofence.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* geofence::release_type() {
  // @@protoc_insertion_point(field_release:ce.nbapi.geofence.type)
  if (!has_type()) {
    return NULL;
  }
  clear_has_type();
  return type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void geofence::set_allocated_type(::std::string* type) {
  if (type != NULL) {
    set_has_type();
  } else {
    clear_has_type();
  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.geofence.type)
}

// repeated .ce.nbapi.point point_list = 5;
inline int geofence::point_list_size() const {
  return point_list_.size();
}
inline void geofence::clear_point_list() {
  point_list_.Clear();
}
inline ::ce::nbapi::point* geofence::mutable_point_list(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.geofence.point_list)
  return point_list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::point >*
geofence::mutable_point_list() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.geofence.point_list)
  return &point_list_;
}
inline const ::ce::nbapi::point& geofence::point_list(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence.point_list)
  return point_list_.Get(index);
}
inline ::ce::nbapi::point* geofence::add_point_list() {
  // @@protoc_insertion_point(field_add:ce.nbapi.geofence.point_list)
  return point_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::point >&
geofence::point_list() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.geofence.point_list)
  return point_list_;
}

// -------------------------------------------------------------------

// geofence_notify_Access_point_info

// optional .ce.nbapi.mac_address ap_mac = 8;
inline bool geofence_notify_Access_point_info::has_ap_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void geofence_notify_Access_point_info::set_has_ap_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void geofence_notify_Access_point_info::clear_has_ap_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void geofence_notify_Access_point_info::clear_ap_mac() {
  if (ap_mac_ != NULL) ap_mac_->Clear();
  clear_has_ap_mac();
}
inline const ::ce::nbapi::mac_address& geofence_notify_Access_point_info::_internal_ap_mac() const {
  return *ap_mac_;
}
inline const ::ce::nbapi::mac_address& geofence_notify_Access_point_info::ap_mac() const {
  const ::ce::nbapi::mac_address* p = ap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence_notify.Access_point_info.ap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* geofence_notify_Access_point_info::release_ap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.geofence_notify.Access_point_info.ap_mac)
  clear_has_ap_mac();
  ::ce::nbapi::mac_address* temp = ap_mac_;
  ap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* geofence_notify_Access_point_info::mutable_ap_mac() {
  set_has_ap_mac();
  if (ap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.geofence_notify.Access_point_info.ap_mac)
  return ap_mac_;
}
inline void geofence_notify_Access_point_info::set_allocated_ap_mac(::ce::nbapi::mac_address* ap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_mac_;
  }
  if (ap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_mac, submessage_arena);
    }
    set_has_ap_mac();
  } else {
    clear_has_ap_mac();
  }
  ap_mac_ = ap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.geofence_notify.Access_point_info.ap_mac)
}

// optional string ap_name = 9;
inline bool geofence_notify_Access_point_info::has_ap_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void geofence_notify_Access_point_info::set_has_ap_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void geofence_notify_Access_point_info::clear_has_ap_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void geofence_notify_Access_point_info::clear_ap_name() {
  ap_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ap_name();
}
inline const ::std::string& geofence_notify_Access_point_info::ap_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence_notify.Access_point_info.ap_name)
  return ap_name_.GetNoArena();
}
inline void geofence_notify_Access_point_info::set_ap_name(const ::std::string& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.geofence_notify.Access_point_info.ap_name)
}
#if LANG_CXX11
inline void geofence_notify_Access_point_info::set_ap_name(::std::string&& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.geofence_notify.Access_point_info.ap_name)
}
#endif
inline void geofence_notify_Access_point_info::set_ap_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.geofence_notify.Access_point_info.ap_name)
}
inline void geofence_notify_Access_point_info::set_ap_name(const char* value, size_t size) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.geofence_notify.Access_point_info.ap_name)
}
inline ::std::string* geofence_notify_Access_point_info::mutable_ap_name() {
  set_has_ap_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.geofence_notify.Access_point_info.ap_name)
  return ap_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* geofence_notify_Access_point_info::release_ap_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.geofence_notify.Access_point_info.ap_name)
  if (!has_ap_name()) {
    return NULL;
  }
  clear_has_ap_name();
  return ap_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void geofence_notify_Access_point_info::set_allocated_ap_name(::std::string* ap_name) {
  if (ap_name != NULL) {
    set_has_ap_name();
  } else {
    clear_has_ap_name();
  }
  ap_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ap_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.geofence_notify.Access_point_info.ap_name)
}

// optional .ce.nbapi.mac_address radio_bssid = 10;
inline bool geofence_notify_Access_point_info::has_radio_bssid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void geofence_notify_Access_point_info::set_has_radio_bssid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void geofence_notify_Access_point_info::clear_has_radio_bssid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void geofence_notify_Access_point_info::clear_radio_bssid() {
  if (radio_bssid_ != NULL) radio_bssid_->Clear();
  clear_has_radio_bssid();
}
inline const ::ce::nbapi::mac_address& geofence_notify_Access_point_info::_internal_radio_bssid() const {
  return *radio_bssid_;
}
inline const ::ce::nbapi::mac_address& geofence_notify_Access_point_info::radio_bssid() const {
  const ::ce::nbapi::mac_address* p = radio_bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence_notify.Access_point_info.radio_bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* geofence_notify_Access_point_info::release_radio_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.geofence_notify.Access_point_info.radio_bssid)
  clear_has_radio_bssid();
  ::ce::nbapi::mac_address* temp = radio_bssid_;
  radio_bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* geofence_notify_Access_point_info::mutable_radio_bssid() {
  set_has_radio_bssid();
  if (radio_bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    radio_bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.geofence_notify.Access_point_info.radio_bssid)
  return radio_bssid_;
}
inline void geofence_notify_Access_point_info::set_allocated_radio_bssid(::ce::nbapi::mac_address* radio_bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radio_bssid_;
  }
  if (radio_bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radio_bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radio_bssid, submessage_arena);
    }
    set_has_radio_bssid();
  } else {
    clear_has_radio_bssid();
  }
  radio_bssid_ = radio_bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.geofence_notify.Access_point_info.radio_bssid)
}

// optional uint32 rssi_val = 11;
inline bool geofence_notify_Access_point_info::has_rssi_val() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void geofence_notify_Access_point_info::set_has_rssi_val() {
  _has_bits_[0] |= 0x00000008u;
}
inline void geofence_notify_Access_point_info::clear_has_rssi_val() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void geofence_notify_Access_point_info::clear_rssi_val() {
  rssi_val_ = 0u;
  clear_has_rssi_val();
}
inline ::google::protobuf::uint32 geofence_notify_Access_point_info::rssi_val() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence_notify.Access_point_info.rssi_val)
  return rssi_val_;
}
inline void geofence_notify_Access_point_info::set_rssi_val(::google::protobuf::uint32 value) {
  set_has_rssi_val();
  rssi_val_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.geofence_notify.Access_point_info.rssi_val)
}

// -------------------------------------------------------------------

// geofence_notify

// optional .ce.nbapi.geofence_notify.zone_event geofence_event = 1;
inline bool geofence_notify::has_geofence_event() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void geofence_notify::set_has_geofence_event() {
  _has_bits_[0] |= 0x00000010u;
}
inline void geofence_notify::clear_has_geofence_event() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void geofence_notify::clear_geofence_event() {
  geofence_event_ = 0;
  clear_has_geofence_event();
}
inline ::ce::nbapi::geofence_notify_zone_event geofence_notify::geofence_event() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence_notify.geofence_event)
  return static_cast< ::ce::nbapi::geofence_notify_zone_event >(geofence_event_);
}
inline void geofence_notify::set_geofence_event(::ce::nbapi::geofence_notify_zone_event value) {
  assert(::ce::nbapi::geofence_notify_zone_event_IsValid(value));
  set_has_geofence_event();
  geofence_event_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.geofence_notify.geofence_event)
}

// optional bytes geofence_id = 2;
inline bool geofence_notify::has_geofence_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void geofence_notify::set_has_geofence_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void geofence_notify::clear_has_geofence_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void geofence_notify::clear_geofence_id() {
  geofence_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_geofence_id();
}
inline const ::std::string& geofence_notify::geofence_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence_notify.geofence_id)
  return geofence_id_.GetNoArena();
}
inline void geofence_notify::set_geofence_id(const ::std::string& value) {
  set_has_geofence_id();
  geofence_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.geofence_notify.geofence_id)
}
#if LANG_CXX11
inline void geofence_notify::set_geofence_id(::std::string&& value) {
  set_has_geofence_id();
  geofence_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.geofence_notify.geofence_id)
}
#endif
inline void geofence_notify::set_geofence_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_geofence_id();
  geofence_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.geofence_notify.geofence_id)
}
inline void geofence_notify::set_geofence_id(const void* value, size_t size) {
  set_has_geofence_id();
  geofence_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.geofence_notify.geofence_id)
}
inline ::std::string* geofence_notify::mutable_geofence_id() {
  set_has_geofence_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.geofence_notify.geofence_id)
  return geofence_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* geofence_notify::release_geofence_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.geofence_notify.geofence_id)
  if (!has_geofence_id()) {
    return NULL;
  }
  clear_has_geofence_id();
  return geofence_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void geofence_notify::set_allocated_geofence_id(::std::string* geofence_id) {
  if (geofence_id != NULL) {
    set_has_geofence_id();
  } else {
    clear_has_geofence_id();
  }
  geofence_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), geofence_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.geofence_notify.geofence_id)
}

// optional string geofence_name = 3;
inline bool geofence_notify::has_geofence_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void geofence_notify::set_has_geofence_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void geofence_notify::clear_has_geofence_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void geofence_notify::clear_geofence_name() {
  geofence_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_geofence_name();
}
inline const ::std::string& geofence_notify::geofence_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence_notify.geofence_name)
  return geofence_name_.GetNoArena();
}
inline void geofence_notify::set_geofence_name(const ::std::string& value) {
  set_has_geofence_name();
  geofence_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.geofence_notify.geofence_name)
}
#if LANG_CXX11
inline void geofence_notify::set_geofence_name(::std::string&& value) {
  set_has_geofence_name();
  geofence_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.geofence_notify.geofence_name)
}
#endif
inline void geofence_notify::set_geofence_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_geofence_name();
  geofence_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.geofence_notify.geofence_name)
}
inline void geofence_notify::set_geofence_name(const char* value, size_t size) {
  set_has_geofence_name();
  geofence_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.geofence_notify.geofence_name)
}
inline ::std::string* geofence_notify::mutable_geofence_name() {
  set_has_geofence_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.geofence_notify.geofence_name)
  return geofence_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* geofence_notify::release_geofence_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.geofence_notify.geofence_name)
  if (!has_geofence_name()) {
    return NULL;
  }
  clear_has_geofence_name();
  return geofence_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void geofence_notify::set_allocated_geofence_name(::std::string* geofence_name) {
  if (geofence_name != NULL) {
    set_has_geofence_name();
  } else {
    clear_has_geofence_name();
  }
  geofence_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), geofence_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.geofence_notify.geofence_name)
}

// optional .ce.nbapi.mac_address sta_mac = 4;
inline bool geofence_notify::has_sta_mac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void geofence_notify::set_has_sta_mac() {
  _has_bits_[0] |= 0x00000008u;
}
inline void geofence_notify::clear_has_sta_mac() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void geofence_notify::clear_sta_mac() {
  if (sta_mac_ != NULL) sta_mac_->Clear();
  clear_has_sta_mac();
}
inline const ::ce::nbapi::mac_address& geofence_notify::_internal_sta_mac() const {
  return *sta_mac_;
}
inline const ::ce::nbapi::mac_address& geofence_notify::sta_mac() const {
  const ::ce::nbapi::mac_address* p = sta_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence_notify.sta_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* geofence_notify::release_sta_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.geofence_notify.sta_mac)
  clear_has_sta_mac();
  ::ce::nbapi::mac_address* temp = sta_mac_;
  sta_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* geofence_notify::mutable_sta_mac() {
  set_has_sta_mac();
  if (sta_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    sta_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.geofence_notify.sta_mac)
  return sta_mac_;
}
inline void geofence_notify::set_allocated_sta_mac(::ce::nbapi::mac_address* sta_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sta_mac_;
  }
  if (sta_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sta_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sta_mac, submessage_arena);
    }
    set_has_sta_mac();
  } else {
    clear_has_sta_mac();
  }
  sta_mac_ = sta_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.geofence_notify.sta_mac)
}

// optional bool associated = 5;
inline bool geofence_notify::has_associated() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void geofence_notify::set_has_associated() {
  _has_bits_[0] |= 0x00000020u;
}
inline void geofence_notify::clear_has_associated() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void geofence_notify::clear_associated() {
  associated_ = false;
  clear_has_associated();
}
inline bool geofence_notify::associated() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence_notify.associated)
  return associated_;
}
inline void geofence_notify::set_associated(bool value) {
  set_has_associated();
  associated_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.geofence_notify.associated)
}

// optional uint32 dwell_time = 6 [default = 0];
inline bool geofence_notify::has_dwell_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void geofence_notify::set_has_dwell_time() {
  _has_bits_[0] |= 0x00000040u;
}
inline void geofence_notify::clear_has_dwell_time() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void geofence_notify::clear_dwell_time() {
  dwell_time_ = 0u;
  clear_has_dwell_time();
}
inline ::google::protobuf::uint32 geofence_notify::dwell_time() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence_notify.dwell_time)
  return dwell_time_;
}
inline void geofence_notify::set_dwell_time(::google::protobuf::uint32 value) {
  set_has_dwell_time();
  dwell_time_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.geofence_notify.dwell_time)
}

// repeated group Access_point_info = 7 { ... };
inline int geofence_notify::access_point_info_size() const {
  return access_point_info_.size();
}
inline void geofence_notify::clear_access_point_info() {
  access_point_info_.Clear();
}
inline ::ce::nbapi::geofence_notify_Access_point_info* geofence_notify::mutable_access_point_info(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.geofence_notify.access_point_info)
  return access_point_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::geofence_notify_Access_point_info >*
geofence_notify::mutable_access_point_info() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.geofence_notify.access_point_info)
  return &access_point_info_;
}
inline const ::ce::nbapi::geofence_notify_Access_point_info& geofence_notify::access_point_info(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence_notify.access_point_info)
  return access_point_info_.Get(index);
}
inline ::ce::nbapi::geofence_notify_Access_point_info* geofence_notify::add_access_point_info() {
  // @@protoc_insertion_point(field_add:ce.nbapi.geofence_notify.access_point_info)
  return access_point_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::geofence_notify_Access_point_info >&
geofence_notify::access_point_info() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.geofence_notify.access_point_info)
  return access_point_info_;
}

// optional bytes hashed_sta_mac = 30;
inline bool geofence_notify::has_hashed_sta_mac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void geofence_notify::set_has_hashed_sta_mac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void geofence_notify::clear_has_hashed_sta_mac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void geofence_notify::clear_hashed_sta_mac() {
  hashed_sta_mac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hashed_sta_mac();
}
inline const ::std::string& geofence_notify::hashed_sta_mac() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.geofence_notify.hashed_sta_mac)
  return hashed_sta_mac_.GetNoArena();
}
inline void geofence_notify::set_hashed_sta_mac(const ::std::string& value) {
  set_has_hashed_sta_mac();
  hashed_sta_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.geofence_notify.hashed_sta_mac)
}
#if LANG_CXX11
inline void geofence_notify::set_hashed_sta_mac(::std::string&& value) {
  set_has_hashed_sta_mac();
  hashed_sta_mac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.geofence_notify.hashed_sta_mac)
}
#endif
inline void geofence_notify::set_hashed_sta_mac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hashed_sta_mac();
  hashed_sta_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.geofence_notify.hashed_sta_mac)
}
inline void geofence_notify::set_hashed_sta_mac(const void* value, size_t size) {
  set_has_hashed_sta_mac();
  hashed_sta_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.geofence_notify.hashed_sta_mac)
}
inline ::std::string* geofence_notify::mutable_hashed_sta_mac() {
  set_has_hashed_sta_mac();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.geofence_notify.hashed_sta_mac)
  return hashed_sta_mac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* geofence_notify::release_hashed_sta_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.geofence_notify.hashed_sta_mac)
  if (!has_hashed_sta_mac()) {
    return NULL;
  }
  clear_has_hashed_sta_mac();
  return hashed_sta_mac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void geofence_notify::set_allocated_hashed_sta_mac(::std::string* hashed_sta_mac) {
  if (hashed_sta_mac != NULL) {
    set_has_hashed_sta_mac();
  } else {
    clear_has_hashed_sta_mac();
  }
  hashed_sta_mac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashed_sta_mac);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.geofence_notify.hashed_sta_mac)
}

// -------------------------------------------------------------------

// stats_radio

// optional .ce.nbapi.mac_address ap_eth_mac = 1;
inline bool stats_radio::has_ap_eth_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stats_radio::set_has_ap_eth_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stats_radio::clear_has_ap_eth_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stats_radio::clear_ap_eth_mac() {
  if (ap_eth_mac_ != NULL) ap_eth_mac_->Clear();
  clear_has_ap_eth_mac();
}
inline const ::ce::nbapi::mac_address& stats_radio::_internal_ap_eth_mac() const {
  return *ap_eth_mac_;
}
inline const ::ce::nbapi::mac_address& stats_radio::ap_eth_mac() const {
  const ::ce::nbapi::mac_address* p = ap_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.ap_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_radio::release_ap_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_radio.ap_eth_mac)
  clear_has_ap_eth_mac();
  ::ce::nbapi::mac_address* temp = ap_eth_mac_;
  ap_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_radio::mutable_ap_eth_mac() {
  set_has_ap_eth_mac();
  if (ap_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_radio.ap_eth_mac)
  return ap_eth_mac_;
}
inline void stats_radio::set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_eth_mac_;
  }
  if (ap_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_eth_mac, submessage_arena);
    }
    set_has_ap_eth_mac();
  } else {
    clear_has_ap_eth_mac();
  }
  ap_eth_mac_ = ap_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_radio.ap_eth_mac)
}

// optional uint32 radio_number = 2;
inline bool stats_radio::has_radio_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void stats_radio::set_has_radio_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void stats_radio::clear_has_radio_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void stats_radio::clear_radio_number() {
  radio_number_ = 0u;
  clear_has_radio_number();
}
inline ::google::protobuf::uint32 stats_radio::radio_number() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.radio_number)
  return radio_number_;
}
inline void stats_radio::set_radio_number(::google::protobuf::uint32 value) {
  set_has_radio_number();
  radio_number_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.radio_number)
}

// optional uint32 channel = 3;
inline bool stats_radio::has_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void stats_radio::set_has_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void stats_radio::clear_has_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void stats_radio::clear_channel() {
  channel_ = 0u;
  clear_has_channel();
}
inline ::google::protobuf::uint32 stats_radio::channel() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.channel)
  return channel_;
}
inline void stats_radio::set_channel(::google::protobuf::uint32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.channel)
}

// optional .ce.nbapi.phy_type phy = 4;
inline bool stats_radio::has_phy() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void stats_radio::set_has_phy() {
  _has_bits_[0] |= 0x00000010u;
}
inline void stats_radio::clear_has_phy() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void stats_radio::clear_phy() {
  phy_ = 0;
  clear_has_phy();
}
inline ::ce::nbapi::phy_type stats_radio::phy() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.phy)
  return static_cast< ::ce::nbapi::phy_type >(phy_);
}
inline void stats_radio::set_phy(::ce::nbapi::phy_type value) {
  assert(::ce::nbapi::phy_type_IsValid(value));
  set_has_phy();
  phy_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.phy)
}

// optional .ce.nbapi.stats_radio.radio_mode mode = 5;
inline bool stats_radio::has_mode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void stats_radio::set_has_mode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void stats_radio::clear_has_mode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void stats_radio::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::ce::nbapi::stats_radio_radio_mode stats_radio::mode() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.mode)
  return static_cast< ::ce::nbapi::stats_radio_radio_mode >(mode_);
}
inline void stats_radio::set_mode(::ce::nbapi::stats_radio_radio_mode value) {
  assert(::ce::nbapi::stats_radio_radio_mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.mode)
}

// optional uint32 noise_floor = 7;
inline bool stats_radio::has_noise_floor() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void stats_radio::set_has_noise_floor() {
  _has_bits_[0] |= 0x00000040u;
}
inline void stats_radio::clear_has_noise_floor() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void stats_radio::clear_noise_floor() {
  noise_floor_ = 0u;
  clear_has_noise_floor();
}
inline ::google::protobuf::uint32 stats_radio::noise_floor() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.noise_floor)
  return noise_floor_;
}
inline void stats_radio::set_noise_floor(::google::protobuf::uint32 value) {
  set_has_noise_floor();
  noise_floor_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.noise_floor)
}

// optional uint32 tx_power = 8;
inline bool stats_radio::has_tx_power() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void stats_radio::set_has_tx_power() {
  _has_bits_[0] |= 0x00000080u;
}
inline void stats_radio::clear_has_tx_power() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void stats_radio::clear_tx_power() {
  tx_power_ = 0u;
  clear_has_tx_power();
}
inline ::google::protobuf::uint32 stats_radio::tx_power() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.tx_power)
  return tx_power_;
}
inline void stats_radio::set_tx_power(::google::protobuf::uint32 value) {
  set_has_tx_power();
  tx_power_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.tx_power)
}

// optional uint32 channel_utilization = 9;
inline bool stats_radio::has_channel_utilization() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void stats_radio::set_has_channel_utilization() {
  _has_bits_[0] |= 0x00000100u;
}
inline void stats_radio::clear_has_channel_utilization() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void stats_radio::clear_channel_utilization() {
  channel_utilization_ = 0u;
  clear_has_channel_utilization();
}
inline ::google::protobuf::uint32 stats_radio::channel_utilization() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.channel_utilization)
  return channel_utilization_;
}
inline void stats_radio::set_channel_utilization(::google::protobuf::uint32 value) {
  set_has_channel_utilization();
  channel_utilization_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.channel_utilization)
}

// optional uint32 rx_channel_utilization = 10;
inline bool stats_radio::has_rx_channel_utilization() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void stats_radio::set_has_rx_channel_utilization() {
  _has_bits_[0] |= 0x00000200u;
}
inline void stats_radio::clear_has_rx_channel_utilization() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void stats_radio::clear_rx_channel_utilization() {
  rx_channel_utilization_ = 0u;
  clear_has_rx_channel_utilization();
}
inline ::google::protobuf::uint32 stats_radio::rx_channel_utilization() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.rx_channel_utilization)
  return rx_channel_utilization_;
}
inline void stats_radio::set_rx_channel_utilization(::google::protobuf::uint32 value) {
  set_has_rx_channel_utilization();
  rx_channel_utilization_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.rx_channel_utilization)
}

// optional uint32 tx_channel_utilization = 11;
inline bool stats_radio::has_tx_channel_utilization() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void stats_radio::set_has_tx_channel_utilization() {
  _has_bits_[0] |= 0x00000400u;
}
inline void stats_radio::clear_has_tx_channel_utilization() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void stats_radio::clear_tx_channel_utilization() {
  tx_channel_utilization_ = 0u;
  clear_has_tx_channel_utilization();
}
inline ::google::protobuf::uint32 stats_radio::tx_channel_utilization() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.tx_channel_utilization)
  return tx_channel_utilization_;
}
inline void stats_radio::set_tx_channel_utilization(::google::protobuf::uint32 value) {
  set_has_tx_channel_utilization();
  tx_channel_utilization_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.tx_channel_utilization)
}

// optional uint32 tx_received = 12;
inline bool stats_radio::has_tx_received() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void stats_radio::set_has_tx_received() {
  _has_bits_[0] |= 0x00000800u;
}
inline void stats_radio::clear_has_tx_received() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void stats_radio::clear_tx_received() {
  tx_received_ = 0u;
  clear_has_tx_received();
}
inline ::google::protobuf::uint32 stats_radio::tx_received() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.tx_received)
  return tx_received_;
}
inline void stats_radio::set_tx_received(::google::protobuf::uint32 value) {
  set_has_tx_received();
  tx_received_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.tx_received)
}

// optional uint32 tx_transmitted = 13;
inline bool stats_radio::has_tx_transmitted() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void stats_radio::set_has_tx_transmitted() {
  _has_bits_[0] |= 0x00001000u;
}
inline void stats_radio::clear_has_tx_transmitted() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void stats_radio::clear_tx_transmitted() {
  tx_transmitted_ = 0u;
  clear_has_tx_transmitted();
}
inline ::google::protobuf::uint32 stats_radio::tx_transmitted() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.tx_transmitted)
  return tx_transmitted_;
}
inline void stats_radio::set_tx_transmitted(::google::protobuf::uint32 value) {
  set_has_tx_transmitted();
  tx_transmitted_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.tx_transmitted)
}

// optional uint32 tx_dropped = 14;
inline bool stats_radio::has_tx_dropped() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void stats_radio::set_has_tx_dropped() {
  _has_bits_[0] |= 0x00002000u;
}
inline void stats_radio::clear_has_tx_dropped() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void stats_radio::clear_tx_dropped() {
  tx_dropped_ = 0u;
  clear_has_tx_dropped();
}
inline ::google::protobuf::uint32 stats_radio::tx_dropped() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.tx_dropped)
  return tx_dropped_;
}
inline void stats_radio::set_tx_dropped(::google::protobuf::uint32 value) {
  set_has_tx_dropped();
  tx_dropped_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.tx_dropped)
}

// optional uint32 tx_data_received = 15;
inline bool stats_radio::has_tx_data_received() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void stats_radio::set_has_tx_data_received() {
  _has_bits_[0] |= 0x00004000u;
}
inline void stats_radio::clear_has_tx_data_received() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void stats_radio::clear_tx_data_received() {
  tx_data_received_ = 0u;
  clear_has_tx_data_received();
}
inline ::google::protobuf::uint32 stats_radio::tx_data_received() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.tx_data_received)
  return tx_data_received_;
}
inline void stats_radio::set_tx_data_received(::google::protobuf::uint32 value) {
  set_has_tx_data_received();
  tx_data_received_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.tx_data_received)
}

// optional uint32 tx_data_transmitted = 16;
inline bool stats_radio::has_tx_data_transmitted() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void stats_radio::set_has_tx_data_transmitted() {
  _has_bits_[0] |= 0x00008000u;
}
inline void stats_radio::clear_has_tx_data_transmitted() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void stats_radio::clear_tx_data_transmitted() {
  tx_data_transmitted_ = 0u;
  clear_has_tx_data_transmitted();
}
inline ::google::protobuf::uint32 stats_radio::tx_data_transmitted() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.tx_data_transmitted)
  return tx_data_transmitted_;
}
inline void stats_radio::set_tx_data_transmitted(::google::protobuf::uint32 value) {
  set_has_tx_data_transmitted();
  tx_data_transmitted_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.tx_data_transmitted)
}

// optional uint32 tx_data_retried = 17;
inline bool stats_radio::has_tx_data_retried() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void stats_radio::set_has_tx_data_retried() {
  _has_bits_[0] |= 0x00010000u;
}
inline void stats_radio::clear_has_tx_data_retried() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void stats_radio::clear_tx_data_retried() {
  tx_data_retried_ = 0u;
  clear_has_tx_data_retried();
}
inline ::google::protobuf::uint32 stats_radio::tx_data_retried() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.tx_data_retried)
  return tx_data_retried_;
}
inline void stats_radio::set_tx_data_retried(::google::protobuf::uint32 value) {
  set_has_tx_data_retried();
  tx_data_retried_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.tx_data_retried)
}

// optional uint32 rx_frames = 18;
inline bool stats_radio::has_rx_frames() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void stats_radio::set_has_rx_frames() {
  _has_bits_[0] |= 0x00020000u;
}
inline void stats_radio::clear_has_rx_frames() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void stats_radio::clear_rx_frames() {
  rx_frames_ = 0u;
  clear_has_rx_frames();
}
inline ::google::protobuf::uint32 stats_radio::rx_frames() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.rx_frames)
  return rx_frames_;
}
inline void stats_radio::set_rx_frames(::google::protobuf::uint32 value) {
  set_has_rx_frames();
  rx_frames_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.rx_frames)
}

// optional uint32 rx_retried = 19;
inline bool stats_radio::has_rx_retried() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void stats_radio::set_has_rx_retried() {
  _has_bits_[0] |= 0x00040000u;
}
inline void stats_radio::clear_has_rx_retried() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void stats_radio::clear_rx_retried() {
  rx_retried_ = 0u;
  clear_has_rx_retried();
}
inline ::google::protobuf::uint32 stats_radio::rx_retried() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.rx_retried)
  return rx_retried_;
}
inline void stats_radio::set_rx_retried(::google::protobuf::uint32 value) {
  set_has_rx_retried();
  rx_retried_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.rx_retried)
}

// optional uint32 rx_data_frames = 20;
inline bool stats_radio::has_rx_data_frames() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void stats_radio::set_has_rx_data_frames() {
  _has_bits_[0] |= 0x00080000u;
}
inline void stats_radio::clear_has_rx_data_frames() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void stats_radio::clear_rx_data_frames() {
  rx_data_frames_ = 0u;
  clear_has_rx_data_frames();
}
inline ::google::protobuf::uint32 stats_radio::rx_data_frames() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.rx_data_frames)
  return rx_data_frames_;
}
inline void stats_radio::set_rx_data_frames(::google::protobuf::uint32 value) {
  set_has_rx_data_frames();
  rx_data_frames_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.rx_data_frames)
}

// optional uint32 rx_data_retried = 21;
inline bool stats_radio::has_rx_data_retried() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void stats_radio::set_has_rx_data_retried() {
  _has_bits_[0] |= 0x00100000u;
}
inline void stats_radio::clear_has_rx_data_retried() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void stats_radio::clear_rx_data_retried() {
  rx_data_retried_ = 0u;
  clear_has_rx_data_retried();
}
inline ::google::protobuf::uint32 stats_radio::rx_data_retried() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.rx_data_retried)
  return rx_data_retried_;
}
inline void stats_radio::set_rx_data_retried(::google::protobuf::uint32 value) {
  set_has_rx_data_retried();
  rx_data_retried_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.rx_data_retried)
}

// optional uint32 rx_frame_errors = 22;
inline bool stats_radio::has_rx_frame_errors() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void stats_radio::set_has_rx_frame_errors() {
  _has_bits_[0] |= 0x00200000u;
}
inline void stats_radio::clear_has_rx_frame_errors() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void stats_radio::clear_rx_frame_errors() {
  rx_frame_errors_ = 0u;
  clear_has_rx_frame_errors();
}
inline ::google::protobuf::uint32 stats_radio::rx_frame_errors() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.rx_frame_errors)
  return rx_frame_errors_;
}
inline void stats_radio::set_rx_frame_errors(::google::protobuf::uint32 value) {
  set_has_rx_frame_errors();
  rx_frame_errors_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.rx_frame_errors)
}

// repeated .ce.nbapi.data_traffic_type_stats traffic_stats = 23;
inline int stats_radio::traffic_stats_size() const {
  return traffic_stats_.size();
}
inline void stats_radio::clear_traffic_stats() {
  traffic_stats_.Clear();
}
inline ::ce::nbapi::data_traffic_type_stats* stats_radio::mutable_traffic_stats(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_radio.traffic_stats)
  return traffic_stats_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_traffic_type_stats >*
stats_radio::mutable_traffic_stats() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.stats_radio.traffic_stats)
  return &traffic_stats_;
}
inline const ::ce::nbapi::data_traffic_type_stats& stats_radio::traffic_stats(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.traffic_stats)
  return traffic_stats_.Get(index);
}
inline ::ce::nbapi::data_traffic_type_stats* stats_radio::add_traffic_stats() {
  // @@protoc_insertion_point(field_add:ce.nbapi.stats_radio.traffic_stats)
  return traffic_stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_traffic_type_stats >&
stats_radio::traffic_stats() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.stats_radio.traffic_stats)
  return traffic_stats_;
}

// repeated .ce.nbapi.data_prio_stats prio_stats = 24;
inline int stats_radio::prio_stats_size() const {
  return prio_stats_.size();
}
inline void stats_radio::clear_prio_stats() {
  prio_stats_.Clear();
}
inline ::ce::nbapi::data_prio_stats* stats_radio::mutable_prio_stats(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_radio.prio_stats)
  return prio_stats_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats >*
stats_radio::mutable_prio_stats() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.stats_radio.prio_stats)
  return &prio_stats_;
}
inline const ::ce::nbapi::data_prio_stats& stats_radio::prio_stats(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.prio_stats)
  return prio_stats_.Get(index);
}
inline ::ce::nbapi::data_prio_stats* stats_radio::add_prio_stats() {
  // @@protoc_insertion_point(field_add:ce.nbapi.stats_radio.prio_stats)
  return prio_stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats >&
stats_radio::prio_stats() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.stats_radio.prio_stats)
  return prio_stats_;
}

// repeated .ce.nbapi.data_rate_stats rate_stats = 25;
inline int stats_radio::rate_stats_size() const {
  return rate_stats_.size();
}
inline void stats_radio::clear_rate_stats() {
  rate_stats_.Clear();
}
inline ::ce::nbapi::data_rate_stats* stats_radio::mutable_rate_stats(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_radio.rate_stats)
  return rate_stats_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats >*
stats_radio::mutable_rate_stats() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.stats_radio.rate_stats)
  return &rate_stats_;
}
inline const ::ce::nbapi::data_rate_stats& stats_radio::rate_stats(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.rate_stats)
  return rate_stats_.Get(index);
}
inline ::ce::nbapi::data_rate_stats* stats_radio::add_rate_stats() {
  // @@protoc_insertion_point(field_add:ce.nbapi.stats_radio.rate_stats)
  return rate_stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats >&
stats_radio::rate_stats() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.stats_radio.rate_stats)
  return rate_stats_;
}

// optional uint32 actual_eirp = 26;
inline bool stats_radio::has_actual_eirp() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void stats_radio::set_has_actual_eirp() {
  _has_bits_[0] |= 0x00800000u;
}
inline void stats_radio::clear_has_actual_eirp() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void stats_radio::clear_actual_eirp() {
  actual_eirp_ = 0u;
  clear_has_actual_eirp();
}
inline ::google::protobuf::uint32 stats_radio::actual_eirp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.actual_eirp)
  return actual_eirp_;
}
inline void stats_radio::set_actual_eirp(::google::protobuf::uint32 value) {
  set_has_actual_eirp();
  actual_eirp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.actual_eirp)
}

// optional .ce.nbapi.mac_address radio_mac = 27;
inline bool stats_radio::has_radio_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stats_radio::set_has_radio_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stats_radio::clear_has_radio_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stats_radio::clear_radio_mac() {
  if (radio_mac_ != NULL) radio_mac_->Clear();
  clear_has_radio_mac();
}
inline const ::ce::nbapi::mac_address& stats_radio::_internal_radio_mac() const {
  return *radio_mac_;
}
inline const ::ce::nbapi::mac_address& stats_radio::radio_mac() const {
  const ::ce::nbapi::mac_address* p = radio_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.radio_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_radio::release_radio_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_radio.radio_mac)
  clear_has_radio_mac();
  ::ce::nbapi::mac_address* temp = radio_mac_;
  radio_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_radio::mutable_radio_mac() {
  set_has_radio_mac();
  if (radio_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    radio_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_radio.radio_mac)
  return radio_mac_;
}
inline void stats_radio::set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radio_mac_;
  }
  if (radio_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radio_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radio_mac, submessage_arena);
    }
    set_has_radio_mac();
  } else {
    clear_has_radio_mac();
  }
  radio_mac_ = radio_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_radio.radio_mac)
}

// optional uint64 tx_data_bytes = 28;
inline bool stats_radio::has_tx_data_bytes() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void stats_radio::set_has_tx_data_bytes() {
  _has_bits_[0] |= 0x00400000u;
}
inline void stats_radio::clear_has_tx_data_bytes() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void stats_radio::clear_tx_data_bytes() {
  tx_data_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_data_bytes();
}
inline ::google::protobuf::uint64 stats_radio::tx_data_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.tx_data_bytes)
  return tx_data_bytes_;
}
inline void stats_radio::set_tx_data_bytes(::google::protobuf::uint64 value) {
  set_has_tx_data_bytes();
  tx_data_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.tx_data_bytes)
}

// optional uint64 rx_data_bytes = 29;
inline bool stats_radio::has_rx_data_bytes() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void stats_radio::set_has_rx_data_bytes() {
  _has_bits_[0] |= 0x02000000u;
}
inline void stats_radio::clear_has_rx_data_bytes() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void stats_radio::clear_rx_data_bytes() {
  rx_data_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_data_bytes();
}
inline ::google::protobuf::uint64 stats_radio::rx_data_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.rx_data_bytes)
  return rx_data_bytes_;
}
inline void stats_radio::set_rx_data_bytes(::google::protobuf::uint64 value) {
  set_has_rx_data_bytes();
  rx_data_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.rx_data_bytes)
}

// optional uint32 radio_band = 30;
inline bool stats_radio::has_radio_band() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void stats_radio::set_has_radio_band() {
  _has_bits_[0] |= 0x01000000u;
}
inline void stats_radio::clear_has_radio_band() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void stats_radio::clear_radio_band() {
  radio_band_ = 0u;
  clear_has_radio_band();
}
inline ::google::protobuf::uint32 stats_radio::radio_band() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.radio_band)
  return radio_band_;
}
inline void stats_radio::set_radio_band(::google::protobuf::uint32 value) {
  set_has_radio_band();
  radio_band_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.radio_band)
}

// optional uint32 channel_busy_64 = 31;
inline bool stats_radio::has_channel_busy_64() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void stats_radio::set_has_channel_busy_64() {
  _has_bits_[0] |= 0x04000000u;
}
inline void stats_radio::clear_has_channel_busy_64() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void stats_radio::clear_channel_busy_64() {
  channel_busy_64_ = 0u;
  clear_has_channel_busy_64();
}
inline ::google::protobuf::uint32 stats_radio::channel_busy_64() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.channel_busy_64)
  return channel_busy_64_;
}
inline void stats_radio::set_channel_busy_64(::google::protobuf::uint32 value) {
  set_has_channel_busy_64();
  channel_busy_64_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.channel_busy_64)
}

// optional uint32 sta_number = 32;
inline bool stats_radio::has_sta_number() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void stats_radio::set_has_sta_number() {
  _has_bits_[0] |= 0x08000000u;
}
inline void stats_radio::clear_has_sta_number() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void stats_radio::clear_sta_number() {
  sta_number_ = 0u;
  clear_has_sta_number();
}
inline ::google::protobuf::uint32 stats_radio::sta_number() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_radio.sta_number)
  return sta_number_;
}
inline void stats_radio::set_sta_number(::google::protobuf::uint32 value) {
  set_has_sta_number();
  sta_number_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_radio.sta_number)
}

// -------------------------------------------------------------------

// stats_vap

// optional .ce.nbapi.mac_address ap_eth_mac = 1;
inline bool stats_vap::has_ap_eth_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stats_vap::set_has_ap_eth_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stats_vap::clear_has_ap_eth_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stats_vap::clear_ap_eth_mac() {
  if (ap_eth_mac_ != NULL) ap_eth_mac_->Clear();
  clear_has_ap_eth_mac();
}
inline const ::ce::nbapi::mac_address& stats_vap::_internal_ap_eth_mac() const {
  return *ap_eth_mac_;
}
inline const ::ce::nbapi::mac_address& stats_vap::ap_eth_mac() const {
  const ::ce::nbapi::mac_address* p = ap_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.ap_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_vap::release_ap_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_vap.ap_eth_mac)
  clear_has_ap_eth_mac();
  ::ce::nbapi::mac_address* temp = ap_eth_mac_;
  ap_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_vap::mutable_ap_eth_mac() {
  set_has_ap_eth_mac();
  if (ap_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_vap.ap_eth_mac)
  return ap_eth_mac_;
}
inline void stats_vap::set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_eth_mac_;
  }
  if (ap_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_eth_mac, submessage_arena);
    }
    set_has_ap_eth_mac();
  } else {
    clear_has_ap_eth_mac();
  }
  ap_eth_mac_ = ap_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_vap.ap_eth_mac)
}

// optional .ce.nbapi.mac_address bssid = 2;
inline bool stats_vap::has_bssid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stats_vap::set_has_bssid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stats_vap::clear_has_bssid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stats_vap::clear_bssid() {
  if (bssid_ != NULL) bssid_->Clear();
  clear_has_bssid();
}
inline const ::ce::nbapi::mac_address& stats_vap::_internal_bssid() const {
  return *bssid_;
}
inline const ::ce::nbapi::mac_address& stats_vap::bssid() const {
  const ::ce::nbapi::mac_address* p = bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_vap::release_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_vap.bssid)
  clear_has_bssid();
  ::ce::nbapi::mac_address* temp = bssid_;
  bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_vap::mutable_bssid() {
  set_has_bssid();
  if (bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_vap.bssid)
  return bssid_;
}
inline void stats_vap::set_allocated_bssid(::ce::nbapi::mac_address* bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bssid_;
  }
  if (bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bssid, submessage_arena);
    }
    set_has_bssid();
  } else {
    clear_has_bssid();
  }
  bssid_ = bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_vap.bssid)
}

// optional uint32 tx_received = 5;
inline bool stats_vap::has_tx_received() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void stats_vap::set_has_tx_received() {
  _has_bits_[0] |= 0x00000004u;
}
inline void stats_vap::clear_has_tx_received() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void stats_vap::clear_tx_received() {
  tx_received_ = 0u;
  clear_has_tx_received();
}
inline ::google::protobuf::uint32 stats_vap::tx_received() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.tx_received)
  return tx_received_;
}
inline void stats_vap::set_tx_received(::google::protobuf::uint32 value) {
  set_has_tx_received();
  tx_received_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_vap.tx_received)
}

// optional uint32 tx_transmitted = 6;
inline bool stats_vap::has_tx_transmitted() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void stats_vap::set_has_tx_transmitted() {
  _has_bits_[0] |= 0x00000008u;
}
inline void stats_vap::clear_has_tx_transmitted() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void stats_vap::clear_tx_transmitted() {
  tx_transmitted_ = 0u;
  clear_has_tx_transmitted();
}
inline ::google::protobuf::uint32 stats_vap::tx_transmitted() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.tx_transmitted)
  return tx_transmitted_;
}
inline void stats_vap::set_tx_transmitted(::google::protobuf::uint32 value) {
  set_has_tx_transmitted();
  tx_transmitted_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_vap.tx_transmitted)
}

// optional uint32 tx_dropped = 7;
inline bool stats_vap::has_tx_dropped() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void stats_vap::set_has_tx_dropped() {
  _has_bits_[0] |= 0x00000010u;
}
inline void stats_vap::clear_has_tx_dropped() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void stats_vap::clear_tx_dropped() {
  tx_dropped_ = 0u;
  clear_has_tx_dropped();
}
inline ::google::protobuf::uint32 stats_vap::tx_dropped() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.tx_dropped)
  return tx_dropped_;
}
inline void stats_vap::set_tx_dropped(::google::protobuf::uint32 value) {
  set_has_tx_dropped();
  tx_dropped_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_vap.tx_dropped)
}

// optional uint32 tx_data_received = 8;
inline bool stats_vap::has_tx_data_received() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void stats_vap::set_has_tx_data_received() {
  _has_bits_[0] |= 0x00000020u;
}
inline void stats_vap::clear_has_tx_data_received() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void stats_vap::clear_tx_data_received() {
  tx_data_received_ = 0u;
  clear_has_tx_data_received();
}
inline ::google::protobuf::uint32 stats_vap::tx_data_received() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.tx_data_received)
  return tx_data_received_;
}
inline void stats_vap::set_tx_data_received(::google::protobuf::uint32 value) {
  set_has_tx_data_received();
  tx_data_received_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_vap.tx_data_received)
}

// optional uint32 tx_data_transmitted = 9;
inline bool stats_vap::has_tx_data_transmitted() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void stats_vap::set_has_tx_data_transmitted() {
  _has_bits_[0] |= 0x00000040u;
}
inline void stats_vap::clear_has_tx_data_transmitted() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void stats_vap::clear_tx_data_transmitted() {
  tx_data_transmitted_ = 0u;
  clear_has_tx_data_transmitted();
}
inline ::google::protobuf::uint32 stats_vap::tx_data_transmitted() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.tx_data_transmitted)
  return tx_data_transmitted_;
}
inline void stats_vap::set_tx_data_transmitted(::google::protobuf::uint32 value) {
  set_has_tx_data_transmitted();
  tx_data_transmitted_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_vap.tx_data_transmitted)
}

// optional uint32 tx_data_retried = 10;
inline bool stats_vap::has_tx_data_retried() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void stats_vap::set_has_tx_data_retried() {
  _has_bits_[0] |= 0x00000080u;
}
inline void stats_vap::clear_has_tx_data_retried() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void stats_vap::clear_tx_data_retried() {
  tx_data_retried_ = 0u;
  clear_has_tx_data_retried();
}
inline ::google::protobuf::uint32 stats_vap::tx_data_retried() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.tx_data_retried)
  return tx_data_retried_;
}
inline void stats_vap::set_tx_data_retried(::google::protobuf::uint32 value) {
  set_has_tx_data_retried();
  tx_data_retried_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_vap.tx_data_retried)
}

// optional uint32 rx_frames = 18;
inline bool stats_vap::has_rx_frames() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void stats_vap::set_has_rx_frames() {
  _has_bits_[0] |= 0x00000800u;
}
inline void stats_vap::clear_has_rx_frames() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void stats_vap::clear_rx_frames() {
  rx_frames_ = 0u;
  clear_has_rx_frames();
}
inline ::google::protobuf::uint32 stats_vap::rx_frames() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.rx_frames)
  return rx_frames_;
}
inline void stats_vap::set_rx_frames(::google::protobuf::uint32 value) {
  set_has_rx_frames();
  rx_frames_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_vap.rx_frames)
}

// optional uint32 rx_retried = 19;
inline bool stats_vap::has_rx_retried() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void stats_vap::set_has_rx_retried() {
  _has_bits_[0] |= 0x00001000u;
}
inline void stats_vap::clear_has_rx_retried() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void stats_vap::clear_rx_retried() {
  rx_retried_ = 0u;
  clear_has_rx_retried();
}
inline ::google::protobuf::uint32 stats_vap::rx_retried() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.rx_retried)
  return rx_retried_;
}
inline void stats_vap::set_rx_retried(::google::protobuf::uint32 value) {
  set_has_rx_retried();
  rx_retried_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_vap.rx_retried)
}

// optional uint32 rx_data_frames = 11;
inline bool stats_vap::has_rx_data_frames() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void stats_vap::set_has_rx_data_frames() {
  _has_bits_[0] |= 0x00000100u;
}
inline void stats_vap::clear_has_rx_data_frames() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void stats_vap::clear_rx_data_frames() {
  rx_data_frames_ = 0u;
  clear_has_rx_data_frames();
}
inline ::google::protobuf::uint32 stats_vap::rx_data_frames() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.rx_data_frames)
  return rx_data_frames_;
}
inline void stats_vap::set_rx_data_frames(::google::protobuf::uint32 value) {
  set_has_rx_data_frames();
  rx_data_frames_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_vap.rx_data_frames)
}

// optional uint32 rx_data_retried = 12;
inline bool stats_vap::has_rx_data_retried() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void stats_vap::set_has_rx_data_retried() {
  _has_bits_[0] |= 0x00000200u;
}
inline void stats_vap::clear_has_rx_data_retried() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void stats_vap::clear_rx_data_retried() {
  rx_data_retried_ = 0u;
  clear_has_rx_data_retried();
}
inline ::google::protobuf::uint32 stats_vap::rx_data_retried() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.rx_data_retried)
  return rx_data_retried_;
}
inline void stats_vap::set_rx_data_retried(::google::protobuf::uint32 value) {
  set_has_rx_data_retried();
  rx_data_retried_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_vap.rx_data_retried)
}

// repeated .ce.nbapi.data_traffic_type_stats traffic_stats = 23;
inline int stats_vap::traffic_stats_size() const {
  return traffic_stats_.size();
}
inline void stats_vap::clear_traffic_stats() {
  traffic_stats_.Clear();
}
inline ::ce::nbapi::data_traffic_type_stats* stats_vap::mutable_traffic_stats(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_vap.traffic_stats)
  return traffic_stats_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_traffic_type_stats >*
stats_vap::mutable_traffic_stats() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.stats_vap.traffic_stats)
  return &traffic_stats_;
}
inline const ::ce::nbapi::data_traffic_type_stats& stats_vap::traffic_stats(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.traffic_stats)
  return traffic_stats_.Get(index);
}
inline ::ce::nbapi::data_traffic_type_stats* stats_vap::add_traffic_stats() {
  // @@protoc_insertion_point(field_add:ce.nbapi.stats_vap.traffic_stats)
  return traffic_stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_traffic_type_stats >&
stats_vap::traffic_stats() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.stats_vap.traffic_stats)
  return traffic_stats_;
}

// repeated .ce.nbapi.data_prio_stats prio_stats = 13;
inline int stats_vap::prio_stats_size() const {
  return prio_stats_.size();
}
inline void stats_vap::clear_prio_stats() {
  prio_stats_.Clear();
}
inline ::ce::nbapi::data_prio_stats* stats_vap::mutable_prio_stats(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_vap.prio_stats)
  return prio_stats_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats >*
stats_vap::mutable_prio_stats() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.stats_vap.prio_stats)
  return &prio_stats_;
}
inline const ::ce::nbapi::data_prio_stats& stats_vap::prio_stats(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.prio_stats)
  return prio_stats_.Get(index);
}
inline ::ce::nbapi::data_prio_stats* stats_vap::add_prio_stats() {
  // @@protoc_insertion_point(field_add:ce.nbapi.stats_vap.prio_stats)
  return prio_stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats >&
stats_vap::prio_stats() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.stats_vap.prio_stats)
  return prio_stats_;
}

// repeated .ce.nbapi.data_rate_stats rate_stats = 14;
inline int stats_vap::rate_stats_size() const {
  return rate_stats_.size();
}
inline void stats_vap::clear_rate_stats() {
  rate_stats_.Clear();
}
inline ::ce::nbapi::data_rate_stats* stats_vap::mutable_rate_stats(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_vap.rate_stats)
  return rate_stats_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats >*
stats_vap::mutable_rate_stats() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.stats_vap.rate_stats)
  return &rate_stats_;
}
inline const ::ce::nbapi::data_rate_stats& stats_vap::rate_stats(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.rate_stats)
  return rate_stats_.Get(index);
}
inline ::ce::nbapi::data_rate_stats* stats_vap::add_rate_stats() {
  // @@protoc_insertion_point(field_add:ce.nbapi.stats_vap.rate_stats)
  return rate_stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats >&
stats_vap::rate_stats() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.stats_vap.rate_stats)
  return rate_stats_;
}

// optional uint32 sta_number = 15;
inline bool stats_vap::has_sta_number() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void stats_vap::set_has_sta_number() {
  _has_bits_[0] |= 0x00000400u;
}
inline void stats_vap::clear_has_sta_number() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void stats_vap::clear_sta_number() {
  sta_number_ = 0u;
  clear_has_sta_number();
}
inline ::google::protobuf::uint32 stats_vap::sta_number() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vap.sta_number)
  return sta_number_;
}
inline void stats_vap::set_sta_number(::google::protobuf::uint32 value) {
  set_has_sta_number();
  sta_number_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_vap.sta_number)
}

// -------------------------------------------------------------------

// stats_station

// optional .ce.nbapi.mac_address sta_eth_mac = 1;
inline bool stats_station::has_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stats_station::set_has_sta_eth_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stats_station::clear_has_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stats_station::clear_sta_eth_mac() {
  if (sta_eth_mac_ != NULL) sta_eth_mac_->Clear();
  clear_has_sta_eth_mac();
}
inline const ::ce::nbapi::mac_address& stats_station::_internal_sta_eth_mac() const {
  return *sta_eth_mac_;
}
inline const ::ce::nbapi::mac_address& stats_station::sta_eth_mac() const {
  const ::ce::nbapi::mac_address* p = sta_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.sta_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_station::release_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_station.sta_eth_mac)
  clear_has_sta_eth_mac();
  ::ce::nbapi::mac_address* temp = sta_eth_mac_;
  sta_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_station::mutable_sta_eth_mac() {
  set_has_sta_eth_mac();
  if (sta_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    sta_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_station.sta_eth_mac)
  return sta_eth_mac_;
}
inline void stats_station::set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sta_eth_mac_;
  }
  if (sta_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sta_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sta_eth_mac, submessage_arena);
    }
    set_has_sta_eth_mac();
  } else {
    clear_has_sta_eth_mac();
  }
  sta_eth_mac_ = sta_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_station.sta_eth_mac)
}

// optional .ce.nbapi.mac_address ap_eth_mac = 2;
inline bool stats_station::has_ap_eth_mac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void stats_station::set_has_ap_eth_mac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void stats_station::clear_has_ap_eth_mac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void stats_station::clear_ap_eth_mac() {
  if (ap_eth_mac_ != NULL) ap_eth_mac_->Clear();
  clear_has_ap_eth_mac();
}
inline const ::ce::nbapi::mac_address& stats_station::_internal_ap_eth_mac() const {
  return *ap_eth_mac_;
}
inline const ::ce::nbapi::mac_address& stats_station::ap_eth_mac() const {
  const ::ce::nbapi::mac_address* p = ap_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.ap_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_station::release_ap_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_station.ap_eth_mac)
  clear_has_ap_eth_mac();
  ::ce::nbapi::mac_address* temp = ap_eth_mac_;
  ap_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_station::mutable_ap_eth_mac() {
  set_has_ap_eth_mac();
  if (ap_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_station.ap_eth_mac)
  return ap_eth_mac_;
}
inline void stats_station::set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_eth_mac_;
  }
  if (ap_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_eth_mac, submessage_arena);
    }
    set_has_ap_eth_mac();
  } else {
    clear_has_ap_eth_mac();
  }
  ap_eth_mac_ = ap_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_station.ap_eth_mac)
}

// optional .ce.nbapi.mac_address bssid = 3;
inline bool stats_station::has_bssid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void stats_station::set_has_bssid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void stats_station::clear_has_bssid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void stats_station::clear_bssid() {
  if (bssid_ != NULL) bssid_->Clear();
  clear_has_bssid();
}
inline const ::ce::nbapi::mac_address& stats_station::_internal_bssid() const {
  return *bssid_;
}
inline const ::ce::nbapi::mac_address& stats_station::bssid() const {
  const ::ce::nbapi::mac_address* p = bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_station::release_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_station.bssid)
  clear_has_bssid();
  ::ce::nbapi::mac_address* temp = bssid_;
  bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_station::mutable_bssid() {
  set_has_bssid();
  if (bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_station.bssid)
  return bssid_;
}
inline void stats_station::set_allocated_bssid(::ce::nbapi::mac_address* bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bssid_;
  }
  if (bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bssid, submessage_arena);
    }
    set_has_bssid();
  } else {
    clear_has_bssid();
  }
  bssid_ = bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_station.bssid)
}

// optional uint32 snr = 4;
inline bool stats_station::has_snr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void stats_station::set_has_snr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void stats_station::clear_has_snr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void stats_station::clear_snr() {
  snr_ = 0u;
  clear_has_snr();
}
inline ::google::protobuf::uint32 stats_station::snr() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.snr)
  return snr_;
}
inline void stats_station::set_snr(::google::protobuf::uint32 value) {
  set_has_snr();
  snr_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.snr)
}

// optional uint32 tx_received = 5;
inline bool stats_station::has_tx_received() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void stats_station::set_has_tx_received() {
  _has_bits_[0] |= 0x00000020u;
}
inline void stats_station::clear_has_tx_received() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void stats_station::clear_tx_received() {
  tx_received_ = 0u;
  clear_has_tx_received();
}
inline ::google::protobuf::uint32 stats_station::tx_received() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.tx_received)
  return tx_received_;
}
inline void stats_station::set_tx_received(::google::protobuf::uint32 value) {
  set_has_tx_received();
  tx_received_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.tx_received)
}

// optional uint32 tx_transmitted = 6;
inline bool stats_station::has_tx_transmitted() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void stats_station::set_has_tx_transmitted() {
  _has_bits_[0] |= 0x00000040u;
}
inline void stats_station::clear_has_tx_transmitted() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void stats_station::clear_tx_transmitted() {
  tx_transmitted_ = 0u;
  clear_has_tx_transmitted();
}
inline ::google::protobuf::uint32 stats_station::tx_transmitted() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.tx_transmitted)
  return tx_transmitted_;
}
inline void stats_station::set_tx_transmitted(::google::protobuf::uint32 value) {
  set_has_tx_transmitted();
  tx_transmitted_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.tx_transmitted)
}

// optional uint32 tx_dropped = 7;
inline bool stats_station::has_tx_dropped() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void stats_station::set_has_tx_dropped() {
  _has_bits_[0] |= 0x00000080u;
}
inline void stats_station::clear_has_tx_dropped() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void stats_station::clear_tx_dropped() {
  tx_dropped_ = 0u;
  clear_has_tx_dropped();
}
inline ::google::protobuf::uint32 stats_station::tx_dropped() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.tx_dropped)
  return tx_dropped_;
}
inline void stats_station::set_tx_dropped(::google::protobuf::uint32 value) {
  set_has_tx_dropped();
  tx_dropped_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.tx_dropped)
}

// optional uint32 tx_data_received = 8;
inline bool stats_station::has_tx_data_received() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void stats_station::set_has_tx_data_received() {
  _has_bits_[0] |= 0x00000100u;
}
inline void stats_station::clear_has_tx_data_received() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void stats_station::clear_tx_data_received() {
  tx_data_received_ = 0u;
  clear_has_tx_data_received();
}
inline ::google::protobuf::uint32 stats_station::tx_data_received() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.tx_data_received)
  return tx_data_received_;
}
inline void stats_station::set_tx_data_received(::google::protobuf::uint32 value) {
  set_has_tx_data_received();
  tx_data_received_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.tx_data_received)
}

// optional uint32 tx_data_transmitted = 9;
inline bool stats_station::has_tx_data_transmitted() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void stats_station::set_has_tx_data_transmitted() {
  _has_bits_[0] |= 0x00000200u;
}
inline void stats_station::clear_has_tx_data_transmitted() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void stats_station::clear_tx_data_transmitted() {
  tx_data_transmitted_ = 0u;
  clear_has_tx_data_transmitted();
}
inline ::google::protobuf::uint32 stats_station::tx_data_transmitted() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.tx_data_transmitted)
  return tx_data_transmitted_;
}
inline void stats_station::set_tx_data_transmitted(::google::protobuf::uint32 value) {
  set_has_tx_data_transmitted();
  tx_data_transmitted_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.tx_data_transmitted)
}

// optional uint32 tx_data_retried = 10;
inline bool stats_station::has_tx_data_retried() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void stats_station::set_has_tx_data_retried() {
  _has_bits_[0] |= 0x00000400u;
}
inline void stats_station::clear_has_tx_data_retried() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void stats_station::clear_tx_data_retried() {
  tx_data_retried_ = 0u;
  clear_has_tx_data_retried();
}
inline ::google::protobuf::uint32 stats_station::tx_data_retried() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.tx_data_retried)
  return tx_data_retried_;
}
inline void stats_station::set_tx_data_retried(::google::protobuf::uint32 value) {
  set_has_tx_data_retried();
  tx_data_retried_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.tx_data_retried)
}

// optional uint32 rx_data_received = 11;
inline bool stats_station::has_rx_data_received() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void stats_station::set_has_rx_data_received() {
  _has_bits_[0] |= 0x00000800u;
}
inline void stats_station::clear_has_rx_data_received() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void stats_station::clear_rx_data_received() {
  rx_data_received_ = 0u;
  clear_has_rx_data_received();
}
inline ::google::protobuf::uint32 stats_station::rx_data_received() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.rx_data_received)
  return rx_data_received_;
}
inline void stats_station::set_rx_data_received(::google::protobuf::uint32 value) {
  set_has_rx_data_received();
  rx_data_received_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.rx_data_received)
}

// optional uint32 rx_data_retried = 12;
inline bool stats_station::has_rx_data_retried() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void stats_station::set_has_rx_data_retried() {
  _has_bits_[0] |= 0x00001000u;
}
inline void stats_station::clear_has_rx_data_retried() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void stats_station::clear_rx_data_retried() {
  rx_data_retried_ = 0u;
  clear_has_rx_data_retried();
}
inline ::google::protobuf::uint32 stats_station::rx_data_retried() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.rx_data_retried)
  return rx_data_retried_;
}
inline void stats_station::set_rx_data_retried(::google::protobuf::uint32 value) {
  set_has_rx_data_retried();
  rx_data_retried_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.rx_data_retried)
}

// repeated .ce.nbapi.data_prio_stats prio_stats = 13;
inline int stats_station::prio_stats_size() const {
  return prio_stats_.size();
}
inline void stats_station::clear_prio_stats() {
  prio_stats_.Clear();
}
inline ::ce::nbapi::data_prio_stats* stats_station::mutable_prio_stats(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_station.prio_stats)
  return prio_stats_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats >*
stats_station::mutable_prio_stats() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.stats_station.prio_stats)
  return &prio_stats_;
}
inline const ::ce::nbapi::data_prio_stats& stats_station::prio_stats(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.prio_stats)
  return prio_stats_.Get(index);
}
inline ::ce::nbapi::data_prio_stats* stats_station::add_prio_stats() {
  // @@protoc_insertion_point(field_add:ce.nbapi.stats_station.prio_stats)
  return prio_stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_prio_stats >&
stats_station::prio_stats() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.stats_station.prio_stats)
  return prio_stats_;
}

// repeated .ce.nbapi.data_rate_stats rate_stats = 14;
inline int stats_station::rate_stats_size() const {
  return rate_stats_.size();
}
inline void stats_station::clear_rate_stats() {
  rate_stats_.Clear();
}
inline ::ce::nbapi::data_rate_stats* stats_station::mutable_rate_stats(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_station.rate_stats)
  return rate_stats_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats >*
stats_station::mutable_rate_stats() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.stats_station.rate_stats)
  return &rate_stats_;
}
inline const ::ce::nbapi::data_rate_stats& stats_station::rate_stats(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.rate_stats)
  return rate_stats_.Get(index);
}
inline ::ce::nbapi::data_rate_stats* stats_station::add_rate_stats() {
  // @@protoc_insertion_point(field_add:ce.nbapi.stats_station.rate_stats)
  return rate_stats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::data_rate_stats >&
stats_station::rate_stats() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.stats_station.rate_stats)
  return rate_stats_;
}

// optional uint32 speed = 15;
inline bool stats_station::has_speed() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void stats_station::set_has_speed() {
  _has_bits_[0] |= 0x00002000u;
}
inline void stats_station::clear_has_speed() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void stats_station::clear_speed() {
  speed_ = 0u;
  clear_has_speed();
}
inline ::google::protobuf::uint32 stats_station::speed() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.speed)
  return speed_;
}
inline void stats_station::set_speed(::google::protobuf::uint32 value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.speed)
}

// optional uint64 rx_rate = 16;
inline bool stats_station::has_rx_rate() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void stats_station::set_has_rx_rate() {
  _has_bits_[0] |= 0x00004000u;
}
inline void stats_station::clear_has_rx_rate() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void stats_station::clear_rx_rate() {
  rx_rate_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_rate();
}
inline ::google::protobuf::uint64 stats_station::rx_rate() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.rx_rate)
  return rx_rate_;
}
inline void stats_station::set_rx_rate(::google::protobuf::uint64 value) {
  set_has_rx_rate();
  rx_rate_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.rx_rate)
}

// optional uint64 tx_rate = 17;
inline bool stats_station::has_tx_rate() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void stats_station::set_has_tx_rate() {
  _has_bits_[0] |= 0x00008000u;
}
inline void stats_station::clear_has_tx_rate() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void stats_station::clear_tx_rate() {
  tx_rate_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_rate();
}
inline ::google::protobuf::uint64 stats_station::tx_rate() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.tx_rate)
  return tx_rate_;
}
inline void stats_station::set_tx_rate(::google::protobuf::uint64 value) {
  set_has_tx_rate();
  tx_rate_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.tx_rate)
}

// optional uint64 rx_data_bytes = 18;
inline bool stats_station::has_rx_data_bytes() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void stats_station::set_has_rx_data_bytes() {
  _has_bits_[0] |= 0x00010000u;
}
inline void stats_station::clear_has_rx_data_bytes() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void stats_station::clear_rx_data_bytes() {
  rx_data_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_data_bytes();
}
inline ::google::protobuf::uint64 stats_station::rx_data_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.rx_data_bytes)
  return rx_data_bytes_;
}
inline void stats_station::set_rx_data_bytes(::google::protobuf::uint64 value) {
  set_has_rx_data_bytes();
  rx_data_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.rx_data_bytes)
}

// optional uint64 tx_data_bytes = 19;
inline bool stats_station::has_tx_data_bytes() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void stats_station::set_has_tx_data_bytes() {
  _has_bits_[0] |= 0x00020000u;
}
inline void stats_station::clear_has_tx_data_bytes() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void stats_station::clear_tx_data_bytes() {
  tx_data_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_data_bytes();
}
inline ::google::protobuf::uint64 stats_station::tx_data_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.tx_data_bytes)
  return tx_data_bytes_;
}
inline void stats_station::set_tx_data_bytes(::google::protobuf::uint64 value) {
  set_has_tx_data_bytes();
  tx_data_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.tx_data_bytes)
}

// optional uint32 ssid_up = 20;
inline bool stats_station::has_ssid_up() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void stats_station::set_has_ssid_up() {
  _has_bits_[0] |= 0x00040000u;
}
inline void stats_station::clear_has_ssid_up() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void stats_station::clear_ssid_up() {
  ssid_up_ = 0u;
  clear_has_ssid_up();
}
inline ::google::protobuf::uint32 stats_station::ssid_up() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.ssid_up)
  return ssid_up_;
}
inline void stats_station::set_ssid_up(::google::protobuf::uint32 value) {
  set_has_ssid_up();
  ssid_up_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.ssid_up)
}

// optional bytes hashed_sta_eth_mac = 22;
inline bool stats_station::has_hashed_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stats_station::set_has_hashed_sta_eth_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stats_station::clear_has_hashed_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stats_station::clear_hashed_sta_eth_mac() {
  hashed_sta_eth_mac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hashed_sta_eth_mac();
}
inline const ::std::string& stats_station::hashed_sta_eth_mac() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.GetNoArena();
}
inline void stats_station::set_hashed_sta_eth_mac(const ::std::string& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.hashed_sta_eth_mac)
}
#if LANG_CXX11
inline void stats_station::set_hashed_sta_eth_mac(::std::string&& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.stats_station.hashed_sta_eth_mac)
}
#endif
inline void stats_station::set_hashed_sta_eth_mac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.stats_station.hashed_sta_eth_mac)
}
inline void stats_station::set_hashed_sta_eth_mac(const void* value, size_t size) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.stats_station.hashed_sta_eth_mac)
}
inline ::std::string* stats_station::mutable_hashed_sta_eth_mac() {
  set_has_hashed_sta_eth_mac();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_station.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* stats_station::release_hashed_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_station.hashed_sta_eth_mac)
  if (!has_hashed_sta_eth_mac()) {
    return NULL;
  }
  clear_has_hashed_sta_eth_mac();
  return hashed_sta_eth_mac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void stats_station::set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac) {
  if (hashed_sta_eth_mac != NULL) {
    set_has_hashed_sta_eth_mac();
  } else {
    clear_has_hashed_sta_eth_mac();
  }
  hashed_sta_eth_mac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashed_sta_eth_mac);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_station.hashed_sta_eth_mac)
}

// optional uint64 max_tx_rate = 23;
inline bool stats_station::has_max_tx_rate() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void stats_station::set_has_max_tx_rate() {
  _has_bits_[0] |= 0x00100000u;
}
inline void stats_station::clear_has_max_tx_rate() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void stats_station::clear_max_tx_rate() {
  max_tx_rate_ = GOOGLE_ULONGLONG(0);
  clear_has_max_tx_rate();
}
inline ::google::protobuf::uint64 stats_station::max_tx_rate() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.max_tx_rate)
  return max_tx_rate_;
}
inline void stats_station::set_max_tx_rate(::google::protobuf::uint64 value) {
  set_has_max_tx_rate();
  max_tx_rate_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.max_tx_rate)
}

// optional uint64 tx_data_bytes_transmitted = 24;
inline bool stats_station::has_tx_data_bytes_transmitted() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void stats_station::set_has_tx_data_bytes_transmitted() {
  _has_bits_[0] |= 0x00200000u;
}
inline void stats_station::clear_has_tx_data_bytes_transmitted() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void stats_station::clear_tx_data_bytes_transmitted() {
  tx_data_bytes_transmitted_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_data_bytes_transmitted();
}
inline ::google::protobuf::uint64 stats_station::tx_data_bytes_transmitted() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.tx_data_bytes_transmitted)
  return tx_data_bytes_transmitted_;
}
inline void stats_station::set_tx_data_bytes_transmitted(::google::protobuf::uint64 value) {
  set_has_tx_data_bytes_transmitted();
  tx_data_bytes_transmitted_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.tx_data_bytes_transmitted)
}

// optional uint32 tx_time_data = 25;
inline bool stats_station::has_tx_time_data() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void stats_station::set_has_tx_time_data() {
  _has_bits_[0] |= 0x00080000u;
}
inline void stats_station::clear_has_tx_time_data() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void stats_station::clear_tx_time_data() {
  tx_time_data_ = 0u;
  clear_has_tx_time_data();
}
inline ::google::protobuf::uint32 stats_station::tx_time_data() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.tx_time_data)
  return tx_time_data_;
}
inline void stats_station::set_tx_time_data(::google::protobuf::uint32 value) {
  set_has_tx_time_data();
  tx_time_data_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.tx_time_data)
}

// optional uint32 rx_time_data = 26;
inline bool stats_station::has_rx_time_data() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void stats_station::set_has_rx_time_data() {
  _has_bits_[0] |= 0x00400000u;
}
inline void stats_station::clear_has_rx_time_data() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void stats_station::clear_rx_time_data() {
  rx_time_data_ = 0u;
  clear_has_rx_time_data();
}
inline ::google::protobuf::uint32 stats_station::rx_time_data() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.rx_time_data)
  return rx_time_data_;
}
inline void stats_station::set_rx_time_data(::google::protobuf::uint32 value) {
  set_has_rx_time_data();
  rx_time_data_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.rx_time_data)
}

// optional uint32 sta_client_health = 27;
inline bool stats_station::has_sta_client_health() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void stats_station::set_has_sta_client_health() {
  _has_bits_[0] |= 0x00800000u;
}
inline void stats_station::clear_has_sta_client_health() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void stats_station::clear_sta_client_health() {
  sta_client_health_ = 0u;
  clear_has_sta_client_health();
}
inline ::google::protobuf::uint32 stats_station::sta_client_health() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.sta_client_health)
  return sta_client_health_;
}
inline void stats_station::set_sta_client_health(::google::protobuf::uint32 value) {
  set_has_sta_client_health();
  sta_client_health_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.sta_client_health)
}

// optional uint32 rx_retries = 28;
inline bool stats_station::has_rx_retries() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void stats_station::set_has_rx_retries() {
  _has_bits_[0] |= 0x01000000u;
}
inline void stats_station::clear_has_rx_retries() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void stats_station::clear_rx_retries() {
  rx_retries_ = 0u;
  clear_has_rx_retries();
}
inline ::google::protobuf::uint32 stats_station::rx_retries() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.rx_retries)
  return rx_retries_;
}
inline void stats_station::set_rx_retries(::google::protobuf::uint32 value) {
  set_has_rx_retries();
  rx_retries_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.rx_retries)
}

// optional uint32 tx_retries = 29;
inline bool stats_station::has_tx_retries() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void stats_station::set_has_tx_retries() {
  _has_bits_[0] |= 0x02000000u;
}
inline void stats_station::clear_has_tx_retries() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void stats_station::clear_tx_retries() {
  tx_retries_ = 0u;
  clear_has_tx_retries();
}
inline ::google::protobuf::uint32 stats_station::tx_retries() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_station.tx_retries)
  return tx_retries_;
}
inline void stats_station::set_tx_retries(::google::protobuf::uint32 value) {
  set_has_tx_retries();
  tx_retries_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_station.tx_retries)
}

// -------------------------------------------------------------------

// state_station

// optional .ce.nbapi.mac_address sta_eth_mac = 1;
inline bool state_station::has_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void state_station::set_has_sta_eth_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void state_station::clear_has_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void state_station::clear_sta_eth_mac() {
  if (sta_eth_mac_ != NULL) sta_eth_mac_->Clear();
  clear_has_sta_eth_mac();
}
inline const ::ce::nbapi::mac_address& state_station::_internal_sta_eth_mac() const {
  return *sta_eth_mac_;
}
inline const ::ce::nbapi::mac_address& state_station::sta_eth_mac() const {
  const ::ce::nbapi::mac_address* p = sta_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.state_station.sta_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* state_station::release_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.state_station.sta_eth_mac)
  clear_has_sta_eth_mac();
  ::ce::nbapi::mac_address* temp = sta_eth_mac_;
  sta_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* state_station::mutable_sta_eth_mac() {
  set_has_sta_eth_mac();
  if (sta_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    sta_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.state_station.sta_eth_mac)
  return sta_eth_mac_;
}
inline void state_station::set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sta_eth_mac_;
  }
  if (sta_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sta_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sta_eth_mac, submessage_arena);
    }
    set_has_sta_eth_mac();
  } else {
    clear_has_sta_eth_mac();
  }
  sta_eth_mac_ = sta_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.state_station.sta_eth_mac)
}

// optional .ce.nbapi.mac_address ap_eth_mac = 2;
inline bool state_station::has_ap_eth_mac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void state_station::set_has_ap_eth_mac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void state_station::clear_has_ap_eth_mac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void state_station::clear_ap_eth_mac() {
  if (ap_eth_mac_ != NULL) ap_eth_mac_->Clear();
  clear_has_ap_eth_mac();
}
inline const ::ce::nbapi::mac_address& state_station::_internal_ap_eth_mac() const {
  return *ap_eth_mac_;
}
inline const ::ce::nbapi::mac_address& state_station::ap_eth_mac() const {
  const ::ce::nbapi::mac_address* p = ap_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.state_station.ap_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* state_station::release_ap_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.state_station.ap_eth_mac)
  clear_has_ap_eth_mac();
  ::ce::nbapi::mac_address* temp = ap_eth_mac_;
  ap_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* state_station::mutable_ap_eth_mac() {
  set_has_ap_eth_mac();
  if (ap_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.state_station.ap_eth_mac)
  return ap_eth_mac_;
}
inline void state_station::set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_eth_mac_;
  }
  if (ap_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_eth_mac, submessage_arena);
    }
    set_has_ap_eth_mac();
  } else {
    clear_has_ap_eth_mac();
  }
  ap_eth_mac_ = ap_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.state_station.ap_eth_mac)
}

// optional uint32 snr = 3;
inline bool state_station::has_snr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void state_station::set_has_snr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void state_station::clear_has_snr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void state_station::clear_snr() {
  snr_ = 0u;
  clear_has_snr();
}
inline ::google::protobuf::uint32 state_station::snr() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_station.snr)
  return snr_;
}
inline void state_station::set_snr(::google::protobuf::uint32 value) {
  set_has_snr();
  snr_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_station.snr)
}

// optional uint32 rx_tries = 4;
inline bool state_station::has_rx_tries() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void state_station::set_has_rx_tries() {
  _has_bits_[0] |= 0x00000010u;
}
inline void state_station::clear_has_rx_tries() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void state_station::clear_rx_tries() {
  rx_tries_ = 0u;
  clear_has_rx_tries();
}
inline ::google::protobuf::uint32 state_station::rx_tries() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_station.rx_tries)
  return rx_tries_;
}
inline void state_station::set_rx_tries(::google::protobuf::uint32 value) {
  set_has_rx_tries();
  rx_tries_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_station.rx_tries)
}

// optional uint32 tx_tries = 5;
inline bool state_station::has_tx_tries() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void state_station::set_has_tx_tries() {
  _has_bits_[0] |= 0x00000020u;
}
inline void state_station::clear_has_tx_tries() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void state_station::clear_tx_tries() {
  tx_tries_ = 0u;
  clear_has_tx_tries();
}
inline ::google::protobuf::uint32 state_station::tx_tries() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_station.tx_tries)
  return tx_tries_;
}
inline void state_station::set_tx_tries(::google::protobuf::uint32 value) {
  set_has_tx_tries();
  tx_tries_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_station.tx_tries)
}

// optional .ce.nbapi.phy_type phy_type = 6;
inline bool state_station::has_phy_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void state_station::set_has_phy_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void state_station::clear_has_phy_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void state_station::clear_phy_type() {
  phy_type_ = 0;
  clear_has_phy_type();
}
inline ::ce::nbapi::phy_type state_station::phy_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_station.phy_type)
  return static_cast< ::ce::nbapi::phy_type >(phy_type_);
}
inline void state_station::set_phy_type(::ce::nbapi::phy_type value) {
  assert(::ce::nbapi::phy_type_IsValid(value));
  set_has_phy_type();
  phy_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_station.phy_type)
}

// optional uint32 security_type = 7;
inline bool state_station::has_security_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void state_station::set_has_security_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void state_station::clear_has_security_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void state_station::clear_security_type() {
  security_type_ = 0u;
  clear_has_security_type();
}
inline ::google::protobuf::uint32 state_station::security_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_station.security_type)
  return security_type_;
}
inline void state_station::set_security_type(::google::protobuf::uint32 value) {
  set_has_security_type();
  security_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.state_station.security_type)
}

// optional bytes hashed_sta_eth_mac = 8;
inline bool state_station::has_hashed_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void state_station::set_has_hashed_sta_eth_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void state_station::clear_has_hashed_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void state_station::clear_hashed_sta_eth_mac() {
  hashed_sta_eth_mac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hashed_sta_eth_mac();
}
inline const ::std::string& state_station::hashed_sta_eth_mac() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.state_station.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.GetNoArena();
}
inline void state_station::set_hashed_sta_eth_mac(const ::std::string& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.state_station.hashed_sta_eth_mac)
}
#if LANG_CXX11
inline void state_station::set_hashed_sta_eth_mac(::std::string&& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.state_station.hashed_sta_eth_mac)
}
#endif
inline void state_station::set_hashed_sta_eth_mac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.state_station.hashed_sta_eth_mac)
}
inline void state_station::set_hashed_sta_eth_mac(const void* value, size_t size) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.state_station.hashed_sta_eth_mac)
}
inline ::std::string* state_station::mutable_hashed_sta_eth_mac() {
  set_has_hashed_sta_eth_mac();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.state_station.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* state_station::release_hashed_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.state_station.hashed_sta_eth_mac)
  if (!has_hashed_sta_eth_mac()) {
    return NULL;
  }
  clear_has_hashed_sta_eth_mac();
  return hashed_sta_eth_mac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void state_station::set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac) {
  if (hashed_sta_eth_mac != NULL) {
    set_has_hashed_sta_eth_mac();
  } else {
    clear_has_hashed_sta_eth_mac();
  }
  hashed_sta_eth_mac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashed_sta_eth_mac);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.state_station.hashed_sta_eth_mac)
}

// -------------------------------------------------------------------

// uplink_bandwidth

// optional .ce.nbapi.ip_address server_ip = 1;
inline bool uplink_bandwidth::has_server_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void uplink_bandwidth::set_has_server_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void uplink_bandwidth::clear_has_server_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void uplink_bandwidth::clear_server_ip() {
  if (server_ip_ != NULL) server_ip_->Clear();
  clear_has_server_ip();
}
inline const ::ce::nbapi::ip_address& uplink_bandwidth::_internal_server_ip() const {
  return *server_ip_;
}
inline const ::ce::nbapi::ip_address& uplink_bandwidth::server_ip() const {
  const ::ce::nbapi::ip_address* p = server_ip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.server_ip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* uplink_bandwidth::release_server_ip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_bandwidth.server_ip)
  clear_has_server_ip();
  ::ce::nbapi::ip_address* temp = server_ip_;
  server_ip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* uplink_bandwidth::mutable_server_ip() {
  set_has_server_ip();
  if (server_ip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    server_ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_bandwidth.server_ip)
  return server_ip_;
}
inline void uplink_bandwidth::set_allocated_server_ip(::ce::nbapi::ip_address* server_ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete server_ip_;
  }
  if (server_ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      server_ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, server_ip, submessage_arena);
    }
    set_has_server_ip();
  } else {
    clear_has_server_ip();
  }
  server_ip_ = server_ip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_bandwidth.server_ip)
}

// optional uint32 server_port = 2;
inline bool uplink_bandwidth::has_server_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void uplink_bandwidth::set_has_server_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void uplink_bandwidth::clear_has_server_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void uplink_bandwidth::clear_server_port() {
  server_port_ = 0u;
  clear_has_server_port();
}
inline ::google::protobuf::uint32 uplink_bandwidth::server_port() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.server_port)
  return server_port_;
}
inline void uplink_bandwidth::set_server_port(::google::protobuf::uint32 value) {
  set_has_server_port();
  server_port_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.server_port)
}

// optional .ce.nbapi.ip_address local_ip = 3;
inline bool uplink_bandwidth::has_local_ip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void uplink_bandwidth::set_has_local_ip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void uplink_bandwidth::clear_has_local_ip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void uplink_bandwidth::clear_local_ip() {
  if (local_ip_ != NULL) local_ip_->Clear();
  clear_has_local_ip();
}
inline const ::ce::nbapi::ip_address& uplink_bandwidth::_internal_local_ip() const {
  return *local_ip_;
}
inline const ::ce::nbapi::ip_address& uplink_bandwidth::local_ip() const {
  const ::ce::nbapi::ip_address* p = local_ip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.local_ip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* uplink_bandwidth::release_local_ip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_bandwidth.local_ip)
  clear_has_local_ip();
  ::ce::nbapi::ip_address* temp = local_ip_;
  local_ip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* uplink_bandwidth::mutable_local_ip() {
  set_has_local_ip();
  if (local_ip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    local_ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_bandwidth.local_ip)
  return local_ip_;
}
inline void uplink_bandwidth::set_allocated_local_ip(::ce::nbapi::ip_address* local_ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete local_ip_;
  }
  if (local_ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      local_ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, local_ip, submessage_arena);
    }
    set_has_local_ip();
  } else {
    clear_has_local_ip();
  }
  local_ip_ = local_ip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_bandwidth.local_ip)
}

// optional uint32 local_port = 4;
inline bool uplink_bandwidth::has_local_port() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void uplink_bandwidth::set_has_local_port() {
  _has_bits_[0] |= 0x00000200u;
}
inline void uplink_bandwidth::clear_has_local_port() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void uplink_bandwidth::clear_local_port() {
  local_port_ = 0u;
  clear_has_local_port();
}
inline ::google::protobuf::uint32 uplink_bandwidth::local_port() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.local_port)
  return local_port_;
}
inline void uplink_bandwidth::set_local_port(::google::protobuf::uint32 value) {
  set_has_local_port();
  local_port_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.local_port)
}

// optional .ce.nbapi.mac_address ap_mac = 5;
inline bool uplink_bandwidth::has_ap_mac() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void uplink_bandwidth::set_has_ap_mac() {
  _has_bits_[0] |= 0x00000080u;
}
inline void uplink_bandwidth::clear_has_ap_mac() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void uplink_bandwidth::clear_ap_mac() {
  if (ap_mac_ != NULL) ap_mac_->Clear();
  clear_has_ap_mac();
}
inline const ::ce::nbapi::mac_address& uplink_bandwidth::_internal_ap_mac() const {
  return *ap_mac_;
}
inline const ::ce::nbapi::mac_address& uplink_bandwidth::ap_mac() const {
  const ::ce::nbapi::mac_address* p = ap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.ap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* uplink_bandwidth::release_ap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_bandwidth.ap_mac)
  clear_has_ap_mac();
  ::ce::nbapi::mac_address* temp = ap_mac_;
  ap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* uplink_bandwidth::mutable_ap_mac() {
  set_has_ap_mac();
  if (ap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_bandwidth.ap_mac)
  return ap_mac_;
}
inline void uplink_bandwidth::set_allocated_ap_mac(::ce::nbapi::mac_address* ap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_mac_;
  }
  if (ap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_mac, submessage_arena);
    }
    set_has_ap_mac();
  } else {
    clear_has_ap_mac();
  }
  ap_mac_ = ap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_bandwidth.ap_mac)
}

// optional string ap_name = 6;
inline bool uplink_bandwidth::has_ap_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void uplink_bandwidth::set_has_ap_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void uplink_bandwidth::clear_has_ap_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void uplink_bandwidth::clear_ap_name() {
  ap_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ap_name();
}
inline const ::std::string& uplink_bandwidth::ap_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.ap_name)
  return ap_name_.GetNoArena();
}
inline void uplink_bandwidth::set_ap_name(const ::std::string& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.ap_name)
}
#if LANG_CXX11
inline void uplink_bandwidth::set_ap_name(::std::string&& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.uplink_bandwidth.ap_name)
}
#endif
inline void uplink_bandwidth::set_ap_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.uplink_bandwidth.ap_name)
}
inline void uplink_bandwidth::set_ap_name(const char* value, size_t size) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.uplink_bandwidth.ap_name)
}
inline ::std::string* uplink_bandwidth::mutable_ap_name() {
  set_has_ap_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_bandwidth.ap_name)
  return ap_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* uplink_bandwidth::release_ap_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_bandwidth.ap_name)
  if (!has_ap_name()) {
    return NULL;
  }
  clear_has_ap_name();
  return ap_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void uplink_bandwidth::set_allocated_ap_name(::std::string* ap_name) {
  if (ap_name != NULL) {
    set_has_ap_name();
  } else {
    clear_has_ap_name();
  }
  ap_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ap_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_bandwidth.ap_name)
}

// optional uint64 timestamp = 7;
inline bool uplink_bandwidth::has_timestamp() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void uplink_bandwidth::set_has_timestamp() {
  _has_bits_[0] |= 0x00000400u;
}
inline void uplink_bandwidth::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void uplink_bandwidth::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 uplink_bandwidth::timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.timestamp)
  return timestamp_;
}
inline void uplink_bandwidth::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.timestamp)
}

// optional string protocol = 8;
inline bool uplink_bandwidth::has_protocol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void uplink_bandwidth::set_has_protocol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void uplink_bandwidth::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void uplink_bandwidth::clear_protocol() {
  protocol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol();
}
inline const ::std::string& uplink_bandwidth::protocol() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.protocol)
  return protocol_.GetNoArena();
}
inline void uplink_bandwidth::set_protocol(const ::std::string& value) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.protocol)
}
#if LANG_CXX11
inline void uplink_bandwidth::set_protocol(::std::string&& value) {
  set_has_protocol();
  protocol_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.uplink_bandwidth.protocol)
}
#endif
inline void uplink_bandwidth::set_protocol(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.uplink_bandwidth.protocol)
}
inline void uplink_bandwidth::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.uplink_bandwidth.protocol)
}
inline ::std::string* uplink_bandwidth::mutable_protocol() {
  set_has_protocol();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_bandwidth.protocol)
  return protocol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* uplink_bandwidth::release_protocol() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_bandwidth.protocol)
  if (!has_protocol()) {
    return NULL;
  }
  clear_has_protocol();
  return protocol_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void uplink_bandwidth::set_allocated_protocol(::std::string* protocol) {
  if (protocol != NULL) {
    set_has_protocol();
  } else {
    clear_has_protocol();
  }
  protocol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_bandwidth.protocol)
}

// optional uint32 interval = 9;
inline bool uplink_bandwidth::has_interval() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void uplink_bandwidth::set_has_interval() {
  _has_bits_[0] |= 0x00000800u;
}
inline void uplink_bandwidth::clear_has_interval() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void uplink_bandwidth::clear_interval() {
  interval_ = 0u;
  clear_has_interval();
}
inline ::google::protobuf::uint32 uplink_bandwidth::interval() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.interval)
  return interval_;
}
inline void uplink_bandwidth::set_interval(::google::protobuf::uint32 value) {
  set_has_interval();
  interval_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.interval)
}

// optional uint32 upstream_bytes = 10;
inline bool uplink_bandwidth::has_upstream_bytes() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void uplink_bandwidth::set_has_upstream_bytes() {
  _has_bits_[0] |= 0x00001000u;
}
inline void uplink_bandwidth::clear_has_upstream_bytes() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void uplink_bandwidth::clear_upstream_bytes() {
  upstream_bytes_ = 0u;
  clear_has_upstream_bytes();
}
inline ::google::protobuf::uint32 uplink_bandwidth::upstream_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.upstream_bytes)
  return upstream_bytes_;
}
inline void uplink_bandwidth::set_upstream_bytes(::google::protobuf::uint32 value) {
  set_has_upstream_bytes();
  upstream_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.upstream_bytes)
}

// optional uint32 upstream_bandwidth = 11;
inline bool uplink_bandwidth::has_upstream_bandwidth() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void uplink_bandwidth::set_has_upstream_bandwidth() {
  _has_bits_[0] |= 0x00002000u;
}
inline void uplink_bandwidth::clear_has_upstream_bandwidth() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void uplink_bandwidth::clear_upstream_bandwidth() {
  upstream_bandwidth_ = 0u;
  clear_has_upstream_bandwidth();
}
inline ::google::protobuf::uint32 uplink_bandwidth::upstream_bandwidth() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.upstream_bandwidth)
  return upstream_bandwidth_;
}
inline void uplink_bandwidth::set_upstream_bandwidth(::google::protobuf::uint32 value) {
  set_has_upstream_bandwidth();
  upstream_bandwidth_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.upstream_bandwidth)
}

// optional uint32 upstream_retries = 12;
inline bool uplink_bandwidth::has_upstream_retries() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void uplink_bandwidth::set_has_upstream_retries() {
  _has_bits_[0] |= 0x00004000u;
}
inline void uplink_bandwidth::clear_has_upstream_retries() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void uplink_bandwidth::clear_upstream_retries() {
  upstream_retries_ = 0u;
  clear_has_upstream_retries();
}
inline ::google::protobuf::uint32 uplink_bandwidth::upstream_retries() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.upstream_retries)
  return upstream_retries_;
}
inline void uplink_bandwidth::set_upstream_retries(::google::protobuf::uint32 value) {
  set_has_upstream_retries();
  upstream_retries_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.upstream_retries)
}

// optional uint32 downstream_bytes = 13;
inline bool uplink_bandwidth::has_downstream_bytes() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void uplink_bandwidth::set_has_downstream_bytes() {
  _has_bits_[0] |= 0x00008000u;
}
inline void uplink_bandwidth::clear_has_downstream_bytes() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void uplink_bandwidth::clear_downstream_bytes() {
  downstream_bytes_ = 0u;
  clear_has_downstream_bytes();
}
inline ::google::protobuf::uint32 uplink_bandwidth::downstream_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.downstream_bytes)
  return downstream_bytes_;
}
inline void uplink_bandwidth::set_downstream_bytes(::google::protobuf::uint32 value) {
  set_has_downstream_bytes();
  downstream_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.downstream_bytes)
}

// optional uint32 downstream_bandwidth = 14;
inline bool uplink_bandwidth::has_downstream_bandwidth() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void uplink_bandwidth::set_has_downstream_bandwidth() {
  _has_bits_[0] |= 0x00010000u;
}
inline void uplink_bandwidth::clear_has_downstream_bandwidth() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void uplink_bandwidth::clear_downstream_bandwidth() {
  downstream_bandwidth_ = 0u;
  clear_has_downstream_bandwidth();
}
inline ::google::protobuf::uint32 uplink_bandwidth::downstream_bandwidth() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.downstream_bandwidth)
  return downstream_bandwidth_;
}
inline void uplink_bandwidth::set_downstream_bandwidth(::google::protobuf::uint32 value) {
  set_has_downstream_bandwidth();
  downstream_bandwidth_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.downstream_bandwidth)
}

// optional uint32 downstream_retries = 15;
inline bool uplink_bandwidth::has_downstream_retries() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void uplink_bandwidth::set_has_downstream_retries() {
  _has_bits_[0] |= 0x00020000u;
}
inline void uplink_bandwidth::clear_has_downstream_retries() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void uplink_bandwidth::clear_downstream_retries() {
  downstream_retries_ = 0u;
  clear_has_downstream_retries();
}
inline ::google::protobuf::uint32 uplink_bandwidth::downstream_retries() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.downstream_retries)
  return downstream_retries_;
}
inline void uplink_bandwidth::set_downstream_retries(::google::protobuf::uint32 value) {
  set_has_downstream_retries();
  downstream_retries_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.downstream_retries)
}

// optional uint32 upstream_datagrams = 16;
inline bool uplink_bandwidth::has_upstream_datagrams() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void uplink_bandwidth::set_has_upstream_datagrams() {
  _has_bits_[0] |= 0x00040000u;
}
inline void uplink_bandwidth::clear_has_upstream_datagrams() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void uplink_bandwidth::clear_upstream_datagrams() {
  upstream_datagrams_ = 0u;
  clear_has_upstream_datagrams();
}
inline ::google::protobuf::uint32 uplink_bandwidth::upstream_datagrams() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.upstream_datagrams)
  return upstream_datagrams_;
}
inline void uplink_bandwidth::set_upstream_datagrams(::google::protobuf::uint32 value) {
  set_has_upstream_datagrams();
  upstream_datagrams_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.upstream_datagrams)
}

// optional uint32 downstream_datagrams = 17;
inline bool uplink_bandwidth::has_downstream_datagrams() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void uplink_bandwidth::set_has_downstream_datagrams() {
  _has_bits_[0] |= 0x00080000u;
}
inline void uplink_bandwidth::clear_has_downstream_datagrams() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void uplink_bandwidth::clear_downstream_datagrams() {
  downstream_datagrams_ = 0u;
  clear_has_downstream_datagrams();
}
inline ::google::protobuf::uint32 uplink_bandwidth::downstream_datagrams() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.downstream_datagrams)
  return downstream_datagrams_;
}
inline void uplink_bandwidth::set_downstream_datagrams(::google::protobuf::uint32 value) {
  set_has_downstream_datagrams();
  downstream_datagrams_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.downstream_datagrams)
}

// optional string upstream_jitter = 18;
inline bool uplink_bandwidth::has_upstream_jitter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void uplink_bandwidth::set_has_upstream_jitter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void uplink_bandwidth::clear_has_upstream_jitter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void uplink_bandwidth::clear_upstream_jitter() {
  upstream_jitter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_upstream_jitter();
}
inline const ::std::string& uplink_bandwidth::upstream_jitter() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.upstream_jitter)
  return upstream_jitter_.GetNoArena();
}
inline void uplink_bandwidth::set_upstream_jitter(const ::std::string& value) {
  set_has_upstream_jitter();
  upstream_jitter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.upstream_jitter)
}
#if LANG_CXX11
inline void uplink_bandwidth::set_upstream_jitter(::std::string&& value) {
  set_has_upstream_jitter();
  upstream_jitter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.uplink_bandwidth.upstream_jitter)
}
#endif
inline void uplink_bandwidth::set_upstream_jitter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_upstream_jitter();
  upstream_jitter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.uplink_bandwidth.upstream_jitter)
}
inline void uplink_bandwidth::set_upstream_jitter(const char* value, size_t size) {
  set_has_upstream_jitter();
  upstream_jitter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.uplink_bandwidth.upstream_jitter)
}
inline ::std::string* uplink_bandwidth::mutable_upstream_jitter() {
  set_has_upstream_jitter();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_bandwidth.upstream_jitter)
  return upstream_jitter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* uplink_bandwidth::release_upstream_jitter() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_bandwidth.upstream_jitter)
  if (!has_upstream_jitter()) {
    return NULL;
  }
  clear_has_upstream_jitter();
  return upstream_jitter_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void uplink_bandwidth::set_allocated_upstream_jitter(::std::string* upstream_jitter) {
  if (upstream_jitter != NULL) {
    set_has_upstream_jitter();
  } else {
    clear_has_upstream_jitter();
  }
  upstream_jitter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), upstream_jitter);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_bandwidth.upstream_jitter)
}

// optional string downstream_jitter = 19;
inline bool uplink_bandwidth::has_downstream_jitter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void uplink_bandwidth::set_has_downstream_jitter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void uplink_bandwidth::clear_has_downstream_jitter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void uplink_bandwidth::clear_downstream_jitter() {
  downstream_jitter_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_downstream_jitter();
}
inline const ::std::string& uplink_bandwidth::downstream_jitter() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.downstream_jitter)
  return downstream_jitter_.GetNoArena();
}
inline void uplink_bandwidth::set_downstream_jitter(const ::std::string& value) {
  set_has_downstream_jitter();
  downstream_jitter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.downstream_jitter)
}
#if LANG_CXX11
inline void uplink_bandwidth::set_downstream_jitter(::std::string&& value) {
  set_has_downstream_jitter();
  downstream_jitter_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.uplink_bandwidth.downstream_jitter)
}
#endif
inline void uplink_bandwidth::set_downstream_jitter(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_downstream_jitter();
  downstream_jitter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.uplink_bandwidth.downstream_jitter)
}
inline void uplink_bandwidth::set_downstream_jitter(const char* value, size_t size) {
  set_has_downstream_jitter();
  downstream_jitter_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.uplink_bandwidth.downstream_jitter)
}
inline ::std::string* uplink_bandwidth::mutable_downstream_jitter() {
  set_has_downstream_jitter();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_bandwidth.downstream_jitter)
  return downstream_jitter_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* uplink_bandwidth::release_downstream_jitter() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_bandwidth.downstream_jitter)
  if (!has_downstream_jitter()) {
    return NULL;
  }
  clear_has_downstream_jitter();
  return downstream_jitter_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void uplink_bandwidth::set_allocated_downstream_jitter(::std::string* downstream_jitter) {
  if (downstream_jitter != NULL) {
    set_has_downstream_jitter();
  } else {
    clear_has_downstream_jitter();
  }
  downstream_jitter_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), downstream_jitter);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_bandwidth.downstream_jitter)
}

// optional uint32 upstream_lost_packets = 20;
inline bool uplink_bandwidth::has_upstream_lost_packets() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void uplink_bandwidth::set_has_upstream_lost_packets() {
  _has_bits_[0] |= 0x00100000u;
}
inline void uplink_bandwidth::clear_has_upstream_lost_packets() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void uplink_bandwidth::clear_upstream_lost_packets() {
  upstream_lost_packets_ = 0u;
  clear_has_upstream_lost_packets();
}
inline ::google::protobuf::uint32 uplink_bandwidth::upstream_lost_packets() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.upstream_lost_packets)
  return upstream_lost_packets_;
}
inline void uplink_bandwidth::set_upstream_lost_packets(::google::protobuf::uint32 value) {
  set_has_upstream_lost_packets();
  upstream_lost_packets_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.upstream_lost_packets)
}

// optional uint32 downstream_lost_packets = 21;
inline bool uplink_bandwidth::has_downstream_lost_packets() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void uplink_bandwidth::set_has_downstream_lost_packets() {
  _has_bits_[0] |= 0x00200000u;
}
inline void uplink_bandwidth::clear_has_downstream_lost_packets() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void uplink_bandwidth::clear_downstream_lost_packets() {
  downstream_lost_packets_ = 0u;
  clear_has_downstream_lost_packets();
}
inline ::google::protobuf::uint32 uplink_bandwidth::downstream_lost_packets() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.downstream_lost_packets)
  return downstream_lost_packets_;
}
inline void uplink_bandwidth::set_downstream_lost_packets(::google::protobuf::uint32 value) {
  set_has_downstream_lost_packets();
  downstream_lost_packets_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.downstream_lost_packets)
}

// optional bytes hashed_ap_eth_mac = 22;
inline bool uplink_bandwidth::has_hashed_ap_eth_mac() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void uplink_bandwidth::set_has_hashed_ap_eth_mac() {
  _has_bits_[0] |= 0x00000010u;
}
inline void uplink_bandwidth::clear_has_hashed_ap_eth_mac() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void uplink_bandwidth::clear_hashed_ap_eth_mac() {
  hashed_ap_eth_mac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hashed_ap_eth_mac();
}
inline const ::std::string& uplink_bandwidth::hashed_ap_eth_mac() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_bandwidth.hashed_ap_eth_mac)
  return hashed_ap_eth_mac_.GetNoArena();
}
inline void uplink_bandwidth::set_hashed_ap_eth_mac(const ::std::string& value) {
  set_has_hashed_ap_eth_mac();
  hashed_ap_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_bandwidth.hashed_ap_eth_mac)
}
#if LANG_CXX11
inline void uplink_bandwidth::set_hashed_ap_eth_mac(::std::string&& value) {
  set_has_hashed_ap_eth_mac();
  hashed_ap_eth_mac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.uplink_bandwidth.hashed_ap_eth_mac)
}
#endif
inline void uplink_bandwidth::set_hashed_ap_eth_mac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hashed_ap_eth_mac();
  hashed_ap_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.uplink_bandwidth.hashed_ap_eth_mac)
}
inline void uplink_bandwidth::set_hashed_ap_eth_mac(const void* value, size_t size) {
  set_has_hashed_ap_eth_mac();
  hashed_ap_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.uplink_bandwidth.hashed_ap_eth_mac)
}
inline ::std::string* uplink_bandwidth::mutable_hashed_ap_eth_mac() {
  set_has_hashed_ap_eth_mac();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_bandwidth.hashed_ap_eth_mac)
  return hashed_ap_eth_mac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* uplink_bandwidth::release_hashed_ap_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_bandwidth.hashed_ap_eth_mac)
  if (!has_hashed_ap_eth_mac()) {
    return NULL;
  }
  clear_has_hashed_ap_eth_mac();
  return hashed_ap_eth_mac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void uplink_bandwidth::set_allocated_hashed_ap_eth_mac(::std::string* hashed_ap_eth_mac) {
  if (hashed_ap_eth_mac != NULL) {
    set_has_hashed_ap_eth_mac();
  } else {
    clear_has_hashed_ap_eth_mac();
  }
  hashed_ap_eth_mac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashed_ap_eth_mac);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_bandwidth.hashed_ap_eth_mac)
}

// -------------------------------------------------------------------

// uplink_info

// optional .ce.nbapi.mac_address device_mac = 1;
inline bool uplink_info::has_device_mac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void uplink_info::set_has_device_mac() {
  _has_bits_[0] |= 0x00000008u;
}
inline void uplink_info::clear_has_device_mac() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void uplink_info::clear_device_mac() {
  if (device_mac_ != NULL) device_mac_->Clear();
  clear_has_device_mac();
}
inline const ::ce::nbapi::mac_address& uplink_info::_internal_device_mac() const {
  return *device_mac_;
}
inline const ::ce::nbapi::mac_address& uplink_info::device_mac() const {
  const ::ce::nbapi::mac_address* p = device_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.device_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* uplink_info::release_device_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_info.device_mac)
  clear_has_device_mac();
  ::ce::nbapi::mac_address* temp = device_mac_;
  device_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* uplink_info::mutable_device_mac() {
  set_has_device_mac();
  if (device_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    device_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_info.device_mac)
  return device_mac_;
}
inline void uplink_info::set_allocated_device_mac(::ce::nbapi::mac_address* device_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete device_mac_;
  }
  if (device_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      device_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device_mac, submessage_arena);
    }
    set_has_device_mac();
  } else {
    clear_has_device_mac();
  }
  device_mac_ = device_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_info.device_mac)
}

// optional uint64 link_id = 2;
inline bool uplink_info::has_link_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void uplink_info::set_has_link_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void uplink_info::clear_has_link_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void uplink_info::clear_link_id() {
  link_id_ = GOOGLE_ULONGLONG(0);
  clear_has_link_id();
}
inline ::google::protobuf::uint64 uplink_info::link_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.link_id)
  return link_id_;
}
inline void uplink_info::set_link_id(::google::protobuf::uint64 value) {
  set_has_link_id();
  link_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_info.link_id)
}

// optional string desc = 3;
inline bool uplink_info::has_desc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void uplink_info::set_has_desc() {
  _has_bits_[0] |= 0x00000001u;
}
inline void uplink_info::clear_has_desc() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void uplink_info::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_desc();
}
inline const ::std::string& uplink_info::desc() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.desc)
  return desc_.GetNoArena();
}
inline void uplink_info::set_desc(const ::std::string& value) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_info.desc)
}
#if LANG_CXX11
inline void uplink_info::set_desc(::std::string&& value) {
  set_has_desc();
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.uplink_info.desc)
}
#endif
inline void uplink_info::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.uplink_info.desc)
}
inline void uplink_info::set_desc(const char* value, size_t size) {
  set_has_desc();
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.uplink_info.desc)
}
inline ::std::string* uplink_info::mutable_desc() {
  set_has_desc();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_info.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* uplink_info::release_desc() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_info.desc)
  if (!has_desc()) {
    return NULL;
  }
  clear_has_desc();
  return desc_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void uplink_info::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    set_has_desc();
  } else {
    clear_has_desc();
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_info.desc)
}

// optional uint32 link_status = 4;
inline bool uplink_info::has_link_status() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void uplink_info::set_has_link_status() {
  _has_bits_[0] |= 0x00000100u;
}
inline void uplink_info::clear_has_link_status() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void uplink_info::clear_link_status() {
  link_status_ = 0u;
  clear_has_link_status();
}
inline ::google::protobuf::uint32 uplink_info::link_status() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.link_status)
  return link_status_;
}
inline void uplink_info::set_link_status(::google::protobuf::uint32 value) {
  set_has_link_status();
  link_status_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_info.link_status)
}

// optional uint64 vlan_id = 5;
inline bool uplink_info::has_vlan_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void uplink_info::set_has_vlan_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void uplink_info::clear_has_vlan_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void uplink_info::clear_vlan_id() {
  vlan_id_ = GOOGLE_ULONGLONG(0);
  clear_has_vlan_id();
}
inline ::google::protobuf::uint64 uplink_info::vlan_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.vlan_id)
  return vlan_id_;
}
inline void uplink_info::set_vlan_id(::google::protobuf::uint64 value) {
  set_has_vlan_id();
  vlan_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_info.vlan_id)
}

// optional string port_tunnel_desc = 6;
inline bool uplink_info::has_port_tunnel_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void uplink_info::set_has_port_tunnel_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void uplink_info::clear_has_port_tunnel_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void uplink_info::clear_port_tunnel_desc() {
  port_tunnel_desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_port_tunnel_desc();
}
inline const ::std::string& uplink_info::port_tunnel_desc() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.port_tunnel_desc)
  return port_tunnel_desc_.GetNoArena();
}
inline void uplink_info::set_port_tunnel_desc(const ::std::string& value) {
  set_has_port_tunnel_desc();
  port_tunnel_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_info.port_tunnel_desc)
}
#if LANG_CXX11
inline void uplink_info::set_port_tunnel_desc(::std::string&& value) {
  set_has_port_tunnel_desc();
  port_tunnel_desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.uplink_info.port_tunnel_desc)
}
#endif
inline void uplink_info::set_port_tunnel_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_port_tunnel_desc();
  port_tunnel_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.uplink_info.port_tunnel_desc)
}
inline void uplink_info::set_port_tunnel_desc(const char* value, size_t size) {
  set_has_port_tunnel_desc();
  port_tunnel_desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.uplink_info.port_tunnel_desc)
}
inline ::std::string* uplink_info::mutable_port_tunnel_desc() {
  set_has_port_tunnel_desc();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_info.port_tunnel_desc)
  return port_tunnel_desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* uplink_info::release_port_tunnel_desc() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_info.port_tunnel_desc)
  if (!has_port_tunnel_desc()) {
    return NULL;
  }
  clear_has_port_tunnel_desc();
  return port_tunnel_desc_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void uplink_info::set_allocated_port_tunnel_desc(::std::string* port_tunnel_desc) {
  if (port_tunnel_desc != NULL) {
    set_has_port_tunnel_desc();
  } else {
    clear_has_port_tunnel_desc();
  }
  port_tunnel_desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), port_tunnel_desc);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_info.port_tunnel_desc)
}

// optional uint32 link_prio = 7;
inline bool uplink_info::has_link_prio() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void uplink_info::set_has_link_prio() {
  _has_bits_[0] |= 0x00000200u;
}
inline void uplink_info::clear_has_link_prio() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void uplink_info::clear_link_prio() {
  link_prio_ = 0u;
  clear_has_link_prio();
}
inline ::google::protobuf::uint32 uplink_info::link_prio() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.link_prio)
  return link_prio_;
}
inline void uplink_info::set_link_prio(::google::protobuf::uint32 value) {
  set_has_link_prio();
  link_prio_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_info.link_prio)
}

// optional uint32 wan_status = 8;
inline bool uplink_info::has_wan_status() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void uplink_info::set_has_wan_status() {
  _has_bits_[0] |= 0x00000400u;
}
inline void uplink_info::clear_has_wan_status() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void uplink_info::clear_wan_status() {
  wan_status_ = 0u;
  clear_has_wan_status();
}
inline ::google::protobuf::uint32 uplink_info::wan_status() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.wan_status)
  return wan_status_;
}
inline void uplink_info::set_wan_status(::google::protobuf::uint32 value) {
  set_has_wan_status();
  wan_status_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_info.wan_status)
}

// optional uint32 crypto_type = 9;
inline bool uplink_info::has_crypto_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void uplink_info::set_has_crypto_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void uplink_info::clear_has_crypto_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void uplink_info::clear_crypto_type() {
  crypto_type_ = 0u;
  clear_has_crypto_type();
}
inline ::google::protobuf::uint32 uplink_info::crypto_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.crypto_type)
  return crypto_type_;
}
inline void uplink_info::set_crypto_type(::google::protobuf::uint32 value) {
  set_has_crypto_type();
  crypto_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_info.crypto_type)
}

// optional uint32 tunnel_active_status = 10;
inline bool uplink_info::has_tunnel_active_status() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void uplink_info::set_has_tunnel_active_status() {
  _has_bits_[0] |= 0x00002000u;
}
inline void uplink_info::clear_has_tunnel_active_status() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void uplink_info::clear_tunnel_active_status() {
  tunnel_active_status_ = 0u;
  clear_has_tunnel_active_status();
}
inline ::google::protobuf::uint32 uplink_info::tunnel_active_status() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.tunnel_active_status)
  return tunnel_active_status_;
}
inline void uplink_info::set_tunnel_active_status(::google::protobuf::uint32 value) {
  set_has_tunnel_active_status();
  tunnel_active_status_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_info.tunnel_active_status)
}

// optional uint64 tunnel_uptime = 11;
inline bool uplink_info::has_tunnel_uptime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void uplink_info::set_has_tunnel_uptime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void uplink_info::clear_has_tunnel_uptime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void uplink_info::clear_tunnel_uptime() {
  tunnel_uptime_ = GOOGLE_ULONGLONG(0);
  clear_has_tunnel_uptime();
}
inline ::google::protobuf::uint64 uplink_info::tunnel_uptime() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.tunnel_uptime)
  return tunnel_uptime_;
}
inline void uplink_info::set_tunnel_uptime(::google::protobuf::uint64 value) {
  set_has_tunnel_uptime();
  tunnel_uptime_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_info.tunnel_uptime)
}

// optional .ce.nbapi.ip_address peer_tunnel_ip = 12;
inline bool uplink_info::has_peer_tunnel_ip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void uplink_info::set_has_peer_tunnel_ip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void uplink_info::clear_has_peer_tunnel_ip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void uplink_info::clear_peer_tunnel_ip() {
  if (peer_tunnel_ip_ != NULL) peer_tunnel_ip_->Clear();
  clear_has_peer_tunnel_ip();
}
inline const ::ce::nbapi::ip_address& uplink_info::_internal_peer_tunnel_ip() const {
  return *peer_tunnel_ip_;
}
inline const ::ce::nbapi::ip_address& uplink_info::peer_tunnel_ip() const {
  const ::ce::nbapi::ip_address* p = peer_tunnel_ip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.peer_tunnel_ip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* uplink_info::release_peer_tunnel_ip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_info.peer_tunnel_ip)
  clear_has_peer_tunnel_ip();
  ::ce::nbapi::ip_address* temp = peer_tunnel_ip_;
  peer_tunnel_ip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* uplink_info::mutable_peer_tunnel_ip() {
  set_has_peer_tunnel_ip();
  if (peer_tunnel_ip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    peer_tunnel_ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_info.peer_tunnel_ip)
  return peer_tunnel_ip_;
}
inline void uplink_info::set_allocated_peer_tunnel_ip(::ce::nbapi::ip_address* peer_tunnel_ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete peer_tunnel_ip_;
  }
  if (peer_tunnel_ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      peer_tunnel_ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, peer_tunnel_ip, submessage_arena);
    }
    set_has_peer_tunnel_ip();
  } else {
    clear_has_peer_tunnel_ip();
  }
  peer_tunnel_ip_ = peer_tunnel_ip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_info.peer_tunnel_ip)
}

// optional .ce.nbapi.ip_address tunnel_ip = 13;
inline bool uplink_info::has_tunnel_ip() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void uplink_info::set_has_tunnel_ip() {
  _has_bits_[0] |= 0x00000020u;
}
inline void uplink_info::clear_has_tunnel_ip() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void uplink_info::clear_tunnel_ip() {
  if (tunnel_ip_ != NULL) tunnel_ip_->Clear();
  clear_has_tunnel_ip();
}
inline const ::ce::nbapi::ip_address& uplink_info::_internal_tunnel_ip() const {
  return *tunnel_ip_;
}
inline const ::ce::nbapi::ip_address& uplink_info::tunnel_ip() const {
  const ::ce::nbapi::ip_address* p = tunnel_ip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.tunnel_ip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* uplink_info::release_tunnel_ip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_info.tunnel_ip)
  clear_has_tunnel_ip();
  ::ce::nbapi::ip_address* temp = tunnel_ip_;
  tunnel_ip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* uplink_info::mutable_tunnel_ip() {
  set_has_tunnel_ip();
  if (tunnel_ip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    tunnel_ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_info.tunnel_ip)
  return tunnel_ip_;
}
inline void uplink_info::set_allocated_tunnel_ip(::ce::nbapi::ip_address* tunnel_ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tunnel_ip_;
  }
  if (tunnel_ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tunnel_ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tunnel_ip, submessage_arena);
    }
    set_has_tunnel_ip();
  } else {
    clear_has_tunnel_ip();
  }
  tunnel_ip_ = tunnel_ip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_info.tunnel_ip)
}

// optional string tunnel_name = 14;
inline bool uplink_info::has_tunnel_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void uplink_info::set_has_tunnel_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void uplink_info::clear_has_tunnel_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void uplink_info::clear_tunnel_name() {
  tunnel_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tunnel_name();
}
inline const ::std::string& uplink_info::tunnel_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.uplink_info.tunnel_name)
  return tunnel_name_.GetNoArena();
}
inline void uplink_info::set_tunnel_name(const ::std::string& value) {
  set_has_tunnel_name();
  tunnel_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.uplink_info.tunnel_name)
}
#if LANG_CXX11
inline void uplink_info::set_tunnel_name(::std::string&& value) {
  set_has_tunnel_name();
  tunnel_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.uplink_info.tunnel_name)
}
#endif
inline void uplink_info::set_tunnel_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tunnel_name();
  tunnel_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.uplink_info.tunnel_name)
}
inline void uplink_info::set_tunnel_name(const char* value, size_t size) {
  set_has_tunnel_name();
  tunnel_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.uplink_info.tunnel_name)
}
inline ::std::string* uplink_info::mutable_tunnel_name() {
  set_has_tunnel_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.uplink_info.tunnel_name)
  return tunnel_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* uplink_info::release_tunnel_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.uplink_info.tunnel_name)
  if (!has_tunnel_name()) {
    return NULL;
  }
  clear_has_tunnel_name();
  return tunnel_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void uplink_info::set_allocated_tunnel_name(::std::string* tunnel_name) {
  if (tunnel_name != NULL) {
    set_has_tunnel_name();
  } else {
    clear_has_tunnel_name();
  }
  tunnel_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tunnel_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.uplink_info.tunnel_name)
}

// -------------------------------------------------------------------

// stats_uplink

// optional .ce.nbapi.mac_address device_mac = 1;
inline bool stats_uplink::has_device_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stats_uplink::set_has_device_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stats_uplink::clear_has_device_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stats_uplink::clear_device_mac() {
  if (device_mac_ != NULL) device_mac_->Clear();
  clear_has_device_mac();
}
inline const ::ce::nbapi::mac_address& stats_uplink::_internal_device_mac() const {
  return *device_mac_;
}
inline const ::ce::nbapi::mac_address& stats_uplink::device_mac() const {
  const ::ce::nbapi::mac_address* p = device_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_uplink.device_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_uplink::release_device_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_uplink.device_mac)
  clear_has_device_mac();
  ::ce::nbapi::mac_address* temp = device_mac_;
  device_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_uplink::mutable_device_mac() {
  set_has_device_mac();
  if (device_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    device_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_uplink.device_mac)
  return device_mac_;
}
inline void stats_uplink::set_allocated_device_mac(::ce::nbapi::mac_address* device_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete device_mac_;
  }
  if (device_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      device_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device_mac, submessage_arena);
    }
    set_has_device_mac();
  } else {
    clear_has_device_mac();
  }
  device_mac_ = device_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_uplink.device_mac)
}

// optional uint64 link_id = 2;
inline bool stats_uplink::has_link_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void stats_uplink::set_has_link_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void stats_uplink::clear_has_link_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void stats_uplink::clear_link_id() {
  link_id_ = GOOGLE_ULONGLONG(0);
  clear_has_link_id();
}
inline ::google::protobuf::uint64 stats_uplink::link_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_uplink.link_id)
  return link_id_;
}
inline void stats_uplink::set_link_id(::google::protobuf::uint64 value) {
  set_has_link_id();
  link_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_uplink.link_id)
}

// optional uint64 rx_pkts = 3;
inline bool stats_uplink::has_rx_pkts() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void stats_uplink::set_has_rx_pkts() {
  _has_bits_[0] |= 0x00000008u;
}
inline void stats_uplink::clear_has_rx_pkts() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void stats_uplink::clear_rx_pkts() {
  rx_pkts_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_pkts();
}
inline ::google::protobuf::uint64 stats_uplink::rx_pkts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_uplink.rx_pkts)
  return rx_pkts_;
}
inline void stats_uplink::set_rx_pkts(::google::protobuf::uint64 value) {
  set_has_rx_pkts();
  rx_pkts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_uplink.rx_pkts)
}

// optional uint64 tx_pkts = 4;
inline bool stats_uplink::has_tx_pkts() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void stats_uplink::set_has_tx_pkts() {
  _has_bits_[0] |= 0x00000010u;
}
inline void stats_uplink::clear_has_tx_pkts() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void stats_uplink::clear_tx_pkts() {
  tx_pkts_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_pkts();
}
inline ::google::protobuf::uint64 stats_uplink::tx_pkts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_uplink.tx_pkts)
  return tx_pkts_;
}
inline void stats_uplink::set_tx_pkts(::google::protobuf::uint64 value) {
  set_has_tx_pkts();
  tx_pkts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_uplink.tx_pkts)
}

// optional uint64 rx_bytes = 5;
inline bool stats_uplink::has_rx_bytes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void stats_uplink::set_has_rx_bytes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void stats_uplink::clear_has_rx_bytes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void stats_uplink::clear_rx_bytes() {
  rx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_bytes();
}
inline ::google::protobuf::uint64 stats_uplink::rx_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_uplink.rx_bytes)
  return rx_bytes_;
}
inline void stats_uplink::set_rx_bytes(::google::protobuf::uint64 value) {
  set_has_rx_bytes();
  rx_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_uplink.rx_bytes)
}

// optional uint64 tx_bytes = 6;
inline bool stats_uplink::has_tx_bytes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void stats_uplink::set_has_tx_bytes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void stats_uplink::clear_has_tx_bytes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void stats_uplink::clear_tx_bytes() {
  tx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_bytes();
}
inline ::google::protobuf::uint64 stats_uplink::tx_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_uplink.tx_bytes)
  return tx_bytes_;
}
inline void stats_uplink::set_tx_bytes(::google::protobuf::uint64 value) {
  set_has_tx_bytes();
  tx_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_uplink.tx_bytes)
}

// optional uint32 vlan_id = 7;
inline bool stats_uplink::has_vlan_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void stats_uplink::set_has_vlan_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void stats_uplink::clear_has_vlan_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void stats_uplink::clear_vlan_id() {
  vlan_id_ = 0u;
  clear_has_vlan_id();
}
inline ::google::protobuf::uint32 stats_uplink::vlan_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_uplink.vlan_id)
  return vlan_id_;
}
inline void stats_uplink::set_vlan_id(::google::protobuf::uint32 value) {
  set_has_vlan_id();
  vlan_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_uplink.vlan_id)
}

// optional string tunnel_name = 8;
inline bool stats_uplink::has_tunnel_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stats_uplink::set_has_tunnel_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stats_uplink::clear_has_tunnel_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stats_uplink::clear_tunnel_name() {
  tunnel_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tunnel_name();
}
inline const ::std::string& stats_uplink::tunnel_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_uplink.tunnel_name)
  return tunnel_name_.GetNoArena();
}
inline void stats_uplink::set_tunnel_name(const ::std::string& value) {
  set_has_tunnel_name();
  tunnel_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_uplink.tunnel_name)
}
#if LANG_CXX11
inline void stats_uplink::set_tunnel_name(::std::string&& value) {
  set_has_tunnel_name();
  tunnel_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.stats_uplink.tunnel_name)
}
#endif
inline void stats_uplink::set_tunnel_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tunnel_name();
  tunnel_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.stats_uplink.tunnel_name)
}
inline void stats_uplink::set_tunnel_name(const char* value, size_t size) {
  set_has_tunnel_name();
  tunnel_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.stats_uplink.tunnel_name)
}
inline ::std::string* stats_uplink::mutable_tunnel_name() {
  set_has_tunnel_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_uplink.tunnel_name)
  return tunnel_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* stats_uplink::release_tunnel_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_uplink.tunnel_name)
  if (!has_tunnel_name()) {
    return NULL;
  }
  clear_has_tunnel_name();
  return tunnel_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void stats_uplink::set_allocated_tunnel_name(::std::string* tunnel_name) {
  if (tunnel_name != NULL) {
    set_has_tunnel_name();
  } else {
    clear_has_tunnel_name();
  }
  tunnel_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tunnel_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_uplink.tunnel_name)
}

// -------------------------------------------------------------------

// wan_comp_uplink

// optional .ce.nbapi.mac_address boc_mac = 1;
inline bool wan_comp_uplink::has_boc_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void wan_comp_uplink::set_has_boc_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void wan_comp_uplink::clear_has_boc_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void wan_comp_uplink::clear_boc_mac() {
  if (boc_mac_ != NULL) boc_mac_->Clear();
  clear_has_boc_mac();
}
inline const ::ce::nbapi::mac_address& wan_comp_uplink::_internal_boc_mac() const {
  return *boc_mac_;
}
inline const ::ce::nbapi::mac_address& wan_comp_uplink::boc_mac() const {
  const ::ce::nbapi::mac_address* p = boc_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.wan_comp_uplink.boc_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* wan_comp_uplink::release_boc_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.wan_comp_uplink.boc_mac)
  clear_has_boc_mac();
  ::ce::nbapi::mac_address* temp = boc_mac_;
  boc_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* wan_comp_uplink::mutable_boc_mac() {
  set_has_boc_mac();
  if (boc_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    boc_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.wan_comp_uplink.boc_mac)
  return boc_mac_;
}
inline void wan_comp_uplink::set_allocated_boc_mac(::ce::nbapi::mac_address* boc_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete boc_mac_;
  }
  if (boc_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      boc_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, boc_mac, submessage_arena);
    }
    set_has_boc_mac();
  } else {
    clear_has_boc_mac();
  }
  boc_mac_ = boc_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.wan_comp_uplink.boc_mac)
}

// optional uint64 link_id = 2;
inline bool wan_comp_uplink::has_link_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void wan_comp_uplink::set_has_link_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void wan_comp_uplink::clear_has_link_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void wan_comp_uplink::clear_link_id() {
  link_id_ = GOOGLE_ULONGLONG(0);
  clear_has_link_id();
}
inline ::google::protobuf::uint64 wan_comp_uplink::link_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.wan_comp_uplink.link_id)
  return link_id_;
}
inline void wan_comp_uplink::set_link_id(::google::protobuf::uint64 value) {
  set_has_link_id();
  link_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.wan_comp_uplink.link_id)
}

// optional uint64 tot_comp_bytes = 3;
inline bool wan_comp_uplink::has_tot_comp_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void wan_comp_uplink::set_has_tot_comp_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void wan_comp_uplink::clear_has_tot_comp_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void wan_comp_uplink::clear_tot_comp_bytes() {
  tot_comp_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_tot_comp_bytes();
}
inline ::google::protobuf::uint64 wan_comp_uplink::tot_comp_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.wan_comp_uplink.tot_comp_bytes)
  return tot_comp_bytes_;
}
inline void wan_comp_uplink::set_tot_comp_bytes(::google::protobuf::uint64 value) {
  set_has_tot_comp_bytes();
  tot_comp_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.wan_comp_uplink.tot_comp_bytes)
}

// optional uint64 tot_uncomp_bytes = 4;
inline bool wan_comp_uplink::has_tot_uncomp_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void wan_comp_uplink::set_has_tot_uncomp_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void wan_comp_uplink::clear_has_tot_uncomp_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void wan_comp_uplink::clear_tot_uncomp_bytes() {
  tot_uncomp_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_tot_uncomp_bytes();
}
inline ::google::protobuf::uint64 wan_comp_uplink::tot_uncomp_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.wan_comp_uplink.tot_uncomp_bytes)
  return tot_uncomp_bytes_;
}
inline void wan_comp_uplink::set_tot_uncomp_bytes(::google::protobuf::uint64 value) {
  set_has_tot_uncomp_bytes();
  tot_uncomp_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.wan_comp_uplink.tot_uncomp_bytes)
}

// optional uint64 tot_comp_savings = 5;
inline bool wan_comp_uplink::has_tot_comp_savings() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void wan_comp_uplink::set_has_tot_comp_savings() {
  _has_bits_[0] |= 0x00000010u;
}
inline void wan_comp_uplink::clear_has_tot_comp_savings() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void wan_comp_uplink::clear_tot_comp_savings() {
  tot_comp_savings_ = GOOGLE_ULONGLONG(0);
  clear_has_tot_comp_savings();
}
inline ::google::protobuf::uint64 wan_comp_uplink::tot_comp_savings() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.wan_comp_uplink.tot_comp_savings)
  return tot_comp_savings_;
}
inline void wan_comp_uplink::set_tot_comp_savings(::google::protobuf::uint64 value) {
  set_has_tot_comp_savings();
  tot_comp_savings_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.wan_comp_uplink.tot_comp_savings)
}

// -------------------------------------------------------------------

// stats_ip_probe_uplink

// optional .ce.nbapi.mac_address device_mac = 1;
inline bool stats_ip_probe_uplink::has_device_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stats_ip_probe_uplink::set_has_device_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stats_ip_probe_uplink::clear_has_device_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stats_ip_probe_uplink::clear_device_mac() {
  if (device_mac_ != NULL) device_mac_->Clear();
  clear_has_device_mac();
}
inline const ::ce::nbapi::mac_address& stats_ip_probe_uplink::_internal_device_mac() const {
  return *device_mac_;
}
inline const ::ce::nbapi::mac_address& stats_ip_probe_uplink::device_mac() const {
  const ::ce::nbapi::mac_address* p = device_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.device_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_ip_probe_uplink::release_device_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_ip_probe_uplink.device_mac)
  clear_has_device_mac();
  ::ce::nbapi::mac_address* temp = device_mac_;
  device_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_ip_probe_uplink::mutable_device_mac() {
  set_has_device_mac();
  if (device_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    device_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_ip_probe_uplink.device_mac)
  return device_mac_;
}
inline void stats_ip_probe_uplink::set_allocated_device_mac(::ce::nbapi::mac_address* device_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete device_mac_;
  }
  if (device_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      device_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device_mac, submessage_arena);
    }
    set_has_device_mac();
  } else {
    clear_has_device_mac();
  }
  device_mac_ = device_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_ip_probe_uplink.device_mac)
}

// optional uint64 link_id = 2;
inline bool stats_ip_probe_uplink::has_link_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void stats_ip_probe_uplink::set_has_link_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void stats_ip_probe_uplink::clear_has_link_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void stats_ip_probe_uplink::clear_link_id() {
  link_id_ = GOOGLE_ULONGLONG(0);
  clear_has_link_id();
}
inline ::google::protobuf::uint64 stats_ip_probe_uplink::link_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.link_id)
  return link_id_;
}
inline void stats_ip_probe_uplink::set_link_id(::google::protobuf::uint64 value) {
  set_has_link_id();
  link_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.link_id)
}

// optional .ce.nbapi.ip_address probe_ip_addr = 3;
inline bool stats_ip_probe_uplink::has_probe_ip_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void stats_ip_probe_uplink::set_has_probe_ip_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void stats_ip_probe_uplink::clear_has_probe_ip_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void stats_ip_probe_uplink::clear_probe_ip_addr() {
  if (probe_ip_addr_ != NULL) probe_ip_addr_->Clear();
  clear_has_probe_ip_addr();
}
inline const ::ce::nbapi::ip_address& stats_ip_probe_uplink::_internal_probe_ip_addr() const {
  return *probe_ip_addr_;
}
inline const ::ce::nbapi::ip_address& stats_ip_probe_uplink::probe_ip_addr() const {
  const ::ce::nbapi::ip_address* p = probe_ip_addr_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.probe_ip_addr)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* stats_ip_probe_uplink::release_probe_ip_addr() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_ip_probe_uplink.probe_ip_addr)
  clear_has_probe_ip_addr();
  ::ce::nbapi::ip_address* temp = probe_ip_addr_;
  probe_ip_addr_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* stats_ip_probe_uplink::mutable_probe_ip_addr() {
  set_has_probe_ip_addr();
  if (probe_ip_addr_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    probe_ip_addr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_ip_probe_uplink.probe_ip_addr)
  return probe_ip_addr_;
}
inline void stats_ip_probe_uplink::set_allocated_probe_ip_addr(::ce::nbapi::ip_address* probe_ip_addr) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete probe_ip_addr_;
  }
  if (probe_ip_addr) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      probe_ip_addr = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, probe_ip_addr, submessage_arena);
    }
    set_has_probe_ip_addr();
  } else {
    clear_has_probe_ip_addr();
  }
  probe_ip_addr_ = probe_ip_addr;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_ip_probe_uplink.probe_ip_addr)
}

// optional uint32 vlan_id = 4;
inline bool stats_ip_probe_uplink::has_vlan_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void stats_ip_probe_uplink::set_has_vlan_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void stats_ip_probe_uplink::clear_has_vlan_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void stats_ip_probe_uplink::clear_vlan_id() {
  vlan_id_ = 0u;
  clear_has_vlan_id();
}
inline ::google::protobuf::uint32 stats_ip_probe_uplink::vlan_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.vlan_id)
  return vlan_id_;
}
inline void stats_ip_probe_uplink::set_vlan_id(::google::protobuf::uint32 value) {
  set_has_vlan_id();
  vlan_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.vlan_id)
}

// optional uint64 avg_rtt = 5;
inline bool stats_ip_probe_uplink::has_avg_rtt() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void stats_ip_probe_uplink::set_has_avg_rtt() {
  _has_bits_[0] |= 0x00000010u;
}
inline void stats_ip_probe_uplink::clear_has_avg_rtt() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void stats_ip_probe_uplink::clear_avg_rtt() {
  avg_rtt_ = GOOGLE_ULONGLONG(0);
  clear_has_avg_rtt();
}
inline ::google::protobuf::uint64 stats_ip_probe_uplink::avg_rtt() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.avg_rtt)
  return avg_rtt_;
}
inline void stats_ip_probe_uplink::set_avg_rtt(::google::protobuf::uint64 value) {
  set_has_avg_rtt();
  avg_rtt_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.avg_rtt)
}

// optional uint64 max_rtt = 6;
inline bool stats_ip_probe_uplink::has_max_rtt() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void stats_ip_probe_uplink::set_has_max_rtt() {
  _has_bits_[0] |= 0x00000020u;
}
inline void stats_ip_probe_uplink::clear_has_max_rtt() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void stats_ip_probe_uplink::clear_max_rtt() {
  max_rtt_ = GOOGLE_ULONGLONG(0);
  clear_has_max_rtt();
}
inline ::google::protobuf::uint64 stats_ip_probe_uplink::max_rtt() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.max_rtt)
  return max_rtt_;
}
inline void stats_ip_probe_uplink::set_max_rtt(::google::protobuf::uint64 value) {
  set_has_max_rtt();
  max_rtt_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.max_rtt)
}

// optional uint64 min_rtt = 7;
inline bool stats_ip_probe_uplink::has_min_rtt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void stats_ip_probe_uplink::set_has_min_rtt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void stats_ip_probe_uplink::clear_has_min_rtt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void stats_ip_probe_uplink::clear_min_rtt() {
  min_rtt_ = GOOGLE_ULONGLONG(0);
  clear_has_min_rtt();
}
inline ::google::protobuf::uint64 stats_ip_probe_uplink::min_rtt() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.min_rtt)
  return min_rtt_;
}
inline void stats_ip_probe_uplink::set_min_rtt(::google::protobuf::uint64 value) {
  set_has_min_rtt();
  min_rtt_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.min_rtt)
}

// optional uint64 avg_jitter = 8;
inline bool stats_ip_probe_uplink::has_avg_jitter() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void stats_ip_probe_uplink::set_has_avg_jitter() {
  _has_bits_[0] |= 0x00000080u;
}
inline void stats_ip_probe_uplink::clear_has_avg_jitter() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void stats_ip_probe_uplink::clear_avg_jitter() {
  avg_jitter_ = GOOGLE_ULONGLONG(0);
  clear_has_avg_jitter();
}
inline ::google::protobuf::uint64 stats_ip_probe_uplink::avg_jitter() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.avg_jitter)
  return avg_jitter_;
}
inline void stats_ip_probe_uplink::set_avg_jitter(::google::protobuf::uint64 value) {
  set_has_avg_jitter();
  avg_jitter_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.avg_jitter)
}

// optional uint64 max_jitter = 9;
inline bool stats_ip_probe_uplink::has_max_jitter() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void stats_ip_probe_uplink::set_has_max_jitter() {
  _has_bits_[0] |= 0x00000400u;
}
inline void stats_ip_probe_uplink::clear_has_max_jitter() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void stats_ip_probe_uplink::clear_max_jitter() {
  max_jitter_ = GOOGLE_ULONGLONG(0);
  clear_has_max_jitter();
}
inline ::google::protobuf::uint64 stats_ip_probe_uplink::max_jitter() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.max_jitter)
  return max_jitter_;
}
inline void stats_ip_probe_uplink::set_max_jitter(::google::protobuf::uint64 value) {
  set_has_max_jitter();
  max_jitter_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.max_jitter)
}

// optional uint64 min_jitter = 10;
inline bool stats_ip_probe_uplink::has_min_jitter() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void stats_ip_probe_uplink::set_has_min_jitter() {
  _has_bits_[0] |= 0x00000800u;
}
inline void stats_ip_probe_uplink::clear_has_min_jitter() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void stats_ip_probe_uplink::clear_min_jitter() {
  min_jitter_ = GOOGLE_ULONGLONG(0);
  clear_has_min_jitter();
}
inline ::google::protobuf::uint64 stats_ip_probe_uplink::min_jitter() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.min_jitter)
  return min_jitter_;
}
inline void stats_ip_probe_uplink::set_min_jitter(::google::protobuf::uint64 value) {
  set_has_min_jitter();
  min_jitter_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.min_jitter)
}

// optional uint64 mos_quality = 11;
inline bool stats_ip_probe_uplink::has_mos_quality() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void stats_ip_probe_uplink::set_has_mos_quality() {
  _has_bits_[0] |= 0x00001000u;
}
inline void stats_ip_probe_uplink::clear_has_mos_quality() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void stats_ip_probe_uplink::clear_mos_quality() {
  mos_quality_ = GOOGLE_ULONGLONG(0);
  clear_has_mos_quality();
}
inline ::google::protobuf::uint64 stats_ip_probe_uplink::mos_quality() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.mos_quality)
  return mos_quality_;
}
inline void stats_ip_probe_uplink::set_mos_quality(::google::protobuf::uint64 value) {
  set_has_mos_quality();
  mos_quality_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.mos_quality)
}

// optional uint32 probe_status = 12;
inline bool stats_ip_probe_uplink::has_probe_status() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void stats_ip_probe_uplink::set_has_probe_status() {
  _has_bits_[0] |= 0x00000200u;
}
inline void stats_ip_probe_uplink::clear_has_probe_status() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void stats_ip_probe_uplink::clear_probe_status() {
  probe_status_ = 0u;
  clear_has_probe_status();
}
inline ::google::protobuf::uint32 stats_ip_probe_uplink::probe_status() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.probe_status)
  return probe_status_;
}
inline void stats_ip_probe_uplink::set_probe_status(::google::protobuf::uint32 value) {
  set_has_probe_status();
  probe_status_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.probe_status)
}

// optional uint32 ip_probe_pkt_loss_pct = 13;
inline bool stats_ip_probe_uplink::has_ip_probe_pkt_loss_pct() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void stats_ip_probe_uplink::set_has_ip_probe_pkt_loss_pct() {
  _has_bits_[0] |= 0x00020000u;
}
inline void stats_ip_probe_uplink::clear_has_ip_probe_pkt_loss_pct() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void stats_ip_probe_uplink::clear_ip_probe_pkt_loss_pct() {
  ip_probe_pkt_loss_pct_ = 0u;
  clear_has_ip_probe_pkt_loss_pct();
}
inline ::google::protobuf::uint32 stats_ip_probe_uplink::ip_probe_pkt_loss_pct() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.ip_probe_pkt_loss_pct)
  return ip_probe_pkt_loss_pct_;
}
inline void stats_ip_probe_uplink::set_ip_probe_pkt_loss_pct(::google::protobuf::uint32 value) {
  set_has_ip_probe_pkt_loss_pct();
  ip_probe_pkt_loss_pct_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.ip_probe_pkt_loss_pct)
}

// optional string tunnel_name = 14;
inline bool stats_ip_probe_uplink::has_tunnel_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stats_ip_probe_uplink::set_has_tunnel_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stats_ip_probe_uplink::clear_has_tunnel_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stats_ip_probe_uplink::clear_tunnel_name() {
  tunnel_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_tunnel_name();
}
inline const ::std::string& stats_ip_probe_uplink::tunnel_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.tunnel_name)
  return tunnel_name_.GetNoArena();
}
inline void stats_ip_probe_uplink::set_tunnel_name(const ::std::string& value) {
  set_has_tunnel_name();
  tunnel_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.tunnel_name)
}
#if LANG_CXX11
inline void stats_ip_probe_uplink::set_tunnel_name(::std::string&& value) {
  set_has_tunnel_name();
  tunnel_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.stats_ip_probe_uplink.tunnel_name)
}
#endif
inline void stats_ip_probe_uplink::set_tunnel_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_tunnel_name();
  tunnel_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.stats_ip_probe_uplink.tunnel_name)
}
inline void stats_ip_probe_uplink::set_tunnel_name(const char* value, size_t size) {
  set_has_tunnel_name();
  tunnel_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.stats_ip_probe_uplink.tunnel_name)
}
inline ::std::string* stats_ip_probe_uplink::mutable_tunnel_name() {
  set_has_tunnel_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_ip_probe_uplink.tunnel_name)
  return tunnel_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* stats_ip_probe_uplink::release_tunnel_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_ip_probe_uplink.tunnel_name)
  if (!has_tunnel_name()) {
    return NULL;
  }
  clear_has_tunnel_name();
  return tunnel_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void stats_ip_probe_uplink::set_allocated_tunnel_name(::std::string* tunnel_name) {
  if (tunnel_name != NULL) {
    set_has_tunnel_name();
  } else {
    clear_has_tunnel_name();
  }
  tunnel_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tunnel_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_ip_probe_uplink.tunnel_name)
}

// optional uint64 sd_avg_latency = 15;
inline bool stats_ip_probe_uplink::has_sd_avg_latency() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void stats_ip_probe_uplink::set_has_sd_avg_latency() {
  _has_bits_[0] |= 0x00002000u;
}
inline void stats_ip_probe_uplink::clear_has_sd_avg_latency() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void stats_ip_probe_uplink::clear_sd_avg_latency() {
  sd_avg_latency_ = GOOGLE_ULONGLONG(0);
  clear_has_sd_avg_latency();
}
inline ::google::protobuf::uint64 stats_ip_probe_uplink::sd_avg_latency() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.sd_avg_latency)
  return sd_avg_latency_;
}
inline void stats_ip_probe_uplink::set_sd_avg_latency(::google::protobuf::uint64 value) {
  set_has_sd_avg_latency();
  sd_avg_latency_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.sd_avg_latency)
}

// optional uint64 ds_avg_latency = 16;
inline bool stats_ip_probe_uplink::has_ds_avg_latency() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void stats_ip_probe_uplink::set_has_ds_avg_latency() {
  _has_bits_[0] |= 0x00004000u;
}
inline void stats_ip_probe_uplink::clear_has_ds_avg_latency() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void stats_ip_probe_uplink::clear_ds_avg_latency() {
  ds_avg_latency_ = GOOGLE_ULONGLONG(0);
  clear_has_ds_avg_latency();
}
inline ::google::protobuf::uint64 stats_ip_probe_uplink::ds_avg_latency() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.ds_avg_latency)
  return ds_avg_latency_;
}
inline void stats_ip_probe_uplink::set_ds_avg_latency(::google::protobuf::uint64 value) {
  set_has_ds_avg_latency();
  ds_avg_latency_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.ds_avg_latency)
}

// optional uint64 sd_avg_jitter = 17;
inline bool stats_ip_probe_uplink::has_sd_avg_jitter() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void stats_ip_probe_uplink::set_has_sd_avg_jitter() {
  _has_bits_[0] |= 0x00008000u;
}
inline void stats_ip_probe_uplink::clear_has_sd_avg_jitter() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void stats_ip_probe_uplink::clear_sd_avg_jitter() {
  sd_avg_jitter_ = GOOGLE_ULONGLONG(0);
  clear_has_sd_avg_jitter();
}
inline ::google::protobuf::uint64 stats_ip_probe_uplink::sd_avg_jitter() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.sd_avg_jitter)
  return sd_avg_jitter_;
}
inline void stats_ip_probe_uplink::set_sd_avg_jitter(::google::protobuf::uint64 value) {
  set_has_sd_avg_jitter();
  sd_avg_jitter_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.sd_avg_jitter)
}

// optional uint64 ds_avg_jitter = 18;
inline bool stats_ip_probe_uplink::has_ds_avg_jitter() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void stats_ip_probe_uplink::set_has_ds_avg_jitter() {
  _has_bits_[0] |= 0x00010000u;
}
inline void stats_ip_probe_uplink::clear_has_ds_avg_jitter() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void stats_ip_probe_uplink::clear_ds_avg_jitter() {
  ds_avg_jitter_ = GOOGLE_ULONGLONG(0);
  clear_has_ds_avg_jitter();
}
inline ::google::protobuf::uint64 stats_ip_probe_uplink::ds_avg_jitter() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ip_probe_uplink.ds_avg_jitter)
  return ds_avg_jitter_;
}
inline void stats_ip_probe_uplink::set_ds_avg_jitter(::google::protobuf::uint64 value) {
  set_has_ds_avg_jitter();
  ds_avg_jitter_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ip_probe_uplink.ds_avg_jitter)
}

// -------------------------------------------------------------------

// stats_tunnel

// optional uint32 tunnel_index = 1;
inline bool stats_tunnel::has_tunnel_index() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void stats_tunnel::set_has_tunnel_index() {
  _has_bits_[0] |= 0x00000020u;
}
inline void stats_tunnel::clear_has_tunnel_index() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void stats_tunnel::clear_tunnel_index() {
  tunnel_index_ = 0u;
  clear_has_tunnel_index();
}
inline ::google::protobuf::uint32 stats_tunnel::tunnel_index() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_tunnel.tunnel_index)
  return tunnel_index_;
}
inline void stats_tunnel::set_tunnel_index(::google::protobuf::uint32 value) {
  set_has_tunnel_index();
  tunnel_index_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_tunnel.tunnel_index)
}

// optional uint64 tx_data_pkts = 2;
inline bool stats_tunnel::has_tx_data_pkts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stats_tunnel::set_has_tx_data_pkts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stats_tunnel::clear_has_tx_data_pkts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stats_tunnel::clear_tx_data_pkts() {
  tx_data_pkts_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_data_pkts();
}
inline ::google::protobuf::uint64 stats_tunnel::tx_data_pkts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_tunnel.tx_data_pkts)
  return tx_data_pkts_;
}
inline void stats_tunnel::set_tx_data_pkts(::google::protobuf::uint64 value) {
  set_has_tx_data_pkts();
  tx_data_pkts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_tunnel.tx_data_pkts)
}

// optional uint64 rx_data_pkts = 3;
inline bool stats_tunnel::has_rx_data_pkts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void stats_tunnel::set_has_rx_data_pkts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void stats_tunnel::clear_has_rx_data_pkts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void stats_tunnel::clear_rx_data_pkts() {
  rx_data_pkts_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_data_pkts();
}
inline ::google::protobuf::uint64 stats_tunnel::rx_data_pkts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_tunnel.rx_data_pkts)
  return rx_data_pkts_;
}
inline void stats_tunnel::set_rx_data_pkts(::google::protobuf::uint64 value) {
  set_has_rx_data_pkts();
  rx_data_pkts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_tunnel.rx_data_pkts)
}

// optional uint64 tx_data_bytes = 4;
inline bool stats_tunnel::has_tx_data_bytes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void stats_tunnel::set_has_tx_data_bytes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void stats_tunnel::clear_has_tx_data_bytes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void stats_tunnel::clear_tx_data_bytes() {
  tx_data_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_data_bytes();
}
inline ::google::protobuf::uint64 stats_tunnel::tx_data_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_tunnel.tx_data_bytes)
  return tx_data_bytes_;
}
inline void stats_tunnel::set_tx_data_bytes(::google::protobuf::uint64 value) {
  set_has_tx_data_bytes();
  tx_data_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_tunnel.tx_data_bytes)
}

// optional uint64 rx_data_bytes = 5;
inline bool stats_tunnel::has_rx_data_bytes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void stats_tunnel::set_has_rx_data_bytes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void stats_tunnel::clear_has_rx_data_bytes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void stats_tunnel::clear_rx_data_bytes() {
  rx_data_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_data_bytes();
}
inline ::google::protobuf::uint64 stats_tunnel::rx_data_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_tunnel.rx_data_bytes)
  return rx_data_bytes_;
}
inline void stats_tunnel::set_rx_data_bytes(::google::protobuf::uint64 value) {
  set_has_rx_data_bytes();
  rx_data_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_tunnel.rx_data_bytes)
}

// optional .ce.nbapi.mac_address iap_mac = 6;
inline bool stats_tunnel::has_iap_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stats_tunnel::set_has_iap_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stats_tunnel::clear_has_iap_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stats_tunnel::clear_iap_mac() {
  if (iap_mac_ != NULL) iap_mac_->Clear();
  clear_has_iap_mac();
}
inline const ::ce::nbapi::mac_address& stats_tunnel::_internal_iap_mac() const {
  return *iap_mac_;
}
inline const ::ce::nbapi::mac_address& stats_tunnel::iap_mac() const {
  const ::ce::nbapi::mac_address* p = iap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_tunnel.iap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_tunnel::release_iap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_tunnel.iap_mac)
  clear_has_iap_mac();
  ::ce::nbapi::mac_address* temp = iap_mac_;
  iap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_tunnel::mutable_iap_mac() {
  set_has_iap_mac();
  if (iap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    iap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_tunnel.iap_mac)
  return iap_mac_;
}
inline void stats_tunnel::set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete iap_mac_;
  }
  if (iap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      iap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, iap_mac, submessage_arena);
    }
    set_has_iap_mac();
  } else {
    clear_has_iap_mac();
  }
  iap_mac_ = iap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_tunnel.iap_mac)
}

// -------------------------------------------------------------------

// bytes_info

// optional uint64 tx_bytes = 1;
inline bool bytes_info::has_tx_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bytes_info::set_has_tx_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void bytes_info::clear_has_tx_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void bytes_info::clear_tx_bytes() {
  tx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_bytes();
}
inline ::google::protobuf::uint64 bytes_info::tx_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.bytes_info.tx_bytes)
  return tx_bytes_;
}
inline void bytes_info::set_tx_bytes(::google::protobuf::uint64 value) {
  set_has_tx_bytes();
  tx_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.bytes_info.tx_bytes)
}

// optional uint64 rx_bytes = 2;
inline bool bytes_info::has_rx_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void bytes_info::set_has_rx_bytes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void bytes_info::clear_has_rx_bytes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void bytes_info::clear_rx_bytes() {
  rx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_rx_bytes();
}
inline ::google::protobuf::uint64 bytes_info::rx_bytes() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.bytes_info.rx_bytes)
  return rx_bytes_;
}
inline void bytes_info::set_rx_bytes(::google::protobuf::uint64 value) {
  set_has_rx_bytes();
  rx_bytes_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.bytes_info.rx_bytes)
}

// -------------------------------------------------------------------

// iap_bytes_info

// optional .ce.nbapi.iap_enforcement_status session_flags = 1;
inline bool iap_bytes_info::has_session_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void iap_bytes_info::set_has_session_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void iap_bytes_info::clear_has_session_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void iap_bytes_info::clear_session_flags() {
  session_flags_ = 1;
  clear_has_session_flags();
}
inline ::ce::nbapi::iap_enforcement_status iap_bytes_info::session_flags() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.iap_bytes_info.session_flags)
  return static_cast< ::ce::nbapi::iap_enforcement_status >(session_flags_);
}
inline void iap_bytes_info::set_session_flags(::ce::nbapi::iap_enforcement_status value) {
  assert(::ce::nbapi::iap_enforcement_status_IsValid(value));
  set_has_session_flags();
  session_flags_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.iap_bytes_info.session_flags)
}

// optional .ce.nbapi.bytes_info bytes_info = 2;
inline bool iap_bytes_info::has_bytes_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void iap_bytes_info::set_has_bytes_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void iap_bytes_info::clear_has_bytes_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void iap_bytes_info::clear_bytes_info() {
  if (bytes_info_ != NULL) bytes_info_->Clear();
  clear_has_bytes_info();
}
inline const ::ce::nbapi::bytes_info& iap_bytes_info::_internal_bytes_info() const {
  return *bytes_info_;
}
inline const ::ce::nbapi::bytes_info& iap_bytes_info::bytes_info() const {
  const ::ce::nbapi::bytes_info* p = bytes_info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.iap_bytes_info.bytes_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::bytes_info*>(
      &::ce::nbapi::_bytes_info_default_instance_);
}
inline ::ce::nbapi::bytes_info* iap_bytes_info::release_bytes_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.iap_bytes_info.bytes_info)
  clear_has_bytes_info();
  ::ce::nbapi::bytes_info* temp = bytes_info_;
  bytes_info_ = NULL;
  return temp;
}
inline ::ce::nbapi::bytes_info* iap_bytes_info::mutable_bytes_info() {
  set_has_bytes_info();
  if (bytes_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::bytes_info>(GetArenaNoVirtual());
    bytes_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.iap_bytes_info.bytes_info)
  return bytes_info_;
}
inline void iap_bytes_info::set_allocated_bytes_info(::ce::nbapi::bytes_info* bytes_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bytes_info_;
  }
  if (bytes_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bytes_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bytes_info, submessage_arena);
    }
    set_has_bytes_info();
  } else {
    clear_has_bytes_info();
  }
  bytes_info_ = bytes_info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.iap_bytes_info.bytes_info)
}

// -------------------------------------------------------------------

// stats_role_iap

// optional .ce.nbapi.mac_address iap_mac = 1;
inline bool stats_role_iap::has_iap_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stats_role_iap::set_has_iap_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stats_role_iap::clear_has_iap_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stats_role_iap::clear_iap_mac() {
  if (iap_mac_ != NULL) iap_mac_->Clear();
  clear_has_iap_mac();
}
inline const ::ce::nbapi::mac_address& stats_role_iap::_internal_iap_mac() const {
  return *iap_mac_;
}
inline const ::ce::nbapi::mac_address& stats_role_iap::iap_mac() const {
  const ::ce::nbapi::mac_address* p = iap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_role_iap.iap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_role_iap::release_iap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_role_iap.iap_mac)
  clear_has_iap_mac();
  ::ce::nbapi::mac_address* temp = iap_mac_;
  iap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_role_iap::mutable_iap_mac() {
  set_has_iap_mac();
  if (iap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    iap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_role_iap.iap_mac)
  return iap_mac_;
}
inline void stats_role_iap::set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete iap_mac_;
  }
  if (iap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      iap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, iap_mac, submessage_arena);
    }
    set_has_iap_mac();
  } else {
    clear_has_iap_mac();
  }
  iap_mac_ = iap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_role_iap.iap_mac)
}

// optional bytes user_role = 2;
inline bool stats_role_iap::has_user_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stats_role_iap::set_has_user_role() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stats_role_iap::clear_has_user_role() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stats_role_iap::clear_user_role() {
  user_role_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_role();
}
inline const ::std::string& stats_role_iap::user_role() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_role_iap.user_role)
  return user_role_.GetNoArena();
}
inline void stats_role_iap::set_user_role(const ::std::string& value) {
  set_has_user_role();
  user_role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_role_iap.user_role)
}
#if LANG_CXX11
inline void stats_role_iap::set_user_role(::std::string&& value) {
  set_has_user_role();
  user_role_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.stats_role_iap.user_role)
}
#endif
inline void stats_role_iap::set_user_role(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_role();
  user_role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.stats_role_iap.user_role)
}
inline void stats_role_iap::set_user_role(const void* value, size_t size) {
  set_has_user_role();
  user_role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.stats_role_iap.user_role)
}
inline ::std::string* stats_role_iap::mutable_user_role() {
  set_has_user_role();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_role_iap.user_role)
  return user_role_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* stats_role_iap::release_user_role() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_role_iap.user_role)
  if (!has_user_role()) {
    return NULL;
  }
  clear_has_user_role();
  return user_role_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void stats_role_iap::set_allocated_user_role(::std::string* user_role) {
  if (user_role != NULL) {
    set_has_user_role();
  } else {
    clear_has_user_role();
  }
  user_role_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_role);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_role_iap.user_role)
}

// optional .ce.nbapi.bytes_info bytes_info = 3;
inline bool stats_role_iap::has_bytes_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void stats_role_iap::set_has_bytes_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void stats_role_iap::clear_has_bytes_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void stats_role_iap::clear_bytes_info() {
  if (bytes_info_ != NULL) bytes_info_->Clear();
  clear_has_bytes_info();
}
inline const ::ce::nbapi::bytes_info& stats_role_iap::_internal_bytes_info() const {
  return *bytes_info_;
}
inline const ::ce::nbapi::bytes_info& stats_role_iap::bytes_info() const {
  const ::ce::nbapi::bytes_info* p = bytes_info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_role_iap.bytes_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::bytes_info*>(
      &::ce::nbapi::_bytes_info_default_instance_);
}
inline ::ce::nbapi::bytes_info* stats_role_iap::release_bytes_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_role_iap.bytes_info)
  clear_has_bytes_info();
  ::ce::nbapi::bytes_info* temp = bytes_info_;
  bytes_info_ = NULL;
  return temp;
}
inline ::ce::nbapi::bytes_info* stats_role_iap::mutable_bytes_info() {
  set_has_bytes_info();
  if (bytes_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::bytes_info>(GetArenaNoVirtual());
    bytes_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_role_iap.bytes_info)
  return bytes_info_;
}
inline void stats_role_iap::set_allocated_bytes_info(::ce::nbapi::bytes_info* bytes_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bytes_info_;
  }
  if (bytes_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bytes_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bytes_info, submessage_arena);
    }
    set_has_bytes_info();
  } else {
    clear_has_bytes_info();
  }
  bytes_info_ = bytes_info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_role_iap.bytes_info)
}

// -------------------------------------------------------------------

// stats_vlan_iap

// optional .ce.nbapi.mac_address iap_mac = 1;
inline bool stats_vlan_iap::has_iap_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stats_vlan_iap::set_has_iap_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stats_vlan_iap::clear_has_iap_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stats_vlan_iap::clear_iap_mac() {
  if (iap_mac_ != NULL) iap_mac_->Clear();
  clear_has_iap_mac();
}
inline const ::ce::nbapi::mac_address& stats_vlan_iap::_internal_iap_mac() const {
  return *iap_mac_;
}
inline const ::ce::nbapi::mac_address& stats_vlan_iap::iap_mac() const {
  const ::ce::nbapi::mac_address* p = iap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vlan_iap.iap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_vlan_iap::release_iap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_vlan_iap.iap_mac)
  clear_has_iap_mac();
  ::ce::nbapi::mac_address* temp = iap_mac_;
  iap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_vlan_iap::mutable_iap_mac() {
  set_has_iap_mac();
  if (iap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    iap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_vlan_iap.iap_mac)
  return iap_mac_;
}
inline void stats_vlan_iap::set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete iap_mac_;
  }
  if (iap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      iap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, iap_mac, submessage_arena);
    }
    set_has_iap_mac();
  } else {
    clear_has_iap_mac();
  }
  iap_mac_ = iap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_vlan_iap.iap_mac)
}

// optional uint32 vlan = 2;
inline bool stats_vlan_iap::has_vlan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void stats_vlan_iap::set_has_vlan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void stats_vlan_iap::clear_has_vlan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void stats_vlan_iap::clear_vlan() {
  vlan_ = 0u;
  clear_has_vlan();
}
inline ::google::protobuf::uint32 stats_vlan_iap::vlan() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vlan_iap.vlan)
  return vlan_;
}
inline void stats_vlan_iap::set_vlan(::google::protobuf::uint32 value) {
  set_has_vlan();
  vlan_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_vlan_iap.vlan)
}

// optional .ce.nbapi.bytes_info bytes_info = 3;
inline bool stats_vlan_iap::has_bytes_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stats_vlan_iap::set_has_bytes_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stats_vlan_iap::clear_has_bytes_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stats_vlan_iap::clear_bytes_info() {
  if (bytes_info_ != NULL) bytes_info_->Clear();
  clear_has_bytes_info();
}
inline const ::ce::nbapi::bytes_info& stats_vlan_iap::_internal_bytes_info() const {
  return *bytes_info_;
}
inline const ::ce::nbapi::bytes_info& stats_vlan_iap::bytes_info() const {
  const ::ce::nbapi::bytes_info* p = bytes_info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_vlan_iap.bytes_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::bytes_info*>(
      &::ce::nbapi::_bytes_info_default_instance_);
}
inline ::ce::nbapi::bytes_info* stats_vlan_iap::release_bytes_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_vlan_iap.bytes_info)
  clear_has_bytes_info();
  ::ce::nbapi::bytes_info* temp = bytes_info_;
  bytes_info_ = NULL;
  return temp;
}
inline ::ce::nbapi::bytes_info* stats_vlan_iap::mutable_bytes_info() {
  set_has_bytes_info();
  if (bytes_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::bytes_info>(GetArenaNoVirtual());
    bytes_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_vlan_iap.bytes_info)
  return bytes_info_;
}
inline void stats_vlan_iap::set_allocated_bytes_info(::ce::nbapi::bytes_info* bytes_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bytes_info_;
  }
  if (bytes_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bytes_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bytes_info, submessage_arena);
    }
    set_has_bytes_info();
  } else {
    clear_has_bytes_info();
  }
  bytes_info_ = bytes_info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_vlan_iap.bytes_info)
}

// -------------------------------------------------------------------

// stats_ssid_iap

// optional .ce.nbapi.mac_address iap_mac = 1;
inline bool stats_ssid_iap::has_iap_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stats_ssid_iap::set_has_iap_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stats_ssid_iap::clear_has_iap_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stats_ssid_iap::clear_iap_mac() {
  if (iap_mac_ != NULL) iap_mac_->Clear();
  clear_has_iap_mac();
}
inline const ::ce::nbapi::mac_address& stats_ssid_iap::_internal_iap_mac() const {
  return *iap_mac_;
}
inline const ::ce::nbapi::mac_address& stats_ssid_iap::iap_mac() const {
  const ::ce::nbapi::mac_address* p = iap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ssid_iap.iap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_ssid_iap::release_iap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_ssid_iap.iap_mac)
  clear_has_iap_mac();
  ::ce::nbapi::mac_address* temp = iap_mac_;
  iap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_ssid_iap::mutable_iap_mac() {
  set_has_iap_mac();
  if (iap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    iap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_ssid_iap.iap_mac)
  return iap_mac_;
}
inline void stats_ssid_iap::set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete iap_mac_;
  }
  if (iap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      iap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, iap_mac, submessage_arena);
    }
    set_has_iap_mac();
  } else {
    clear_has_iap_mac();
  }
  iap_mac_ = iap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_ssid_iap.iap_mac)
}

// optional bytes essid = 2;
inline bool stats_ssid_iap::has_essid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stats_ssid_iap::set_has_essid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stats_ssid_iap::clear_has_essid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stats_ssid_iap::clear_essid() {
  essid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_essid();
}
inline const ::std::string& stats_ssid_iap::essid() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ssid_iap.essid)
  return essid_.GetNoArena();
}
inline void stats_ssid_iap::set_essid(const ::std::string& value) {
  set_has_essid();
  essid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.stats_ssid_iap.essid)
}
#if LANG_CXX11
inline void stats_ssid_iap::set_essid(::std::string&& value) {
  set_has_essid();
  essid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.stats_ssid_iap.essid)
}
#endif
inline void stats_ssid_iap::set_essid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_essid();
  essid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.stats_ssid_iap.essid)
}
inline void stats_ssid_iap::set_essid(const void* value, size_t size) {
  set_has_essid();
  essid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.stats_ssid_iap.essid)
}
inline ::std::string* stats_ssid_iap::mutable_essid() {
  set_has_essid();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_ssid_iap.essid)
  return essid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* stats_ssid_iap::release_essid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_ssid_iap.essid)
  if (!has_essid()) {
    return NULL;
  }
  clear_has_essid();
  return essid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void stats_ssid_iap::set_allocated_essid(::std::string* essid) {
  if (essid != NULL) {
    set_has_essid();
  } else {
    clear_has_essid();
  }
  essid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), essid);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_ssid_iap.essid)
}

// optional .ce.nbapi.bytes_info bytes_info = 3;
inline bool stats_ssid_iap::has_bytes_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void stats_ssid_iap::set_has_bytes_info() {
  _has_bits_[0] |= 0x00000004u;
}
inline void stats_ssid_iap::clear_has_bytes_info() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void stats_ssid_iap::clear_bytes_info() {
  if (bytes_info_ != NULL) bytes_info_->Clear();
  clear_has_bytes_info();
}
inline const ::ce::nbapi::bytes_info& stats_ssid_iap::_internal_bytes_info() const {
  return *bytes_info_;
}
inline const ::ce::nbapi::bytes_info& stats_ssid_iap::bytes_info() const {
  const ::ce::nbapi::bytes_info* p = bytes_info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_ssid_iap.bytes_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::bytes_info*>(
      &::ce::nbapi::_bytes_info_default_instance_);
}
inline ::ce::nbapi::bytes_info* stats_ssid_iap::release_bytes_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_ssid_iap.bytes_info)
  clear_has_bytes_info();
  ::ce::nbapi::bytes_info* temp = bytes_info_;
  bytes_info_ = NULL;
  return temp;
}
inline ::ce::nbapi::bytes_info* stats_ssid_iap::mutable_bytes_info() {
  set_has_bytes_info();
  if (bytes_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::bytes_info>(GetArenaNoVirtual());
    bytes_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_ssid_iap.bytes_info)
  return bytes_info_;
}
inline void stats_ssid_iap::set_allocated_bytes_info(::ce::nbapi::bytes_info* bytes_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bytes_info_;
  }
  if (bytes_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bytes_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bytes_info, submessage_arena);
    }
    set_has_bytes_info();
  } else {
    clear_has_bytes_info();
  }
  bytes_info_ = bytes_info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_ssid_iap.bytes_info)
}

// -------------------------------------------------------------------

// stats_port

// optional .ce.nbapi.mac_address port_mac = 1;
inline bool stats_port::has_port_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stats_port::set_has_port_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stats_port::clear_has_port_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stats_port::clear_port_mac() {
  if (port_mac_ != NULL) port_mac_->Clear();
  clear_has_port_mac();
}
inline const ::ce::nbapi::mac_address& stats_port::_internal_port_mac() const {
  return *port_mac_;
}
inline const ::ce::nbapi::mac_address& stats_port::port_mac() const {
  const ::ce::nbapi::mac_address* p = port_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_port.port_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* stats_port::release_port_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_port.port_mac)
  clear_has_port_mac();
  ::ce::nbapi::mac_address* temp = port_mac_;
  port_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* stats_port::mutable_port_mac() {
  set_has_port_mac();
  if (port_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    port_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_port.port_mac)
  return port_mac_;
}
inline void stats_port::set_allocated_port_mac(::ce::nbapi::mac_address* port_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete port_mac_;
  }
  if (port_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      port_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, port_mac, submessage_arena);
    }
    set_has_port_mac();
  } else {
    clear_has_port_mac();
  }
  port_mac_ = port_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_port.port_mac)
}

// optional .ce.nbapi.bytes_info bytes_info = 2;
inline bool stats_port::has_bytes_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void stats_port::set_has_bytes_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void stats_port::clear_has_bytes_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void stats_port::clear_bytes_info() {
  if (bytes_info_ != NULL) bytes_info_->Clear();
  clear_has_bytes_info();
}
inline const ::ce::nbapi::bytes_info& stats_port::_internal_bytes_info() const {
  return *bytes_info_;
}
inline const ::ce::nbapi::bytes_info& stats_port::bytes_info() const {
  const ::ce::nbapi::bytes_info* p = bytes_info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.stats_port.bytes_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::bytes_info*>(
      &::ce::nbapi::_bytes_info_default_instance_);
}
inline ::ce::nbapi::bytes_info* stats_port::release_bytes_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.stats_port.bytes_info)
  clear_has_bytes_info();
  ::ce::nbapi::bytes_info* temp = bytes_info_;
  bytes_info_ = NULL;
  return temp;
}
inline ::ce::nbapi::bytes_info* stats_port::mutable_bytes_info() {
  set_has_bytes_info();
  if (bytes_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::bytes_info>(GetArenaNoVirtual());
    bytes_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.stats_port.bytes_info)
  return bytes_info_;
}
inline void stats_port::set_allocated_bytes_info(::ce::nbapi::bytes_info* bytes_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bytes_info_;
  }
  if (bytes_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bytes_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bytes_info, submessage_arena);
    }
    set_has_bytes_info();
  } else {
    clear_has_bytes_info();
  }
  bytes_info_ = bytes_info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.stats_port.bytes_info)
}

// -------------------------------------------------------------------

// summary_webcat_iap

// optional .ce.nbapi.mac_address iap_mac = 1;
inline bool summary_webcat_iap::has_iap_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void summary_webcat_iap::set_has_iap_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void summary_webcat_iap::clear_has_iap_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void summary_webcat_iap::clear_iap_mac() {
  if (iap_mac_ != NULL) iap_mac_->Clear();
  clear_has_iap_mac();
}
inline const ::ce::nbapi::mac_address& summary_webcat_iap::_internal_iap_mac() const {
  return *iap_mac_;
}
inline const ::ce::nbapi::mac_address& summary_webcat_iap::iap_mac() const {
  const ::ce::nbapi::mac_address* p = iap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.summary_webcat_iap.iap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* summary_webcat_iap::release_iap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.summary_webcat_iap.iap_mac)
  clear_has_iap_mac();
  ::ce::nbapi::mac_address* temp = iap_mac_;
  iap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* summary_webcat_iap::mutable_iap_mac() {
  set_has_iap_mac();
  if (iap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    iap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.summary_webcat_iap.iap_mac)
  return iap_mac_;
}
inline void summary_webcat_iap::set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete iap_mac_;
  }
  if (iap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      iap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, iap_mac, submessage_arena);
    }
    set_has_iap_mac();
  } else {
    clear_has_iap_mac();
  }
  iap_mac_ = iap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.summary_webcat_iap.iap_mac)
}

// optional uint32 webcat_id = 2;
inline bool summary_webcat_iap::has_webcat_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void summary_webcat_iap::set_has_webcat_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void summary_webcat_iap::clear_has_webcat_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void summary_webcat_iap::clear_webcat_id() {
  webcat_id_ = 0u;
  clear_has_webcat_id();
}
inline ::google::protobuf::uint32 summary_webcat_iap::webcat_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.summary_webcat_iap.webcat_id)
  return webcat_id_;
}
inline void summary_webcat_iap::set_webcat_id(::google::protobuf::uint32 value) {
  set_has_webcat_id();
  webcat_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.summary_webcat_iap.webcat_id)
}

// optional .ce.nbapi.iap_bytes_info bytes_info = 3;
inline bool summary_webcat_iap::has_bytes_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void summary_webcat_iap::set_has_bytes_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void summary_webcat_iap::clear_has_bytes_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void summary_webcat_iap::clear_bytes_info() {
  if (bytes_info_ != NULL) bytes_info_->Clear();
  clear_has_bytes_info();
}
inline const ::ce::nbapi::iap_bytes_info& summary_webcat_iap::_internal_bytes_info() const {
  return *bytes_info_;
}
inline const ::ce::nbapi::iap_bytes_info& summary_webcat_iap::bytes_info() const {
  const ::ce::nbapi::iap_bytes_info* p = bytes_info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.summary_webcat_iap.bytes_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::iap_bytes_info*>(
      &::ce::nbapi::_iap_bytes_info_default_instance_);
}
inline ::ce::nbapi::iap_bytes_info* summary_webcat_iap::release_bytes_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.summary_webcat_iap.bytes_info)
  clear_has_bytes_info();
  ::ce::nbapi::iap_bytes_info* temp = bytes_info_;
  bytes_info_ = NULL;
  return temp;
}
inline ::ce::nbapi::iap_bytes_info* summary_webcat_iap::mutable_bytes_info() {
  set_has_bytes_info();
  if (bytes_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::iap_bytes_info>(GetArenaNoVirtual());
    bytes_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.summary_webcat_iap.bytes_info)
  return bytes_info_;
}
inline void summary_webcat_iap::set_allocated_bytes_info(::ce::nbapi::iap_bytes_info* bytes_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bytes_info_;
  }
  if (bytes_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bytes_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bytes_info, submessage_arena);
    }
    set_has_bytes_info();
  } else {
    clear_has_bytes_info();
  }
  bytes_info_ = bytes_info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.summary_webcat_iap.bytes_info)
}

// -------------------------------------------------------------------

// summary_appid_iap

// optional .ce.nbapi.mac_address iap_mac = 1;
inline bool summary_appid_iap::has_iap_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void summary_appid_iap::set_has_iap_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void summary_appid_iap::clear_has_iap_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void summary_appid_iap::clear_iap_mac() {
  if (iap_mac_ != NULL) iap_mac_->Clear();
  clear_has_iap_mac();
}
inline const ::ce::nbapi::mac_address& summary_appid_iap::_internal_iap_mac() const {
  return *iap_mac_;
}
inline const ::ce::nbapi::mac_address& summary_appid_iap::iap_mac() const {
  const ::ce::nbapi::mac_address* p = iap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.summary_appid_iap.iap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* summary_appid_iap::release_iap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.summary_appid_iap.iap_mac)
  clear_has_iap_mac();
  ::ce::nbapi::mac_address* temp = iap_mac_;
  iap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* summary_appid_iap::mutable_iap_mac() {
  set_has_iap_mac();
  if (iap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    iap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.summary_appid_iap.iap_mac)
  return iap_mac_;
}
inline void summary_appid_iap::set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete iap_mac_;
  }
  if (iap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      iap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, iap_mac, submessage_arena);
    }
    set_has_iap_mac();
  } else {
    clear_has_iap_mac();
  }
  iap_mac_ = iap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.summary_appid_iap.iap_mac)
}

// optional uint32 app_id = 2;
inline bool summary_appid_iap::has_app_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void summary_appid_iap::set_has_app_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void summary_appid_iap::clear_has_app_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void summary_appid_iap::clear_app_id() {
  app_id_ = 0u;
  clear_has_app_id();
}
inline ::google::protobuf::uint32 summary_appid_iap::app_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.summary_appid_iap.app_id)
  return app_id_;
}
inline void summary_appid_iap::set_app_id(::google::protobuf::uint32 value) {
  set_has_app_id();
  app_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.summary_appid_iap.app_id)
}

// optional .ce.nbapi.iap_bytes_info bytes_info = 3;
inline bool summary_appid_iap::has_bytes_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void summary_appid_iap::set_has_bytes_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void summary_appid_iap::clear_has_bytes_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void summary_appid_iap::clear_bytes_info() {
  if (bytes_info_ != NULL) bytes_info_->Clear();
  clear_has_bytes_info();
}
inline const ::ce::nbapi::iap_bytes_info& summary_appid_iap::_internal_bytes_info() const {
  return *bytes_info_;
}
inline const ::ce::nbapi::iap_bytes_info& summary_appid_iap::bytes_info() const {
  const ::ce::nbapi::iap_bytes_info* p = bytes_info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.summary_appid_iap.bytes_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::iap_bytes_info*>(
      &::ce::nbapi::_iap_bytes_info_default_instance_);
}
inline ::ce::nbapi::iap_bytes_info* summary_appid_iap::release_bytes_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.summary_appid_iap.bytes_info)
  clear_has_bytes_info();
  ::ce::nbapi::iap_bytes_info* temp = bytes_info_;
  bytes_info_ = NULL;
  return temp;
}
inline ::ce::nbapi::iap_bytes_info* summary_appid_iap::mutable_bytes_info() {
  set_has_bytes_info();
  if (bytes_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::iap_bytes_info>(GetArenaNoVirtual());
    bytes_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.summary_appid_iap.bytes_info)
  return bytes_info_;
}
inline void summary_appid_iap::set_allocated_bytes_info(::ce::nbapi::iap_bytes_info* bytes_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bytes_info_;
  }
  if (bytes_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bytes_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bytes_info, submessage_arena);
    }
    set_has_bytes_info();
  } else {
    clear_has_bytes_info();
  }
  bytes_info_ = bytes_info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.summary_appid_iap.bytes_info)
}

// -------------------------------------------------------------------

// summary_webrep_iap

// optional .ce.nbapi.mac_address iap_mac = 1;
inline bool summary_webrep_iap::has_iap_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void summary_webrep_iap::set_has_iap_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void summary_webrep_iap::clear_has_iap_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void summary_webrep_iap::clear_iap_mac() {
  if (iap_mac_ != NULL) iap_mac_->Clear();
  clear_has_iap_mac();
}
inline const ::ce::nbapi::mac_address& summary_webrep_iap::_internal_iap_mac() const {
  return *iap_mac_;
}
inline const ::ce::nbapi::mac_address& summary_webrep_iap::iap_mac() const {
  const ::ce::nbapi::mac_address* p = iap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.summary_webrep_iap.iap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* summary_webrep_iap::release_iap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.summary_webrep_iap.iap_mac)
  clear_has_iap_mac();
  ::ce::nbapi::mac_address* temp = iap_mac_;
  iap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* summary_webrep_iap::mutable_iap_mac() {
  set_has_iap_mac();
  if (iap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    iap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.summary_webrep_iap.iap_mac)
  return iap_mac_;
}
inline void summary_webrep_iap::set_allocated_iap_mac(::ce::nbapi::mac_address* iap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete iap_mac_;
  }
  if (iap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      iap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, iap_mac, submessage_arena);
    }
    set_has_iap_mac();
  } else {
    clear_has_iap_mac();
  }
  iap_mac_ = iap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.summary_webrep_iap.iap_mac)
}

// optional uint32 webrep_id = 2;
inline bool summary_webrep_iap::has_webrep_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void summary_webrep_iap::set_has_webrep_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void summary_webrep_iap::clear_has_webrep_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void summary_webrep_iap::clear_webrep_id() {
  webrep_id_ = 0u;
  clear_has_webrep_id();
}
inline ::google::protobuf::uint32 summary_webrep_iap::webrep_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.summary_webrep_iap.webrep_id)
  return webrep_id_;
}
inline void summary_webrep_iap::set_webrep_id(::google::protobuf::uint32 value) {
  set_has_webrep_id();
  webrep_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.summary_webrep_iap.webrep_id)
}

// optional .ce.nbapi.iap_bytes_info bytes_info = 3;
inline bool summary_webrep_iap::has_bytes_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void summary_webrep_iap::set_has_bytes_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void summary_webrep_iap::clear_has_bytes_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void summary_webrep_iap::clear_bytes_info() {
  if (bytes_info_ != NULL) bytes_info_->Clear();
  clear_has_bytes_info();
}
inline const ::ce::nbapi::iap_bytes_info& summary_webrep_iap::_internal_bytes_info() const {
  return *bytes_info_;
}
inline const ::ce::nbapi::iap_bytes_info& summary_webrep_iap::bytes_info() const {
  const ::ce::nbapi::iap_bytes_info* p = bytes_info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.summary_webrep_iap.bytes_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::iap_bytes_info*>(
      &::ce::nbapi::_iap_bytes_info_default_instance_);
}
inline ::ce::nbapi::iap_bytes_info* summary_webrep_iap::release_bytes_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.summary_webrep_iap.bytes_info)
  clear_has_bytes_info();
  ::ce::nbapi::iap_bytes_info* temp = bytes_info_;
  bytes_info_ = NULL;
  return temp;
}
inline ::ce::nbapi::iap_bytes_info* summary_webrep_iap::mutable_bytes_info() {
  set_has_bytes_info();
  if (bytes_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::iap_bytes_info>(GetArenaNoVirtual());
    bytes_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.summary_webrep_iap.bytes_info)
  return bytes_info_;
}
inline void summary_webrep_iap::set_allocated_bytes_info(::ce::nbapi::iap_bytes_info* bytes_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bytes_info_;
  }
  if (bytes_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bytes_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bytes_info, submessage_arena);
    }
    set_has_bytes_info();
  } else {
    clear_has_bytes_info();
  }
  bytes_info_ = bytes_info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.summary_webrep_iap.bytes_info)
}

// -------------------------------------------------------------------

// ap_neighbor_list

// repeated .ce.nbapi.ap_neighbor neighbor = 1;
inline int ap_neighbor_list::neighbor_size() const {
  return neighbor_.size();
}
inline void ap_neighbor_list::clear_neighbor() {
  neighbor_.Clear();
}
inline ::ce::nbapi::ap_neighbor* ap_neighbor_list::mutable_neighbor(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ap_neighbor_list.neighbor)
  return neighbor_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::ap_neighbor >*
ap_neighbor_list::mutable_neighbor() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.ap_neighbor_list.neighbor)
  return &neighbor_;
}
inline const ::ce::nbapi::ap_neighbor& ap_neighbor_list::neighbor(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_neighbor_list.neighbor)
  return neighbor_.Get(index);
}
inline ::ce::nbapi::ap_neighbor* ap_neighbor_list::add_neighbor() {
  // @@protoc_insertion_point(field_add:ce.nbapi.ap_neighbor_list.neighbor)
  return neighbor_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::ap_neighbor >&
ap_neighbor_list::neighbor() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.ap_neighbor_list.neighbor)
  return neighbor_;
}

// -------------------------------------------------------------------

// utilization_stats_radio

// optional .ce.nbapi.mac_address ap_eth_mac = 1;
inline bool utilization_stats_radio::has_ap_eth_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void utilization_stats_radio::set_has_ap_eth_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void utilization_stats_radio::clear_has_ap_eth_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void utilization_stats_radio::clear_ap_eth_mac() {
  if (ap_eth_mac_ != NULL) ap_eth_mac_->Clear();
  clear_has_ap_eth_mac();
}
inline const ::ce::nbapi::mac_address& utilization_stats_radio::_internal_ap_eth_mac() const {
  return *ap_eth_mac_;
}
inline const ::ce::nbapi::mac_address& utilization_stats_radio::ap_eth_mac() const {
  const ::ce::nbapi::mac_address* p = ap_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.utilization_stats_radio.ap_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* utilization_stats_radio::release_ap_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.utilization_stats_radio.ap_eth_mac)
  clear_has_ap_eth_mac();
  ::ce::nbapi::mac_address* temp = ap_eth_mac_;
  ap_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* utilization_stats_radio::mutable_ap_eth_mac() {
  set_has_ap_eth_mac();
  if (ap_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.utilization_stats_radio.ap_eth_mac)
  return ap_eth_mac_;
}
inline void utilization_stats_radio::set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_eth_mac_;
  }
  if (ap_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_eth_mac, submessage_arena);
    }
    set_has_ap_eth_mac();
  } else {
    clear_has_ap_eth_mac();
  }
  ap_eth_mac_ = ap_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.utilization_stats_radio.ap_eth_mac)
}

// optional uint32 radio_number = 2;
inline bool utilization_stats_radio::has_radio_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void utilization_stats_radio::set_has_radio_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void utilization_stats_radio::clear_has_radio_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void utilization_stats_radio::clear_radio_number() {
  radio_number_ = 0u;
  clear_has_radio_number();
}
inline ::google::protobuf::uint32 utilization_stats_radio::radio_number() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.utilization_stats_radio.radio_number)
  return radio_number_;
}
inline void utilization_stats_radio::set_radio_number(::google::protobuf::uint32 value) {
  set_has_radio_number();
  radio_number_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.utilization_stats_radio.radio_number)
}

// repeated .ce.nbapi.util_stats ustats = 3;
inline int utilization_stats_radio::ustats_size() const {
  return ustats_.size();
}
inline void utilization_stats_radio::clear_ustats() {
  ustats_.Clear();
}
inline ::ce::nbapi::util_stats* utilization_stats_radio::mutable_ustats(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.utilization_stats_radio.ustats)
  return ustats_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::util_stats >*
utilization_stats_radio::mutable_ustats() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.utilization_stats_radio.ustats)
  return &ustats_;
}
inline const ::ce::nbapi::util_stats& utilization_stats_radio::ustats(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.utilization_stats_radio.ustats)
  return ustats_.Get(index);
}
inline ::ce::nbapi::util_stats* utilization_stats_radio::add_ustats() {
  // @@protoc_insertion_point(field_add:ce.nbapi.utilization_stats_radio.ustats)
  return ustats_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::util_stats >&
utilization_stats_radio::ustats() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.utilization_stats_radio.ustats)
  return ustats_;
}

// -------------------------------------------------------------------

// proximity

// optional .ce.nbapi.mac_address sta_eth_mac = 1;
inline bool proximity::has_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void proximity::set_has_sta_eth_mac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void proximity::clear_has_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void proximity::clear_sta_eth_mac() {
  if (sta_eth_mac_ != NULL) sta_eth_mac_->Clear();
  clear_has_sta_eth_mac();
}
inline const ::ce::nbapi::mac_address& proximity::_internal_sta_eth_mac() const {
  return *sta_eth_mac_;
}
inline const ::ce::nbapi::mac_address& proximity::sta_eth_mac() const {
  const ::ce::nbapi::mac_address* p = sta_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.proximity.sta_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* proximity::release_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.proximity.sta_eth_mac)
  clear_has_sta_eth_mac();
  ::ce::nbapi::mac_address* temp = sta_eth_mac_;
  sta_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* proximity::mutable_sta_eth_mac() {
  set_has_sta_eth_mac();
  if (sta_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    sta_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.proximity.sta_eth_mac)
  return sta_eth_mac_;
}
inline void proximity::set_allocated_sta_eth_mac(::ce::nbapi::mac_address* sta_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sta_eth_mac_;
  }
  if (sta_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sta_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sta_eth_mac, submessage_arena);
    }
    set_has_sta_eth_mac();
  } else {
    clear_has_sta_eth_mac();
  }
  sta_eth_mac_ = sta_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.proximity.sta_eth_mac)
}

// optional .ce.nbapi.mac_address radio_mac = 2;
inline bool proximity::has_radio_mac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void proximity::set_has_radio_mac() {
  _has_bits_[0] |= 0x00000008u;
}
inline void proximity::clear_has_radio_mac() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void proximity::clear_radio_mac() {
  if (radio_mac_ != NULL) radio_mac_->Clear();
  clear_has_radio_mac();
}
inline const ::ce::nbapi::mac_address& proximity::_internal_radio_mac() const {
  return *radio_mac_;
}
inline const ::ce::nbapi::mac_address& proximity::radio_mac() const {
  const ::ce::nbapi::mac_address* p = radio_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.proximity.radio_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* proximity::release_radio_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.proximity.radio_mac)
  clear_has_radio_mac();
  ::ce::nbapi::mac_address* temp = radio_mac_;
  radio_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* proximity::mutable_radio_mac() {
  set_has_radio_mac();
  if (radio_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    radio_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.proximity.radio_mac)
  return radio_mac_;
}
inline void proximity::set_allocated_radio_mac(::ce::nbapi::mac_address* radio_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radio_mac_;
  }
  if (radio_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radio_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radio_mac, submessage_arena);
    }
    set_has_radio_mac();
  } else {
    clear_has_radio_mac();
  }
  radio_mac_ = radio_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.proximity.radio_mac)
}

// optional int32 rssi_val = 3;
inline bool proximity::has_rssi_val() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void proximity::set_has_rssi_val() {
  _has_bits_[0] |= 0x00000010u;
}
inline void proximity::clear_has_rssi_val() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void proximity::clear_rssi_val() {
  rssi_val_ = 0;
  clear_has_rssi_val();
}
inline ::google::protobuf::int32 proximity::rssi_val() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.proximity.rssi_val)
  return rssi_val_;
}
inline void proximity::set_rssi_val(::google::protobuf::int32 value) {
  set_has_rssi_val();
  rssi_val_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.proximity.rssi_val)
}

// optional string ap_name = 4;
inline bool proximity::has_ap_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void proximity::set_has_ap_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void proximity::clear_has_ap_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void proximity::clear_ap_name() {
  ap_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ap_name();
}
inline const ::std::string& proximity::ap_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.proximity.ap_name)
  return ap_name_.GetNoArena();
}
inline void proximity::set_ap_name(const ::std::string& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.proximity.ap_name)
}
#if LANG_CXX11
inline void proximity::set_ap_name(::std::string&& value) {
  set_has_ap_name();
  ap_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.proximity.ap_name)
}
#endif
inline void proximity::set_ap_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.proximity.ap_name)
}
inline void proximity::set_ap_name(const char* value, size_t size) {
  set_has_ap_name();
  ap_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.proximity.ap_name)
}
inline ::std::string* proximity::mutable_ap_name() {
  set_has_ap_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.proximity.ap_name)
  return ap_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* proximity::release_ap_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.proximity.ap_name)
  if (!has_ap_name()) {
    return NULL;
  }
  clear_has_ap_name();
  return ap_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void proximity::set_allocated_ap_name(::std::string* ap_name) {
  if (ap_name != NULL) {
    set_has_ap_name();
  } else {
    clear_has_ap_name();
  }
  ap_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ap_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.proximity.ap_name)
}

// optional bytes hashed_sta_eth_mac = 5;
inline bool proximity::has_hashed_sta_eth_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void proximity::set_has_hashed_sta_eth_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void proximity::clear_has_hashed_sta_eth_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void proximity::clear_hashed_sta_eth_mac() {
  hashed_sta_eth_mac_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hashed_sta_eth_mac();
}
inline const ::std::string& proximity::hashed_sta_eth_mac() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.proximity.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.GetNoArena();
}
inline void proximity::set_hashed_sta_eth_mac(const ::std::string& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.proximity.hashed_sta_eth_mac)
}
#if LANG_CXX11
inline void proximity::set_hashed_sta_eth_mac(::std::string&& value) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.proximity.hashed_sta_eth_mac)
}
#endif
inline void proximity::set_hashed_sta_eth_mac(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.proximity.hashed_sta_eth_mac)
}
inline void proximity::set_hashed_sta_eth_mac(const void* value, size_t size) {
  set_has_hashed_sta_eth_mac();
  hashed_sta_eth_mac_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.proximity.hashed_sta_eth_mac)
}
inline ::std::string* proximity::mutable_hashed_sta_eth_mac() {
  set_has_hashed_sta_eth_mac();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.proximity.hashed_sta_eth_mac)
  return hashed_sta_eth_mac_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* proximity::release_hashed_sta_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.proximity.hashed_sta_eth_mac)
  if (!has_hashed_sta_eth_mac()) {
    return NULL;
  }
  clear_has_hashed_sta_eth_mac();
  return hashed_sta_eth_mac_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void proximity::set_allocated_hashed_sta_eth_mac(::std::string* hashed_sta_eth_mac) {
  if (hashed_sta_eth_mac != NULL) {
    set_has_hashed_sta_eth_mac();
  } else {
    clear_has_hashed_sta_eth_mac();
  }
  hashed_sta_eth_mac_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashed_sta_eth_mac);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.proximity.hashed_sta_eth_mac)
}

// optional .ce.nbapi.target_dev_type target_type = 6 [default = TARGET_TYPE_STATION];
inline bool proximity::has_target_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void proximity::set_has_target_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void proximity::clear_has_target_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void proximity::clear_target_type() {
  target_type_ = 1;
  clear_has_target_type();
}
inline ::ce::nbapi::target_dev_type proximity::target_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.proximity.target_type)
  return static_cast< ::ce::nbapi::target_dev_type >(target_type_);
}
inline void proximity::set_target_type(::ce::nbapi::target_dev_type value) {
  assert(::ce::nbapi::target_dev_type_IsValid(value));
  set_has_target_type();
  target_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.proximity.target_type)
}

// -------------------------------------------------------------------

// dot1x

// optional uint64 start_timestamp = 1;
inline bool dot1x::has_start_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dot1x::set_has_start_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void dot1x::clear_has_start_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void dot1x::clear_start_timestamp() {
  start_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_start_timestamp();
}
inline ::google::protobuf::uint64 dot1x::start_timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.dot1x.start_timestamp)
  return start_timestamp_;
}
inline void dot1x::set_start_timestamp(::google::protobuf::uint64 value) {
  set_has_start_timestamp();
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.dot1x.start_timestamp)
}

// optional uint64 finish_timestamp = 2;
inline bool dot1x::has_finish_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dot1x::set_has_finish_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void dot1x::clear_has_finish_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void dot1x::clear_finish_timestamp() {
  finish_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_finish_timestamp();
}
inline ::google::protobuf::uint64 dot1x::finish_timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.dot1x.finish_timestamp)
  return finish_timestamp_;
}
inline void dot1x::set_finish_timestamp(::google::protobuf::uint64 value) {
  set_has_finish_timestamp();
  finish_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.dot1x.finish_timestamp)
}

// optional .ce.nbapi.mac_address station_mac = 3;
inline bool dot1x::has_station_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dot1x::set_has_station_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void dot1x::clear_has_station_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void dot1x::clear_station_mac() {
  if (station_mac_ != NULL) station_mac_->Clear();
  clear_has_station_mac();
}
inline const ::ce::nbapi::mac_address& dot1x::_internal_station_mac() const {
  return *station_mac_;
}
inline const ::ce::nbapi::mac_address& dot1x::station_mac() const {
  const ::ce::nbapi::mac_address* p = station_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.dot1x.station_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* dot1x::release_station_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.dot1x.station_mac)
  clear_has_station_mac();
  ::ce::nbapi::mac_address* temp = station_mac_;
  station_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* dot1x::mutable_station_mac() {
  set_has_station_mac();
  if (station_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    station_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.dot1x.station_mac)
  return station_mac_;
}
inline void dot1x::set_allocated_station_mac(::ce::nbapi::mac_address* station_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete station_mac_;
  }
  if (station_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      station_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, station_mac, submessage_arena);
    }
    set_has_station_mac();
  } else {
    clear_has_station_mac();
  }
  station_mac_ = station_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.dot1x.station_mac)
}

// optional string username = 4;
inline bool dot1x::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dot1x::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void dot1x::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void dot1x::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& dot1x::username() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.dot1x.username)
  return username_.GetNoArena();
}
inline void dot1x::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.dot1x.username)
}
#if LANG_CXX11
inline void dot1x::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.dot1x.username)
}
#endif
inline void dot1x::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.dot1x.username)
}
inline void dot1x::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.dot1x.username)
}
inline ::std::string* dot1x::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.dot1x.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* dot1x::release_username() {
  // @@protoc_insertion_point(field_release:ce.nbapi.dot1x.username)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void dot1x::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.dot1x.username)
}

// optional .ce.nbapi.mac_address bssid = 5;
inline bool dot1x::has_bssid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dot1x::set_has_bssid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void dot1x::clear_has_bssid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void dot1x::clear_bssid() {
  if (bssid_ != NULL) bssid_->Clear();
  clear_has_bssid();
}
inline const ::ce::nbapi::mac_address& dot1x::_internal_bssid() const {
  return *bssid_;
}
inline const ::ce::nbapi::mac_address& dot1x::bssid() const {
  const ::ce::nbapi::mac_address* p = bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.dot1x.bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* dot1x::release_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.dot1x.bssid)
  clear_has_bssid();
  ::ce::nbapi::mac_address* temp = bssid_;
  bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* dot1x::mutable_bssid() {
  set_has_bssid();
  if (bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.dot1x.bssid)
  return bssid_;
}
inline void dot1x::set_allocated_bssid(::ce::nbapi::mac_address* bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bssid_;
  }
  if (bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bssid, submessage_arena);
    }
    set_has_bssid();
  } else {
    clear_has_bssid();
  }
  bssid_ = bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.dot1x.bssid)
}

// optional uint32 result = 6;
inline bool dot1x::has_result() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dot1x::set_has_result() {
  _has_bits_[0] |= 0x00000040u;
}
inline void dot1x::clear_has_result() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void dot1x::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 dot1x::result() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.dot1x.result)
  return result_;
}
inline void dot1x::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.dot1x.result)
}

// optional uint32 reason = 7;
inline bool dot1x::has_reason() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void dot1x::set_has_reason() {
  _has_bits_[0] |= 0x00000080u;
}
inline void dot1x::clear_has_reason() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void dot1x::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
inline ::google::protobuf::uint32 dot1x::reason() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.dot1x.reason)
  return reason_;
}
inline void dot1x::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.dot1x.reason)
}

// optional uint32 server_retry_cnt = 8;
inline bool dot1x::has_server_retry_cnt() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void dot1x::set_has_server_retry_cnt() {
  _has_bits_[0] |= 0x00000100u;
}
inline void dot1x::clear_has_server_retry_cnt() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void dot1x::clear_server_retry_cnt() {
  server_retry_cnt_ = 0u;
  clear_has_server_retry_cnt();
}
inline ::google::protobuf::uint32 dot1x::server_retry_cnt() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.dot1x.server_retry_cnt)
  return server_retry_cnt_;
}
inline void dot1x::set_server_retry_cnt(::google::protobuf::uint32 value) {
  set_has_server_retry_cnt();
  server_retry_cnt_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.dot1x.server_retry_cnt)
}

// optional uint32 client_retry_cnt = 9;
inline bool dot1x::has_client_retry_cnt() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void dot1x::set_has_client_retry_cnt() {
  _has_bits_[0] |= 0x00000200u;
}
inline void dot1x::clear_has_client_retry_cnt() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void dot1x::clear_client_retry_cnt() {
  client_retry_cnt_ = 0u;
  clear_has_client_retry_cnt();
}
inline ::google::protobuf::uint32 dot1x::client_retry_cnt() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.dot1x.client_retry_cnt)
  return client_retry_cnt_;
}
inline void dot1x::set_client_retry_cnt(::google::protobuf::uint32 value) {
  set_has_client_retry_cnt();
  client_retry_cnt_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.dot1x.client_retry_cnt)
}

// optional .ce.nbapi.ip_address serverip = 10;
inline bool dot1x::has_serverip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dot1x::set_has_serverip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void dot1x::clear_has_serverip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void dot1x::clear_serverip() {
  if (serverip_ != NULL) serverip_->Clear();
  clear_has_serverip();
}
inline const ::ce::nbapi::ip_address& dot1x::_internal_serverip() const {
  return *serverip_;
}
inline const ::ce::nbapi::ip_address& dot1x::serverip() const {
  const ::ce::nbapi::ip_address* p = serverip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.dot1x.serverip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* dot1x::release_serverip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.dot1x.serverip)
  clear_has_serverip();
  ::ce::nbapi::ip_address* temp = serverip_;
  serverip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* dot1x::mutable_serverip() {
  set_has_serverip();
  if (serverip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    serverip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.dot1x.serverip)
  return serverip_;
}
inline void dot1x::set_allocated_serverip(::ce::nbapi::ip_address* serverip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete serverip_;
  }
  if (serverip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      serverip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, serverip, submessage_arena);
    }
    set_has_serverip();
  } else {
    clear_has_serverip();
  }
  serverip_ = serverip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.dot1x.serverip)
}

// optional uint32 srvr_elapsed_time = 11;
inline bool dot1x::has_srvr_elapsed_time() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void dot1x::set_has_srvr_elapsed_time() {
  _has_bits_[0] |= 0x00000400u;
}
inline void dot1x::clear_has_srvr_elapsed_time() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void dot1x::clear_srvr_elapsed_time() {
  srvr_elapsed_time_ = 0u;
  clear_has_srvr_elapsed_time();
}
inline ::google::protobuf::uint32 dot1x::srvr_elapsed_time() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.dot1x.srvr_elapsed_time)
  return srvr_elapsed_time_;
}
inline void dot1x::set_srvr_elapsed_time(::google::protobuf::uint32 value) {
  set_has_srvr_elapsed_time();
  srvr_elapsed_time_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.dot1x.srvr_elapsed_time)
}

// optional uint32 clnt_elapsed_time = 12;
inline bool dot1x::has_clnt_elapsed_time() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void dot1x::set_has_clnt_elapsed_time() {
  _has_bits_[0] |= 0x00000800u;
}
inline void dot1x::clear_has_clnt_elapsed_time() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void dot1x::clear_clnt_elapsed_time() {
  clnt_elapsed_time_ = 0u;
  clear_has_clnt_elapsed_time();
}
inline ::google::protobuf::uint32 dot1x::clnt_elapsed_time() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.dot1x.clnt_elapsed_time)
  return clnt_elapsed_time_;
}
inline void dot1x::set_clnt_elapsed_time(::google::protobuf::uint32 value) {
  set_has_clnt_elapsed_time();
  clnt_elapsed_time_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.dot1x.clnt_elapsed_time)
}

// -------------------------------------------------------------------

// wpa_key_handshake

// optional uint64 start_timestamp = 1;
inline bool wpa_key_handshake::has_start_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void wpa_key_handshake::set_has_start_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void wpa_key_handshake::clear_has_start_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void wpa_key_handshake::clear_start_timestamp() {
  start_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_start_timestamp();
}
inline ::google::protobuf::uint64 wpa_key_handshake::start_timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.wpa_key_handshake.start_timestamp)
  return start_timestamp_;
}
inline void wpa_key_handshake::set_start_timestamp(::google::protobuf::uint64 value) {
  set_has_start_timestamp();
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.wpa_key_handshake.start_timestamp)
}

// optional uint64 finish_timestamp = 2;
inline bool wpa_key_handshake::has_finish_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void wpa_key_handshake::set_has_finish_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void wpa_key_handshake::clear_has_finish_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void wpa_key_handshake::clear_finish_timestamp() {
  finish_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_finish_timestamp();
}
inline ::google::protobuf::uint64 wpa_key_handshake::finish_timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.wpa_key_handshake.finish_timestamp)
  return finish_timestamp_;
}
inline void wpa_key_handshake::set_finish_timestamp(::google::protobuf::uint64 value) {
  set_has_finish_timestamp();
  finish_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.wpa_key_handshake.finish_timestamp)
}

// optional .ce.nbapi.mac_address station_mac = 3;
inline bool wpa_key_handshake::has_station_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void wpa_key_handshake::set_has_station_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void wpa_key_handshake::clear_has_station_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void wpa_key_handshake::clear_station_mac() {
  if (station_mac_ != NULL) station_mac_->Clear();
  clear_has_station_mac();
}
inline const ::ce::nbapi::mac_address& wpa_key_handshake::_internal_station_mac() const {
  return *station_mac_;
}
inline const ::ce::nbapi::mac_address& wpa_key_handshake::station_mac() const {
  const ::ce::nbapi::mac_address* p = station_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.wpa_key_handshake.station_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* wpa_key_handshake::release_station_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.wpa_key_handshake.station_mac)
  clear_has_station_mac();
  ::ce::nbapi::mac_address* temp = station_mac_;
  station_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* wpa_key_handshake::mutable_station_mac() {
  set_has_station_mac();
  if (station_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    station_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.wpa_key_handshake.station_mac)
  return station_mac_;
}
inline void wpa_key_handshake::set_allocated_station_mac(::ce::nbapi::mac_address* station_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete station_mac_;
  }
  if (station_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      station_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, station_mac, submessage_arena);
    }
    set_has_station_mac();
  } else {
    clear_has_station_mac();
  }
  station_mac_ = station_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.wpa_key_handshake.station_mac)
}

// optional .ce.nbapi.mac_address bssid = 4;
inline bool wpa_key_handshake::has_bssid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void wpa_key_handshake::set_has_bssid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void wpa_key_handshake::clear_has_bssid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void wpa_key_handshake::clear_bssid() {
  if (bssid_ != NULL) bssid_->Clear();
  clear_has_bssid();
}
inline const ::ce::nbapi::mac_address& wpa_key_handshake::_internal_bssid() const {
  return *bssid_;
}
inline const ::ce::nbapi::mac_address& wpa_key_handshake::bssid() const {
  const ::ce::nbapi::mac_address* p = bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.wpa_key_handshake.bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* wpa_key_handshake::release_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.wpa_key_handshake.bssid)
  clear_has_bssid();
  ::ce::nbapi::mac_address* temp = bssid_;
  bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* wpa_key_handshake::mutable_bssid() {
  set_has_bssid();
  if (bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.wpa_key_handshake.bssid)
  return bssid_;
}
inline void wpa_key_handshake::set_allocated_bssid(::ce::nbapi::mac_address* bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bssid_;
  }
  if (bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bssid, submessage_arena);
    }
    set_has_bssid();
  } else {
    clear_has_bssid();
  }
  bssid_ = bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.wpa_key_handshake.bssid)
}

// optional uint32 result = 5;
inline bool wpa_key_handshake::has_result() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void wpa_key_handshake::set_has_result() {
  _has_bits_[0] |= 0x00000010u;
}
inline void wpa_key_handshake::clear_has_result() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void wpa_key_handshake::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 wpa_key_handshake::result() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.wpa_key_handshake.result)
  return result_;
}
inline void wpa_key_handshake::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.wpa_key_handshake.result)
}

// optional uint32 trigger_reason = 6;
inline bool wpa_key_handshake::has_trigger_reason() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void wpa_key_handshake::set_has_trigger_reason() {
  _has_bits_[0] |= 0x00000020u;
}
inline void wpa_key_handshake::clear_has_trigger_reason() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void wpa_key_handshake::clear_trigger_reason() {
  trigger_reason_ = 0u;
  clear_has_trigger_reason();
}
inline ::google::protobuf::uint32 wpa_key_handshake::trigger_reason() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.wpa_key_handshake.trigger_reason)
  return trigger_reason_;
}
inline void wpa_key_handshake::set_trigger_reason(::google::protobuf::uint32 value) {
  set_has_trigger_reason();
  trigger_reason_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.wpa_key_handshake.trigger_reason)
}

// optional uint32 reason = 7;
inline bool wpa_key_handshake::has_reason() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void wpa_key_handshake::set_has_reason() {
  _has_bits_[0] |= 0x00000040u;
}
inline void wpa_key_handshake::clear_has_reason() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void wpa_key_handshake::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
inline ::google::protobuf::uint32 wpa_key_handshake::reason() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.wpa_key_handshake.reason)
  return reason_;
}
inline void wpa_key_handshake::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.wpa_key_handshake.reason)
}

// optional uint32 key1_retry_cnt = 8;
inline bool wpa_key_handshake::has_key1_retry_cnt() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void wpa_key_handshake::set_has_key1_retry_cnt() {
  _has_bits_[0] |= 0x00000080u;
}
inline void wpa_key_handshake::clear_has_key1_retry_cnt() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void wpa_key_handshake::clear_key1_retry_cnt() {
  key1_retry_cnt_ = 0u;
  clear_has_key1_retry_cnt();
}
inline ::google::protobuf::uint32 wpa_key_handshake::key1_retry_cnt() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.wpa_key_handshake.key1_retry_cnt)
  return key1_retry_cnt_;
}
inline void wpa_key_handshake::set_key1_retry_cnt(::google::protobuf::uint32 value) {
  set_has_key1_retry_cnt();
  key1_retry_cnt_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.wpa_key_handshake.key1_retry_cnt)
}

// optional uint32 key3_retry_cnt = 9;
inline bool wpa_key_handshake::has_key3_retry_cnt() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void wpa_key_handshake::set_has_key3_retry_cnt() {
  _has_bits_[0] |= 0x00000100u;
}
inline void wpa_key_handshake::clear_has_key3_retry_cnt() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void wpa_key_handshake::clear_key3_retry_cnt() {
  key3_retry_cnt_ = 0u;
  clear_has_key3_retry_cnt();
}
inline ::google::protobuf::uint32 wpa_key_handshake::key3_retry_cnt() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.wpa_key_handshake.key3_retry_cnt)
  return key3_retry_cnt_;
}
inline void wpa_key_handshake::set_key3_retry_cnt(::google::protobuf::uint32 value) {
  set_has_key3_retry_cnt();
  key3_retry_cnt_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.wpa_key_handshake.key3_retry_cnt)
}

// optional uint32 replay_counter_mismatch = 10;
inline bool wpa_key_handshake::has_replay_counter_mismatch() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void wpa_key_handshake::set_has_replay_counter_mismatch() {
  _has_bits_[0] |= 0x00000200u;
}
inline void wpa_key_handshake::clear_has_replay_counter_mismatch() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void wpa_key_handshake::clear_replay_counter_mismatch() {
  replay_counter_mismatch_ = 0u;
  clear_has_replay_counter_mismatch();
}
inline ::google::protobuf::uint32 wpa_key_handshake::replay_counter_mismatch() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.wpa_key_handshake.replay_counter_mismatch)
  return replay_counter_mismatch_;
}
inline void wpa_key_handshake::set_replay_counter_mismatch(::google::protobuf::uint32 value) {
  set_has_replay_counter_mismatch();
  replay_counter_mismatch_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.wpa_key_handshake.replay_counter_mismatch)
}

// -------------------------------------------------------------------

// captive_portal

// optional uint64 start_timestamp = 1;
inline bool captive_portal::has_start_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void captive_portal::set_has_start_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void captive_portal::clear_has_start_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void captive_portal::clear_start_timestamp() {
  start_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_start_timestamp();
}
inline ::google::protobuf::uint64 captive_portal::start_timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.captive_portal.start_timestamp)
  return start_timestamp_;
}
inline void captive_portal::set_start_timestamp(::google::protobuf::uint64 value) {
  set_has_start_timestamp();
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.captive_portal.start_timestamp)
}

// optional uint64 finish_timestamp = 2;
inline bool captive_portal::has_finish_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void captive_portal::set_has_finish_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void captive_portal::clear_has_finish_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void captive_portal::clear_finish_timestamp() {
  finish_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_finish_timestamp();
}
inline ::google::protobuf::uint64 captive_portal::finish_timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.captive_portal.finish_timestamp)
  return finish_timestamp_;
}
inline void captive_portal::set_finish_timestamp(::google::protobuf::uint64 value) {
  set_has_finish_timestamp();
  finish_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.captive_portal.finish_timestamp)
}

// optional .ce.nbapi.mac_address station_mac = 3;
inline bool captive_portal::has_station_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void captive_portal::set_has_station_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void captive_portal::clear_has_station_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void captive_portal::clear_station_mac() {
  if (station_mac_ != NULL) station_mac_->Clear();
  clear_has_station_mac();
}
inline const ::ce::nbapi::mac_address& captive_portal::_internal_station_mac() const {
  return *station_mac_;
}
inline const ::ce::nbapi::mac_address& captive_portal::station_mac() const {
  const ::ce::nbapi::mac_address* p = station_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.captive_portal.station_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* captive_portal::release_station_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.captive_portal.station_mac)
  clear_has_station_mac();
  ::ce::nbapi::mac_address* temp = station_mac_;
  station_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* captive_portal::mutable_station_mac() {
  set_has_station_mac();
  if (station_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    station_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.captive_portal.station_mac)
  return station_mac_;
}
inline void captive_portal::set_allocated_station_mac(::ce::nbapi::mac_address* station_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete station_mac_;
  }
  if (station_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      station_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, station_mac, submessage_arena);
    }
    set_has_station_mac();
  } else {
    clear_has_station_mac();
  }
  station_mac_ = station_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.captive_portal.station_mac)
}

// optional string username = 4;
inline bool captive_portal::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void captive_portal::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void captive_portal::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void captive_portal::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& captive_portal::username() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.captive_portal.username)
  return username_.GetNoArena();
}
inline void captive_portal::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.captive_portal.username)
}
#if LANG_CXX11
inline void captive_portal::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.captive_portal.username)
}
#endif
inline void captive_portal::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.captive_portal.username)
}
inline void captive_portal::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.captive_portal.username)
}
inline ::std::string* captive_portal::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.captive_portal.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* captive_portal::release_username() {
  // @@protoc_insertion_point(field_release:ce.nbapi.captive_portal.username)
  if (!has_username()) {
    return NULL;
  }
  clear_has_username();
  return username_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void captive_portal::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.captive_portal.username)
}

// optional .ce.nbapi.mac_address bssid = 5;
inline bool captive_portal::has_bssid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void captive_portal::set_has_bssid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void captive_portal::clear_has_bssid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void captive_portal::clear_bssid() {
  if (bssid_ != NULL) bssid_->Clear();
  clear_has_bssid();
}
inline const ::ce::nbapi::mac_address& captive_portal::_internal_bssid() const {
  return *bssid_;
}
inline const ::ce::nbapi::mac_address& captive_portal::bssid() const {
  const ::ce::nbapi::mac_address* p = bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.captive_portal.bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* captive_portal::release_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.captive_portal.bssid)
  clear_has_bssid();
  ::ce::nbapi::mac_address* temp = bssid_;
  bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* captive_portal::mutable_bssid() {
  set_has_bssid();
  if (bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.captive_portal.bssid)
  return bssid_;
}
inline void captive_portal::set_allocated_bssid(::ce::nbapi::mac_address* bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bssid_;
  }
  if (bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bssid, submessage_arena);
    }
    set_has_bssid();
  } else {
    clear_has_bssid();
  }
  bssid_ = bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.captive_portal.bssid)
}

// optional uint32 result = 6;
inline bool captive_portal::has_result() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void captive_portal::set_has_result() {
  _has_bits_[0] |= 0x00000080u;
}
inline void captive_portal::clear_has_result() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void captive_portal::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 captive_portal::result() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.captive_portal.result)
  return result_;
}
inline void captive_portal::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.captive_portal.result)
}

// optional uint32 reason = 7;
inline bool captive_portal::has_reason() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void captive_portal::set_has_reason() {
  _has_bits_[0] |= 0x00000100u;
}
inline void captive_portal::clear_has_reason() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void captive_portal::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
inline ::google::protobuf::uint32 captive_portal::reason() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.captive_portal.reason)
  return reason_;
}
inline void captive_portal::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.captive_portal.reason)
}

// optional uint32 server_retry_cnt = 8;
inline bool captive_portal::has_server_retry_cnt() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void captive_portal::set_has_server_retry_cnt() {
  _has_bits_[0] |= 0x00000200u;
}
inline void captive_portal::clear_has_server_retry_cnt() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void captive_portal::clear_server_retry_cnt() {
  server_retry_cnt_ = 0u;
  clear_has_server_retry_cnt();
}
inline ::google::protobuf::uint32 captive_portal::server_retry_cnt() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.captive_portal.server_retry_cnt)
  return server_retry_cnt_;
}
inline void captive_portal::set_server_retry_cnt(::google::protobuf::uint32 value) {
  set_has_server_retry_cnt();
  server_retry_cnt_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.captive_portal.server_retry_cnt)
}

// optional .ce.nbapi.ip_address serverip = 9;
inline bool captive_portal::has_serverip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void captive_portal::set_has_serverip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void captive_portal::clear_has_serverip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void captive_portal::clear_serverip() {
  if (serverip_ != NULL) serverip_->Clear();
  clear_has_serverip();
}
inline const ::ce::nbapi::ip_address& captive_portal::_internal_serverip() const {
  return *serverip_;
}
inline const ::ce::nbapi::ip_address& captive_portal::serverip() const {
  const ::ce::nbapi::ip_address* p = serverip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.captive_portal.serverip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* captive_portal::release_serverip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.captive_portal.serverip)
  clear_has_serverip();
  ::ce::nbapi::ip_address* temp = serverip_;
  serverip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* captive_portal::mutable_serverip() {
  set_has_serverip();
  if (serverip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    serverip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.captive_portal.serverip)
  return serverip_;
}
inline void captive_portal::set_allocated_serverip(::ce::nbapi::ip_address* serverip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete serverip_;
  }
  if (serverip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      serverip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, serverip, submessage_arena);
    }
    set_has_serverip();
  } else {
    clear_has_serverip();
  }
  serverip_ = serverip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.captive_portal.serverip)
}

// optional .ce.nbapi.ip_address userip = 10;
inline bool captive_portal::has_userip() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void captive_portal::set_has_userip() {
  _has_bits_[0] |= 0x00000010u;
}
inline void captive_portal::clear_has_userip() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void captive_portal::clear_userip() {
  if (userip_ != NULL) userip_->Clear();
  clear_has_userip();
}
inline const ::ce::nbapi::ip_address& captive_portal::_internal_userip() const {
  return *userip_;
}
inline const ::ce::nbapi::ip_address& captive_portal::userip() const {
  const ::ce::nbapi::ip_address* p = userip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.captive_portal.userip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* captive_portal::release_userip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.captive_portal.userip)
  clear_has_userip();
  ::ce::nbapi::ip_address* temp = userip_;
  userip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* captive_portal::mutable_userip() {
  set_has_userip();
  if (userip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    userip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.captive_portal.userip)
  return userip_;
}
inline void captive_portal::set_allocated_userip(::ce::nbapi::ip_address* userip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete userip_;
  }
  if (userip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      userip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, userip, submessage_arena);
    }
    set_has_userip();
  } else {
    clear_has_userip();
  }
  userip_ = userip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.captive_portal.userip)
}

// -------------------------------------------------------------------

// macauth

// optional uint64 start_timestamp = 1;
inline bool macauth::has_start_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void macauth::set_has_start_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void macauth::clear_has_start_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void macauth::clear_start_timestamp() {
  start_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_start_timestamp();
}
inline ::google::protobuf::uint64 macauth::start_timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.macauth.start_timestamp)
  return start_timestamp_;
}
inline void macauth::set_start_timestamp(::google::protobuf::uint64 value) {
  set_has_start_timestamp();
  start_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.macauth.start_timestamp)
}

// optional uint64 finish_timestamp = 2;
inline bool macauth::has_finish_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void macauth::set_has_finish_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void macauth::clear_has_finish_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void macauth::clear_finish_timestamp() {
  finish_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_finish_timestamp();
}
inline ::google::protobuf::uint64 macauth::finish_timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.macauth.finish_timestamp)
  return finish_timestamp_;
}
inline void macauth::set_finish_timestamp(::google::protobuf::uint64 value) {
  set_has_finish_timestamp();
  finish_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.macauth.finish_timestamp)
}

// optional .ce.nbapi.mac_address station_mac = 3;
inline bool macauth::has_station_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void macauth::set_has_station_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void macauth::clear_has_station_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void macauth::clear_station_mac() {
  if (station_mac_ != NULL) station_mac_->Clear();
  clear_has_station_mac();
}
inline const ::ce::nbapi::mac_address& macauth::_internal_station_mac() const {
  return *station_mac_;
}
inline const ::ce::nbapi::mac_address& macauth::station_mac() const {
  const ::ce::nbapi::mac_address* p = station_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.macauth.station_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* macauth::release_station_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.macauth.station_mac)
  clear_has_station_mac();
  ::ce::nbapi::mac_address* temp = station_mac_;
  station_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* macauth::mutable_station_mac() {
  set_has_station_mac();
  if (station_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    station_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.macauth.station_mac)
  return station_mac_;
}
inline void macauth::set_allocated_station_mac(::ce::nbapi::mac_address* station_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete station_mac_;
  }
  if (station_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      station_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, station_mac, submessage_arena);
    }
    set_has_station_mac();
  } else {
    clear_has_station_mac();
  }
  station_mac_ = station_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.macauth.station_mac)
}

// optional .ce.nbapi.mac_address bssid = 4;
inline bool macauth::has_bssid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void macauth::set_has_bssid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void macauth::clear_has_bssid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void macauth::clear_bssid() {
  if (bssid_ != NULL) bssid_->Clear();
  clear_has_bssid();
}
inline const ::ce::nbapi::mac_address& macauth::_internal_bssid() const {
  return *bssid_;
}
inline const ::ce::nbapi::mac_address& macauth::bssid() const {
  const ::ce::nbapi::mac_address* p = bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.macauth.bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* macauth::release_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.macauth.bssid)
  clear_has_bssid();
  ::ce::nbapi::mac_address* temp = bssid_;
  bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* macauth::mutable_bssid() {
  set_has_bssid();
  if (bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.macauth.bssid)
  return bssid_;
}
inline void macauth::set_allocated_bssid(::ce::nbapi::mac_address* bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bssid_;
  }
  if (bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bssid, submessage_arena);
    }
    set_has_bssid();
  } else {
    clear_has_bssid();
  }
  bssid_ = bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.macauth.bssid)
}

// optional uint32 result = 5;
inline bool macauth::has_result() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void macauth::set_has_result() {
  _has_bits_[0] |= 0x00000020u;
}
inline void macauth::clear_has_result() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void macauth::clear_result() {
  result_ = 0u;
  clear_has_result();
}
inline ::google::protobuf::uint32 macauth::result() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.macauth.result)
  return result_;
}
inline void macauth::set_result(::google::protobuf::uint32 value) {
  set_has_result();
  result_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.macauth.result)
}

// optional uint32 reason = 6;
inline bool macauth::has_reason() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void macauth::set_has_reason() {
  _has_bits_[0] |= 0x00000040u;
}
inline void macauth::clear_has_reason() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void macauth::clear_reason() {
  reason_ = 0u;
  clear_has_reason();
}
inline ::google::protobuf::uint32 macauth::reason() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.macauth.reason)
  return reason_;
}
inline void macauth::set_reason(::google::protobuf::uint32 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.macauth.reason)
}

// optional uint32 server_retry_cnt = 7;
inline bool macauth::has_server_retry_cnt() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void macauth::set_has_server_retry_cnt() {
  _has_bits_[0] |= 0x00000080u;
}
inline void macauth::clear_has_server_retry_cnt() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void macauth::clear_server_retry_cnt() {
  server_retry_cnt_ = 0u;
  clear_has_server_retry_cnt();
}
inline ::google::protobuf::uint32 macauth::server_retry_cnt() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.macauth.server_retry_cnt)
  return server_retry_cnt_;
}
inline void macauth::set_server_retry_cnt(::google::protobuf::uint32 value) {
  set_has_server_retry_cnt();
  server_retry_cnt_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.macauth.server_retry_cnt)
}

// optional .ce.nbapi.ip_address serverip = 8;
inline bool macauth::has_serverip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void macauth::set_has_serverip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void macauth::clear_has_serverip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void macauth::clear_serverip() {
  if (serverip_ != NULL) serverip_->Clear();
  clear_has_serverip();
}
inline const ::ce::nbapi::ip_address& macauth::_internal_serverip() const {
  return *serverip_;
}
inline const ::ce::nbapi::ip_address& macauth::serverip() const {
  const ::ce::nbapi::ip_address* p = serverip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.macauth.serverip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* macauth::release_serverip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.macauth.serverip)
  clear_has_serverip();
  ::ce::nbapi::ip_address* temp = serverip_;
  serverip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* macauth::mutable_serverip() {
  set_has_serverip();
  if (serverip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    serverip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.macauth.serverip)
  return serverip_;
}
inline void macauth::set_allocated_serverip(::ce::nbapi::ip_address* serverip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete serverip_;
  }
  if (serverip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      serverip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, serverip, submessage_arena);
    }
    set_has_serverip();
  } else {
    clear_has_serverip();
  }
  serverip_ = serverip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.macauth.serverip)
}

// -------------------------------------------------------------------

// auth_srvr_timeout

// optional uint64 timestamp = 1;
inline bool auth_srvr_timeout::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void auth_srvr_timeout::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void auth_srvr_timeout::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void auth_srvr_timeout::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 auth_srvr_timeout::timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.auth_srvr_timeout.timestamp)
  return timestamp_;
}
inline void auth_srvr_timeout::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.auth_srvr_timeout.timestamp)
}

// optional .ce.nbapi.mac_address station_mac = 2;
inline bool auth_srvr_timeout::has_station_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void auth_srvr_timeout::set_has_station_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void auth_srvr_timeout::clear_has_station_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void auth_srvr_timeout::clear_station_mac() {
  if (station_mac_ != NULL) station_mac_->Clear();
  clear_has_station_mac();
}
inline const ::ce::nbapi::mac_address& auth_srvr_timeout::_internal_station_mac() const {
  return *station_mac_;
}
inline const ::ce::nbapi::mac_address& auth_srvr_timeout::station_mac() const {
  const ::ce::nbapi::mac_address* p = station_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.auth_srvr_timeout.station_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* auth_srvr_timeout::release_station_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.auth_srvr_timeout.station_mac)
  clear_has_station_mac();
  ::ce::nbapi::mac_address* temp = station_mac_;
  station_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* auth_srvr_timeout::mutable_station_mac() {
  set_has_station_mac();
  if (station_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    station_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.auth_srvr_timeout.station_mac)
  return station_mac_;
}
inline void auth_srvr_timeout::set_allocated_station_mac(::ce::nbapi::mac_address* station_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete station_mac_;
  }
  if (station_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      station_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, station_mac, submessage_arena);
    }
    set_has_station_mac();
  } else {
    clear_has_station_mac();
  }
  station_mac_ = station_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.auth_srvr_timeout.station_mac)
}

// optional .ce.nbapi.mac_address bssid = 3;
inline bool auth_srvr_timeout::has_bssid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void auth_srvr_timeout::set_has_bssid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void auth_srvr_timeout::clear_has_bssid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void auth_srvr_timeout::clear_bssid() {
  if (bssid_ != NULL) bssid_->Clear();
  clear_has_bssid();
}
inline const ::ce::nbapi::mac_address& auth_srvr_timeout::_internal_bssid() const {
  return *bssid_;
}
inline const ::ce::nbapi::mac_address& auth_srvr_timeout::bssid() const {
  const ::ce::nbapi::mac_address* p = bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.auth_srvr_timeout.bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* auth_srvr_timeout::release_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.auth_srvr_timeout.bssid)
  clear_has_bssid();
  ::ce::nbapi::mac_address* temp = bssid_;
  bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* auth_srvr_timeout::mutable_bssid() {
  set_has_bssid();
  if (bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.auth_srvr_timeout.bssid)
  return bssid_;
}
inline void auth_srvr_timeout::set_allocated_bssid(::ce::nbapi::mac_address* bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bssid_;
  }
  if (bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bssid, submessage_arena);
    }
    set_has_bssid();
  } else {
    clear_has_bssid();
  }
  bssid_ = bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.auth_srvr_timeout.bssid)
}

// optional uint32 authtype = 4;
inline bool auth_srvr_timeout::has_authtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void auth_srvr_timeout::set_has_authtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void auth_srvr_timeout::clear_has_authtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void auth_srvr_timeout::clear_authtype() {
  authtype_ = 0u;
  clear_has_authtype();
}
inline ::google::protobuf::uint32 auth_srvr_timeout::authtype() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.auth_srvr_timeout.authtype)
  return authtype_;
}
inline void auth_srvr_timeout::set_authtype(::google::protobuf::uint32 value) {
  set_has_authtype();
  authtype_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.auth_srvr_timeout.authtype)
}

// optional uint32 retry_cnt = 5;
inline bool auth_srvr_timeout::has_retry_cnt() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void auth_srvr_timeout::set_has_retry_cnt() {
  _has_bits_[0] |= 0x00000040u;
}
inline void auth_srvr_timeout::clear_has_retry_cnt() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void auth_srvr_timeout::clear_retry_cnt() {
  retry_cnt_ = 0u;
  clear_has_retry_cnt();
}
inline ::google::protobuf::uint32 auth_srvr_timeout::retry_cnt() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.auth_srvr_timeout.retry_cnt)
  return retry_cnt_;
}
inline void auth_srvr_timeout::set_retry_cnt(::google::protobuf::uint32 value) {
  set_has_retry_cnt();
  retry_cnt_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.auth_srvr_timeout.retry_cnt)
}

// optional .ce.nbapi.ip_address userip = 6;
inline bool auth_srvr_timeout::has_userip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void auth_srvr_timeout::set_has_userip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void auth_srvr_timeout::clear_has_userip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void auth_srvr_timeout::clear_userip() {
  if (userip_ != NULL) userip_->Clear();
  clear_has_userip();
}
inline const ::ce::nbapi::ip_address& auth_srvr_timeout::_internal_userip() const {
  return *userip_;
}
inline const ::ce::nbapi::ip_address& auth_srvr_timeout::userip() const {
  const ::ce::nbapi::ip_address* p = userip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.auth_srvr_timeout.userip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* auth_srvr_timeout::release_userip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.auth_srvr_timeout.userip)
  clear_has_userip();
  ::ce::nbapi::ip_address* temp = userip_;
  userip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* auth_srvr_timeout::mutable_userip() {
  set_has_userip();
  if (userip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    userip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.auth_srvr_timeout.userip)
  return userip_;
}
inline void auth_srvr_timeout::set_allocated_userip(::ce::nbapi::ip_address* userip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete userip_;
  }
  if (userip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      userip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, userip, submessage_arena);
    }
    set_has_userip();
  } else {
    clear_has_userip();
  }
  userip_ = userip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.auth_srvr_timeout.userip)
}

// optional .ce.nbapi.ip_address serverip = 7;
inline bool auth_srvr_timeout::has_serverip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void auth_srvr_timeout::set_has_serverip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void auth_srvr_timeout::clear_has_serverip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void auth_srvr_timeout::clear_serverip() {
  if (serverip_ != NULL) serverip_->Clear();
  clear_has_serverip();
}
inline const ::ce::nbapi::ip_address& auth_srvr_timeout::_internal_serverip() const {
  return *serverip_;
}
inline const ::ce::nbapi::ip_address& auth_srvr_timeout::serverip() const {
  const ::ce::nbapi::ip_address* p = serverip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.auth_srvr_timeout.serverip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* auth_srvr_timeout::release_serverip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.auth_srvr_timeout.serverip)
  clear_has_serverip();
  ::ce::nbapi::ip_address* temp = serverip_;
  serverip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* auth_srvr_timeout::mutable_serverip() {
  set_has_serverip();
  if (serverip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    serverip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.auth_srvr_timeout.serverip)
  return serverip_;
}
inline void auth_srvr_timeout::set_allocated_serverip(::ce::nbapi::ip_address* serverip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete serverip_;
  }
  if (serverip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      serverip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, serverip, submessage_arena);
    }
    set_has_serverip();
  } else {
    clear_has_serverip();
  }
  serverip_ = serverip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.auth_srvr_timeout.serverip)
}

// -------------------------------------------------------------------

// security_message

// optional .ce.nbapi.security_message.security_msg_type msg_type = 1;
inline bool security_message::has_msg_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void security_message::set_has_msg_type() {
  _has_bits_[0] |= 0x00000020u;
}
inline void security_message::clear_has_msg_type() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void security_message::clear_msg_type() {
  msg_type_ = 0;
  clear_has_msg_type();
}
inline ::ce::nbapi::security_message_security_msg_type security_message::msg_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.security_message.msg_type)
  return static_cast< ::ce::nbapi::security_message_security_msg_type >(msg_type_);
}
inline void security_message::set_msg_type(::ce::nbapi::security_message_security_msg_type value) {
  assert(::ce::nbapi::security_message_security_msg_type_IsValid(value));
  set_has_msg_type();
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.security_message.msg_type)
}

// optional .ce.nbapi.auth_srvr_timeout auth_srvr_timeout = 2;
inline bool security_message::has_auth_srvr_timeout() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void security_message::set_has_auth_srvr_timeout() {
  _has_bits_[0] |= 0x00000001u;
}
inline void security_message::clear_has_auth_srvr_timeout() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void security_message::clear_auth_srvr_timeout() {
  if (auth_srvr_timeout_ != NULL) auth_srvr_timeout_->Clear();
  clear_has_auth_srvr_timeout();
}
inline const ::ce::nbapi::auth_srvr_timeout& security_message::_internal_auth_srvr_timeout() const {
  return *auth_srvr_timeout_;
}
inline const ::ce::nbapi::auth_srvr_timeout& security_message::auth_srvr_timeout() const {
  const ::ce::nbapi::auth_srvr_timeout* p = auth_srvr_timeout_;
  // @@protoc_insertion_point(field_get:ce.nbapi.security_message.auth_srvr_timeout)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::auth_srvr_timeout*>(
      &::ce::nbapi::_auth_srvr_timeout_default_instance_);
}
inline ::ce::nbapi::auth_srvr_timeout* security_message::release_auth_srvr_timeout() {
  // @@protoc_insertion_point(field_release:ce.nbapi.security_message.auth_srvr_timeout)
  clear_has_auth_srvr_timeout();
  ::ce::nbapi::auth_srvr_timeout* temp = auth_srvr_timeout_;
  auth_srvr_timeout_ = NULL;
  return temp;
}
inline ::ce::nbapi::auth_srvr_timeout* security_message::mutable_auth_srvr_timeout() {
  set_has_auth_srvr_timeout();
  if (auth_srvr_timeout_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::auth_srvr_timeout>(GetArenaNoVirtual());
    auth_srvr_timeout_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.security_message.auth_srvr_timeout)
  return auth_srvr_timeout_;
}
inline void security_message::set_allocated_auth_srvr_timeout(::ce::nbapi::auth_srvr_timeout* auth_srvr_timeout) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete auth_srvr_timeout_;
  }
  if (auth_srvr_timeout) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      auth_srvr_timeout = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, auth_srvr_timeout, submessage_arena);
    }
    set_has_auth_srvr_timeout();
  } else {
    clear_has_auth_srvr_timeout();
  }
  auth_srvr_timeout_ = auth_srvr_timeout;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.security_message.auth_srvr_timeout)
}

// optional .ce.nbapi.macauth macauth = 3;
inline bool security_message::has_macauth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void security_message::set_has_macauth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void security_message::clear_has_macauth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void security_message::clear_macauth() {
  if (macauth_ != NULL) macauth_->Clear();
  clear_has_macauth();
}
inline const ::ce::nbapi::macauth& security_message::_internal_macauth() const {
  return *macauth_;
}
inline const ::ce::nbapi::macauth& security_message::macauth() const {
  const ::ce::nbapi::macauth* p = macauth_;
  // @@protoc_insertion_point(field_get:ce.nbapi.security_message.macauth)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::macauth*>(
      &::ce::nbapi::_macauth_default_instance_);
}
inline ::ce::nbapi::macauth* security_message::release_macauth() {
  // @@protoc_insertion_point(field_release:ce.nbapi.security_message.macauth)
  clear_has_macauth();
  ::ce::nbapi::macauth* temp = macauth_;
  macauth_ = NULL;
  return temp;
}
inline ::ce::nbapi::macauth* security_message::mutable_macauth() {
  set_has_macauth();
  if (macauth_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::macauth>(GetArenaNoVirtual());
    macauth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.security_message.macauth)
  return macauth_;
}
inline void security_message::set_allocated_macauth(::ce::nbapi::macauth* macauth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete macauth_;
  }
  if (macauth) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      macauth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, macauth, submessage_arena);
    }
    set_has_macauth();
  } else {
    clear_has_macauth();
  }
  macauth_ = macauth;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.security_message.macauth)
}

// optional .ce.nbapi.captive_portal captive_portal = 4;
inline bool security_message::has_captive_portal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void security_message::set_has_captive_portal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void security_message::clear_has_captive_portal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void security_message::clear_captive_portal() {
  if (captive_portal_ != NULL) captive_portal_->Clear();
  clear_has_captive_portal();
}
inline const ::ce::nbapi::captive_portal& security_message::_internal_captive_portal() const {
  return *captive_portal_;
}
inline const ::ce::nbapi::captive_portal& security_message::captive_portal() const {
  const ::ce::nbapi::captive_portal* p = captive_portal_;
  // @@protoc_insertion_point(field_get:ce.nbapi.security_message.captive_portal)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::captive_portal*>(
      &::ce::nbapi::_captive_portal_default_instance_);
}
inline ::ce::nbapi::captive_portal* security_message::release_captive_portal() {
  // @@protoc_insertion_point(field_release:ce.nbapi.security_message.captive_portal)
  clear_has_captive_portal();
  ::ce::nbapi::captive_portal* temp = captive_portal_;
  captive_portal_ = NULL;
  return temp;
}
inline ::ce::nbapi::captive_portal* security_message::mutable_captive_portal() {
  set_has_captive_portal();
  if (captive_portal_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::captive_portal>(GetArenaNoVirtual());
    captive_portal_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.security_message.captive_portal)
  return captive_portal_;
}
inline void security_message::set_allocated_captive_portal(::ce::nbapi::captive_portal* captive_portal) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete captive_portal_;
  }
  if (captive_portal) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      captive_portal = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, captive_portal, submessage_arena);
    }
    set_has_captive_portal();
  } else {
    clear_has_captive_portal();
  }
  captive_portal_ = captive_portal;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.security_message.captive_portal)
}

// optional .ce.nbapi.wpa_key_handshake wpa_key_handshake = 5;
inline bool security_message::has_wpa_key_handshake() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void security_message::set_has_wpa_key_handshake() {
  _has_bits_[0] |= 0x00000008u;
}
inline void security_message::clear_has_wpa_key_handshake() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void security_message::clear_wpa_key_handshake() {
  if (wpa_key_handshake_ != NULL) wpa_key_handshake_->Clear();
  clear_has_wpa_key_handshake();
}
inline const ::ce::nbapi::wpa_key_handshake& security_message::_internal_wpa_key_handshake() const {
  return *wpa_key_handshake_;
}
inline const ::ce::nbapi::wpa_key_handshake& security_message::wpa_key_handshake() const {
  const ::ce::nbapi::wpa_key_handshake* p = wpa_key_handshake_;
  // @@protoc_insertion_point(field_get:ce.nbapi.security_message.wpa_key_handshake)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::wpa_key_handshake*>(
      &::ce::nbapi::_wpa_key_handshake_default_instance_);
}
inline ::ce::nbapi::wpa_key_handshake* security_message::release_wpa_key_handshake() {
  // @@protoc_insertion_point(field_release:ce.nbapi.security_message.wpa_key_handshake)
  clear_has_wpa_key_handshake();
  ::ce::nbapi::wpa_key_handshake* temp = wpa_key_handshake_;
  wpa_key_handshake_ = NULL;
  return temp;
}
inline ::ce::nbapi::wpa_key_handshake* security_message::mutable_wpa_key_handshake() {
  set_has_wpa_key_handshake();
  if (wpa_key_handshake_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::wpa_key_handshake>(GetArenaNoVirtual());
    wpa_key_handshake_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.security_message.wpa_key_handshake)
  return wpa_key_handshake_;
}
inline void security_message::set_allocated_wpa_key_handshake(::ce::nbapi::wpa_key_handshake* wpa_key_handshake) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wpa_key_handshake_;
  }
  if (wpa_key_handshake) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wpa_key_handshake = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wpa_key_handshake, submessage_arena);
    }
    set_has_wpa_key_handshake();
  } else {
    clear_has_wpa_key_handshake();
  }
  wpa_key_handshake_ = wpa_key_handshake;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.security_message.wpa_key_handshake)
}

// optional .ce.nbapi.dot1x dot1x = 6;
inline bool security_message::has_dot1x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void security_message::set_has_dot1x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void security_message::clear_has_dot1x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void security_message::clear_dot1x() {
  if (dot1x_ != NULL) dot1x_->Clear();
  clear_has_dot1x();
}
inline const ::ce::nbapi::dot1x& security_message::_internal_dot1x() const {
  return *dot1x_;
}
inline const ::ce::nbapi::dot1x& security_message::dot1x() const {
  const ::ce::nbapi::dot1x* p = dot1x_;
  // @@protoc_insertion_point(field_get:ce.nbapi.security_message.dot1x)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::dot1x*>(
      &::ce::nbapi::_dot1x_default_instance_);
}
inline ::ce::nbapi::dot1x* security_message::release_dot1x() {
  // @@protoc_insertion_point(field_release:ce.nbapi.security_message.dot1x)
  clear_has_dot1x();
  ::ce::nbapi::dot1x* temp = dot1x_;
  dot1x_ = NULL;
  return temp;
}
inline ::ce::nbapi::dot1x* security_message::mutable_dot1x() {
  set_has_dot1x();
  if (dot1x_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::dot1x>(GetArenaNoVirtual());
    dot1x_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.security_message.dot1x)
  return dot1x_;
}
inline void security_message::set_allocated_dot1x(::ce::nbapi::dot1x* dot1x) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dot1x_;
  }
  if (dot1x) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dot1x = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dot1x, submessage_arena);
    }
    set_has_dot1x();
  } else {
    clear_has_dot1x();
  }
  dot1x_ = dot1x;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.security_message.dot1x)
}

// -------------------------------------------------------------------

// spectrum_info

// optional .ce.nbapi.mac_address ap_mac = 1;
inline bool spectrum_info::has_ap_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void spectrum_info::set_has_ap_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void spectrum_info::clear_has_ap_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void spectrum_info::clear_ap_mac() {
  if (ap_mac_ != NULL) ap_mac_->Clear();
  clear_has_ap_mac();
}
inline const ::ce::nbapi::mac_address& spectrum_info::_internal_ap_mac() const {
  return *ap_mac_;
}
inline const ::ce::nbapi::mac_address& spectrum_info::ap_mac() const {
  const ::ce::nbapi::mac_address* p = ap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.spectrum_info.ap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* spectrum_info::release_ap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.spectrum_info.ap_mac)
  clear_has_ap_mac();
  ::ce::nbapi::mac_address* temp = ap_mac_;
  ap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* spectrum_info::mutable_ap_mac() {
  set_has_ap_mac();
  if (ap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.spectrum_info.ap_mac)
  return ap_mac_;
}
inline void spectrum_info::set_allocated_ap_mac(::ce::nbapi::mac_address* ap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_mac_;
  }
  if (ap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_mac, submessage_arena);
    }
    set_has_ap_mac();
  } else {
    clear_has_ap_mac();
  }
  ap_mac_ = ap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.spectrum_info.ap_mac)
}

// optional uint32 radio_number = 2;
inline bool spectrum_info::has_radio_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void spectrum_info::set_has_radio_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void spectrum_info::clear_has_radio_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void spectrum_info::clear_radio_number() {
  radio_number_ = 0u;
  clear_has_radio_number();
}
inline ::google::protobuf::uint32 spectrum_info::radio_number() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.spectrum_info.radio_number)
  return radio_number_;
}
inline void spectrum_info::set_radio_number(::google::protobuf::uint32 value) {
  set_has_radio_number();
  radio_number_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.spectrum_info.radio_number)
}

// optional uint32 dev_id = 3;
inline bool spectrum_info::has_dev_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void spectrum_info::set_has_dev_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void spectrum_info::clear_has_dev_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void spectrum_info::clear_dev_id() {
  dev_id_ = 0u;
  clear_has_dev_id();
}
inline ::google::protobuf::uint32 spectrum_info::dev_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.spectrum_info.dev_id)
  return dev_id_;
}
inline void spectrum_info::set_dev_id(::google::protobuf::uint32 value) {
  set_has_dev_id();
  dev_id_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.spectrum_info.dev_id)
}

// optional uint32 dev_type = 4;
inline bool spectrum_info::has_dev_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void spectrum_info::set_has_dev_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void spectrum_info::clear_has_dev_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void spectrum_info::clear_dev_type() {
  dev_type_ = 0u;
  clear_has_dev_type();
}
inline ::google::protobuf::uint32 spectrum_info::dev_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.spectrum_info.dev_type)
  return dev_type_;
}
inline void spectrum_info::set_dev_type(::google::protobuf::uint32 value) {
  set_has_dev_type();
  dev_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.spectrum_info.dev_type)
}

// optional uint32 low_ch = 5;
inline bool spectrum_info::has_low_ch() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void spectrum_info::set_has_low_ch() {
  _has_bits_[0] |= 0x00000010u;
}
inline void spectrum_info::clear_has_low_ch() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void spectrum_info::clear_low_ch() {
  low_ch_ = 0u;
  clear_has_low_ch();
}
inline ::google::protobuf::uint32 spectrum_info::low_ch() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.spectrum_info.low_ch)
  return low_ch_;
}
inline void spectrum_info::set_low_ch(::google::protobuf::uint32 value) {
  set_has_low_ch();
  low_ch_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.spectrum_info.low_ch)
}

// optional uint32 high_ch = 6;
inline bool spectrum_info::has_high_ch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void spectrum_info::set_has_high_ch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void spectrum_info::clear_has_high_ch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void spectrum_info::clear_high_ch() {
  high_ch_ = 0u;
  clear_has_high_ch();
}
inline ::google::protobuf::uint32 spectrum_info::high_ch() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.spectrum_info.high_ch)
  return high_ch_;
}
inline void spectrum_info::set_high_ch(::google::protobuf::uint32 value) {
  set_has_high_ch();
  high_ch_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.spectrum_info.high_ch)
}

// optional uint32 signal = 7;
inline bool spectrum_info::has_signal() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void spectrum_info::set_has_signal() {
  _has_bits_[0] |= 0x00000040u;
}
inline void spectrum_info::clear_has_signal() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void spectrum_info::clear_signal() {
  signal_ = 0u;
  clear_has_signal();
}
inline ::google::protobuf::uint32 spectrum_info::signal() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.spectrum_info.signal)
  return signal_;
}
inline void spectrum_info::set_signal(::google::protobuf::uint32 value) {
  set_has_signal();
  signal_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.spectrum_info.signal)
}

// optional uint32 duty_cycle = 8;
inline bool spectrum_info::has_duty_cycle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void spectrum_info::set_has_duty_cycle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void spectrum_info::clear_has_duty_cycle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void spectrum_info::clear_duty_cycle() {
  duty_cycle_ = 0u;
  clear_has_duty_cycle();
}
inline ::google::protobuf::uint32 spectrum_info::duty_cycle() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.spectrum_info.duty_cycle)
  return duty_cycle_;
}
inline void spectrum_info::set_duty_cycle(::google::protobuf::uint32 value) {
  set_has_duty_cycle();
  duty_cycle_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.spectrum_info.duty_cycle)
}

// optional uint32 center_freq = 9;
inline bool spectrum_info::has_center_freq() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void spectrum_info::set_has_center_freq() {
  _has_bits_[0] |= 0x00000100u;
}
inline void spectrum_info::clear_has_center_freq() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void spectrum_info::clear_center_freq() {
  center_freq_ = 0u;
  clear_has_center_freq();
}
inline ::google::protobuf::uint32 spectrum_info::center_freq() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.spectrum_info.center_freq)
  return center_freq_;
}
inline void spectrum_info::set_center_freq(::google::protobuf::uint32 value) {
  set_has_center_freq();
  center_freq_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.spectrum_info.center_freq)
}

// optional uint64 timestamp = 10;
inline bool spectrum_info::has_timestamp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void spectrum_info::set_has_timestamp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void spectrum_info::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void spectrum_info::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 spectrum_info::timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.spectrum_info.timestamp)
  return timestamp_;
}
inline void spectrum_info::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.spectrum_info.timestamp)
}

// optional uint64 active_time = 11;
inline bool spectrum_info::has_active_time() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void spectrum_info::set_has_active_time() {
  _has_bits_[0] |= 0x00000400u;
}
inline void spectrum_info::clear_has_active_time() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void spectrum_info::clear_active_time() {
  active_time_ = GOOGLE_ULONGLONG(0);
  clear_has_active_time();
}
inline ::google::protobuf::uint64 spectrum_info::active_time() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.spectrum_info.active_time)
  return active_time_;
}
inline void spectrum_info::set_active_time(::google::protobuf::uint64 value) {
  set_has_active_time();
  active_time_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.spectrum_info.active_time)
}

// -------------------------------------------------------------------

// rogue_info

// optional .ce.nbapi.mac_address monitor_mac = 1;
inline bool rogue_info::has_monitor_mac() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rogue_info::set_has_monitor_mac() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rogue_info::clear_has_monitor_mac() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rogue_info::clear_monitor_mac() {
  if (monitor_mac_ != NULL) monitor_mac_->Clear();
  clear_has_monitor_mac();
}
inline const ::ce::nbapi::mac_address& rogue_info::_internal_monitor_mac() const {
  return *monitor_mac_;
}
inline const ::ce::nbapi::mac_address& rogue_info::monitor_mac() const {
  const ::ce::nbapi::mac_address* p = monitor_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.rogue_info.monitor_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* rogue_info::release_monitor_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.rogue_info.monitor_mac)
  clear_has_monitor_mac();
  ::ce::nbapi::mac_address* temp = monitor_mac_;
  monitor_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* rogue_info::mutable_monitor_mac() {
  set_has_monitor_mac();
  if (monitor_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    monitor_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.rogue_info.monitor_mac)
  return monitor_mac_;
}
inline void rogue_info::set_allocated_monitor_mac(::ce::nbapi::mac_address* monitor_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete monitor_mac_;
  }
  if (monitor_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      monitor_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, monitor_mac, submessage_arena);
    }
    set_has_monitor_mac();
  } else {
    clear_has_monitor_mac();
  }
  monitor_mac_ = monitor_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.rogue_info.monitor_mac)
}

// optional .ce.nbapi.mac_address heard_mac = 2;
inline bool rogue_info::has_heard_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rogue_info::set_has_heard_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rogue_info::clear_has_heard_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rogue_info::clear_heard_mac() {
  if (heard_mac_ != NULL) heard_mac_->Clear();
  clear_has_heard_mac();
}
inline const ::ce::nbapi::mac_address& rogue_info::_internal_heard_mac() const {
  return *heard_mac_;
}
inline const ::ce::nbapi::mac_address& rogue_info::heard_mac() const {
  const ::ce::nbapi::mac_address* p = heard_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.rogue_info.heard_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* rogue_info::release_heard_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.rogue_info.heard_mac)
  clear_has_heard_mac();
  ::ce::nbapi::mac_address* temp = heard_mac_;
  heard_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* rogue_info::mutable_heard_mac() {
  set_has_heard_mac();
  if (heard_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    heard_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.rogue_info.heard_mac)
  return heard_mac_;
}
inline void rogue_info::set_allocated_heard_mac(::ce::nbapi::mac_address* heard_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete heard_mac_;
  }
  if (heard_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      heard_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, heard_mac, submessage_arena);
    }
    set_has_heard_mac();
  } else {
    clear_has_heard_mac();
  }
  heard_mac_ = heard_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.rogue_info.heard_mac)
}

// optional uint32 monitor_channel = 3;
inline bool rogue_info::has_monitor_channel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void rogue_info::set_has_monitor_channel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void rogue_info::clear_has_monitor_channel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void rogue_info::clear_monitor_channel() {
  monitor_channel_ = 0u;
  clear_has_monitor_channel();
}
inline ::google::protobuf::uint32 rogue_info::monitor_channel() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.rogue_info.monitor_channel)
  return monitor_channel_;
}
inline void rogue_info::set_monitor_channel(::google::protobuf::uint32 value) {
  set_has_monitor_channel();
  monitor_channel_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.rogue_info.monitor_channel)
}

// optional uint32 is_ap = 4;
inline bool rogue_info::has_is_ap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void rogue_info::set_has_is_ap() {
  _has_bits_[0] |= 0x00000008u;
}
inline void rogue_info::clear_has_is_ap() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void rogue_info::clear_is_ap() {
  is_ap_ = 0u;
  clear_has_is_ap();
}
inline ::google::protobuf::uint32 rogue_info::is_ap() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.rogue_info.is_ap)
  return is_ap_;
}
inline void rogue_info::set_is_ap(::google::protobuf::uint32 value) {
  set_has_is_ap();
  is_ap_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.rogue_info.is_ap)
}

// -------------------------------------------------------------------

// key_value_type

// optional string key = 1;
inline bool key_value_type::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void key_value_type::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void key_value_type::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void key_value_type::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& key_value_type::key() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.key_value_type.key)
  return key_.GetNoArena();
}
inline void key_value_type::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.key_value_type.key)
}
#if LANG_CXX11
inline void key_value_type::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.key_value_type.key)
}
#endif
inline void key_value_type::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.key_value_type.key)
}
inline void key_value_type::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.key_value_type.key)
}
inline ::std::string* key_value_type::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.key_value_type.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* key_value_type::release_key() {
  // @@protoc_insertion_point(field_release:ce.nbapi.key_value_type.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void key_value_type::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.key_value_type.key)
}

// optional string value = 2;
inline bool key_value_type::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void key_value_type::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void key_value_type::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void key_value_type::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& key_value_type::value() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.key_value_type.value)
  return value_.GetNoArena();
}
inline void key_value_type::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.key_value_type.value)
}
#if LANG_CXX11
inline void key_value_type::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.key_value_type.value)
}
#endif
inline void key_value_type::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.key_value_type.value)
}
inline void key_value_type::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.key_value_type.value)
}
inline ::std::string* key_value_type::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.key_value_type.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* key_value_type::release_value() {
  // @@protoc_insertion_point(field_release:ce.nbapi.key_value_type.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void key_value_type::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.key_value_type.value)
}

// -------------------------------------------------------------------

// info

// optional .ce.nbapi.info.mode_type current_mode = 1;
inline bool info::has_current_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void info::set_has_current_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void info::clear_has_current_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void info::clear_current_mode() {
  current_mode_ = 0;
  clear_has_current_mode();
}
inline ::ce::nbapi::info_mode_type info::current_mode() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.info.current_mode)
  return static_cast< ::ce::nbapi::info_mode_type >(current_mode_);
}
inline void info::set_current_mode(::ce::nbapi::info_mode_type value) {
  assert(::ce::nbapi::info_mode_type_IsValid(value));
  set_has_current_mode();
  current_mode_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.info.current_mode)
}

// optional bool license_valid = 2;
inline bool info::has_license_valid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void info::set_has_license_valid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void info::clear_has_license_valid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void info::clear_license_valid() {
  license_valid_ = false;
  clear_has_license_valid();
}
inline bool info::license_valid() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.info.license_valid)
  return license_valid_;
}
inline void info::set_license_valid(bool value) {
  set_has_license_valid();
  license_valid_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.info.license_valid)
}

// repeated .ce.nbapi.key_value_type key_value = 3;
inline int info::key_value_size() const {
  return key_value_.size();
}
inline void info::clear_key_value() {
  key_value_.Clear();
}
inline ::ce::nbapi::key_value_type* info::mutable_key_value(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.info.key_value)
  return key_value_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::key_value_type >*
info::mutable_key_value() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.info.key_value)
  return &key_value_;
}
inline const ::ce::nbapi::key_value_type& info::key_value(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.info.key_value)
  return key_value_.Get(index);
}
inline ::ce::nbapi::key_value_type* info::add_key_value() {
  // @@protoc_insertion_point(field_add:ce.nbapi.info.key_value)
  return key_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::key_value_type >&
info::key_value() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.info.key_value)
  return key_value_;
}

// -------------------------------------------------------------------

// controller_info

// required .ce.nbapi.ip_address controller_ip_address = 1;
inline bool controller_info::has_controller_ip_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void controller_info::set_has_controller_ip_address() {
  _has_bits_[0] |= 0x00000001u;
}
inline void controller_info::clear_has_controller_ip_address() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void controller_info::clear_controller_ip_address() {
  if (controller_ip_address_ != NULL) controller_ip_address_->Clear();
  clear_has_controller_ip_address();
}
inline const ::ce::nbapi::ip_address& controller_info::_internal_controller_ip_address() const {
  return *controller_ip_address_;
}
inline const ::ce::nbapi::ip_address& controller_info::controller_ip_address() const {
  const ::ce::nbapi::ip_address* p = controller_ip_address_;
  // @@protoc_insertion_point(field_get:ce.nbapi.controller_info.controller_ip_address)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* controller_info::release_controller_ip_address() {
  // @@protoc_insertion_point(field_release:ce.nbapi.controller_info.controller_ip_address)
  clear_has_controller_ip_address();
  ::ce::nbapi::ip_address* temp = controller_ip_address_;
  controller_ip_address_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* controller_info::mutable_controller_ip_address() {
  set_has_controller_ip_address();
  if (controller_ip_address_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    controller_ip_address_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.controller_info.controller_ip_address)
  return controller_ip_address_;
}
inline void controller_info::set_allocated_controller_ip_address(::ce::nbapi::ip_address* controller_ip_address) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete controller_ip_address_;
  }
  if (controller_ip_address) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      controller_ip_address = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controller_ip_address, submessage_arena);
    }
    set_has_controller_ip_address();
  } else {
    clear_has_controller_ip_address();
  }
  controller_ip_address_ = controller_ip_address;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.controller_info.controller_ip_address)
}

// repeated .ce.nbapi.access_point access_points = 2;
inline int controller_info::access_points_size() const {
  return access_points_.size();
}
inline void controller_info::clear_access_points() {
  access_points_.Clear();
}
inline ::ce::nbapi::access_point* controller_info::mutable_access_points(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.controller_info.access_points)
  return access_points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::access_point >*
controller_info::mutable_access_points() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.controller_info.access_points)
  return &access_points_;
}
inline const ::ce::nbapi::access_point& controller_info::access_points(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.controller_info.access_points)
  return access_points_.Get(index);
}
inline ::ce::nbapi::access_point* controller_info::add_access_points() {
  // @@protoc_insertion_point(field_add:ce.nbapi.controller_info.access_points)
  return access_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::access_point >&
controller_info::access_points() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.controller_info.access_points)
  return access_points_;
}

// -------------------------------------------------------------------

// cluster_info

// optional string cluster_key = 1;
inline bool cluster_info::has_cluster_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void cluster_info::set_has_cluster_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void cluster_info::clear_has_cluster_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void cluster_info::clear_cluster_key() {
  cluster_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cluster_key();
}
inline const ::std::string& cluster_info::cluster_key() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.cluster_info.cluster_key)
  return cluster_key_.GetNoArena();
}
inline void cluster_info::set_cluster_key(const ::std::string& value) {
  set_has_cluster_key();
  cluster_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.cluster_info.cluster_key)
}
#if LANG_CXX11
inline void cluster_info::set_cluster_key(::std::string&& value) {
  set_has_cluster_key();
  cluster_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.cluster_info.cluster_key)
}
#endif
inline void cluster_info::set_cluster_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cluster_key();
  cluster_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.cluster_info.cluster_key)
}
inline void cluster_info::set_cluster_key(const char* value, size_t size) {
  set_has_cluster_key();
  cluster_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.cluster_info.cluster_key)
}
inline ::std::string* cluster_info::mutable_cluster_key() {
  set_has_cluster_key();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.cluster_info.cluster_key)
  return cluster_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* cluster_info::release_cluster_key() {
  // @@protoc_insertion_point(field_release:ce.nbapi.cluster_info.cluster_key)
  if (!has_cluster_key()) {
    return NULL;
  }
  clear_has_cluster_key();
  return cluster_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void cluster_info::set_allocated_cluster_key(::std::string* cluster_key) {
  if (cluster_key != NULL) {
    set_has_cluster_key();
  } else {
    clear_has_cluster_key();
  }
  cluster_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster_key);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.cluster_info.cluster_key)
}

// optional string cluster_name = 2;
inline bool cluster_info::has_cluster_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void cluster_info::set_has_cluster_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void cluster_info::clear_has_cluster_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void cluster_info::clear_cluster_name() {
  cluster_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_cluster_name();
}
inline const ::std::string& cluster_info::cluster_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.cluster_info.cluster_name)
  return cluster_name_.GetNoArena();
}
inline void cluster_info::set_cluster_name(const ::std::string& value) {
  set_has_cluster_name();
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.cluster_info.cluster_name)
}
#if LANG_CXX11
inline void cluster_info::set_cluster_name(::std::string&& value) {
  set_has_cluster_name();
  cluster_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.cluster_info.cluster_name)
}
#endif
inline void cluster_info::set_cluster_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_cluster_name();
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.cluster_info.cluster_name)
}
inline void cluster_info::set_cluster_name(const char* value, size_t size) {
  set_has_cluster_name();
  cluster_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.cluster_info.cluster_name)
}
inline ::std::string* cluster_info::mutable_cluster_name() {
  set_has_cluster_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.cluster_info.cluster_name)
  return cluster_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* cluster_info::release_cluster_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.cluster_info.cluster_name)
  if (!has_cluster_name()) {
    return NULL;
  }
  clear_has_cluster_name();
  return cluster_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void cluster_info::set_allocated_cluster_name(::std::string* cluster_name) {
  if (cluster_name != NULL) {
    set_has_cluster_name();
  } else {
    clear_has_cluster_name();
  }
  cluster_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cluster_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.cluster_info.cluster_name)
}

// optional string organization = 3;
inline bool cluster_info::has_organization() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void cluster_info::set_has_organization() {
  _has_bits_[0] |= 0x00000004u;
}
inline void cluster_info::clear_has_organization() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void cluster_info::clear_organization() {
  organization_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_organization();
}
inline const ::std::string& cluster_info::organization() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.cluster_info.organization)
  return organization_.GetNoArena();
}
inline void cluster_info::set_organization(const ::std::string& value) {
  set_has_organization();
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.cluster_info.organization)
}
#if LANG_CXX11
inline void cluster_info::set_organization(::std::string&& value) {
  set_has_organization();
  organization_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.cluster_info.organization)
}
#endif
inline void cluster_info::set_organization(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_organization();
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.cluster_info.organization)
}
inline void cluster_info::set_organization(const char* value, size_t size) {
  set_has_organization();
  organization_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.cluster_info.organization)
}
inline ::std::string* cluster_info::mutable_organization() {
  set_has_organization();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.cluster_info.organization)
  return organization_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* cluster_info::release_organization() {
  // @@protoc_insertion_point(field_release:ce.nbapi.cluster_info.organization)
  if (!has_organization()) {
    return NULL;
  }
  clear_has_organization();
  return organization_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void cluster_info::set_allocated_organization(::std::string* organization) {
  if (organization != NULL) {
    set_has_organization();
  } else {
    clear_has_organization();
  }
  organization_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), organization);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.cluster_info.organization)
}

// optional .ce.nbapi.ip_address cluster_ip = 4;
inline bool cluster_info::has_cluster_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void cluster_info::set_has_cluster_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void cluster_info::clear_has_cluster_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void cluster_info::clear_cluster_ip() {
  if (cluster_ip_ != NULL) cluster_ip_->Clear();
  clear_has_cluster_ip();
}
inline const ::ce::nbapi::ip_address& cluster_info::_internal_cluster_ip() const {
  return *cluster_ip_;
}
inline const ::ce::nbapi::ip_address& cluster_info::cluster_ip() const {
  const ::ce::nbapi::ip_address* p = cluster_ip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.cluster_info.cluster_ip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* cluster_info::release_cluster_ip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.cluster_info.cluster_ip)
  clear_has_cluster_ip();
  ::ce::nbapi::ip_address* temp = cluster_ip_;
  cluster_ip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* cluster_info::mutable_cluster_ip() {
  set_has_cluster_ip();
  if (cluster_ip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    cluster_ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.cluster_info.cluster_ip)
  return cluster_ip_;
}
inline void cluster_info::set_allocated_cluster_ip(::ce::nbapi::ip_address* cluster_ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cluster_ip_;
  }
  if (cluster_ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cluster_ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cluster_ip, submessage_arena);
    }
    set_has_cluster_ip();
  } else {
    clear_has_cluster_ip();
  }
  cluster_ip_ = cluster_ip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.cluster_info.cluster_ip)
}

// repeated .ce.nbapi.access_point access_points = 5;
inline int cluster_info::access_points_size() const {
  return access_points_.size();
}
inline void cluster_info::clear_access_points() {
  access_points_.Clear();
}
inline ::ce::nbapi::access_point* cluster_info::mutable_access_points(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.cluster_info.access_points)
  return access_points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::access_point >*
cluster_info::mutable_access_points() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.cluster_info.access_points)
  return &access_points_;
}
inline const ::ce::nbapi::access_point& cluster_info::access_points(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.cluster_info.access_points)
  return access_points_.Get(index);
}
inline ::ce::nbapi::access_point* cluster_info::add_access_points() {
  // @@protoc_insertion_point(field_add:ce.nbapi.cluster_info.access_points)
  return access_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::access_point >&
cluster_info::access_points() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.cluster_info.access_points)
  return access_points_;
}

// -------------------------------------------------------------------

// topology

// optional .ce.nbapi.controller_info controller = 2;
inline bool topology::has_controller() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void topology::set_has_controller() {
  _has_bits_[0] |= 0x00000001u;
}
inline void topology::clear_has_controller() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void topology::clear_controller() {
  if (controller_ != NULL) controller_->Clear();
  clear_has_controller();
}
inline const ::ce::nbapi::controller_info& topology::_internal_controller() const {
  return *controller_;
}
inline const ::ce::nbapi::controller_info& topology::controller() const {
  const ::ce::nbapi::controller_info* p = controller_;
  // @@protoc_insertion_point(field_get:ce.nbapi.topology.controller)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::controller_info*>(
      &::ce::nbapi::_controller_info_default_instance_);
}
inline ::ce::nbapi::controller_info* topology::release_controller() {
  // @@protoc_insertion_point(field_release:ce.nbapi.topology.controller)
  clear_has_controller();
  ::ce::nbapi::controller_info* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline ::ce::nbapi::controller_info* topology::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::controller_info>(GetArenaNoVirtual());
    controller_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.topology.controller)
  return controller_;
}
inline void topology::set_allocated_controller(::ce::nbapi::controller_info* controller) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete controller_;
  }
  if (controller) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      controller = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controller, submessage_arena);
    }
    set_has_controller();
  } else {
    clear_has_controller();
  }
  controller_ = controller;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.topology.controller)
}

// optional .ce.nbapi.cluster_info cluster = 3;
inline bool topology::has_cluster() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void topology::set_has_cluster() {
  _has_bits_[0] |= 0x00000002u;
}
inline void topology::clear_has_cluster() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void topology::clear_cluster() {
  if (cluster_ != NULL) cluster_->Clear();
  clear_has_cluster();
}
inline const ::ce::nbapi::cluster_info& topology::_internal_cluster() const {
  return *cluster_;
}
inline const ::ce::nbapi::cluster_info& topology::cluster() const {
  const ::ce::nbapi::cluster_info* p = cluster_;
  // @@protoc_insertion_point(field_get:ce.nbapi.topology.cluster)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::cluster_info*>(
      &::ce::nbapi::_cluster_info_default_instance_);
}
inline ::ce::nbapi::cluster_info* topology::release_cluster() {
  // @@protoc_insertion_point(field_release:ce.nbapi.topology.cluster)
  clear_has_cluster();
  ::ce::nbapi::cluster_info* temp = cluster_;
  cluster_ = NULL;
  return temp;
}
inline ::ce::nbapi::cluster_info* topology::mutable_cluster() {
  set_has_cluster();
  if (cluster_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::cluster_info>(GetArenaNoVirtual());
    cluster_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.topology.cluster)
  return cluster_;
}
inline void topology::set_allocated_cluster(::ce::nbapi::cluster_info* cluster) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cluster_;
  }
  if (cluster) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cluster = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cluster, submessage_arena);
    }
    set_has_cluster();
  } else {
    clear_has_cluster();
  }
  cluster_ = cluster;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.topology.cluster)
}

// -------------------------------------------------------------------

// ap_location

// required .ce.nbapi.mac_address ap_eth_mac = 1;
inline bool ap_location::has_ap_eth_mac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ap_location::set_has_ap_eth_mac() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ap_location::clear_has_ap_eth_mac() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ap_location::clear_ap_eth_mac() {
  if (ap_eth_mac_ != NULL) ap_eth_mac_->Clear();
  clear_has_ap_eth_mac();
}
inline const ::ce::nbapi::mac_address& ap_location::_internal_ap_eth_mac() const {
  return *ap_eth_mac_;
}
inline const ::ce::nbapi::mac_address& ap_location::ap_eth_mac() const {
  const ::ce::nbapi::mac_address* p = ap_eth_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_location.ap_eth_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* ap_location::release_ap_eth_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.ap_location.ap_eth_mac)
  clear_has_ap_eth_mac();
  ::ce::nbapi::mac_address* temp = ap_eth_mac_;
  ap_eth_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* ap_location::mutable_ap_eth_mac() {
  set_has_ap_eth_mac();
  if (ap_eth_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_eth_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ap_location.ap_eth_mac)
  return ap_eth_mac_;
}
inline void ap_location::set_allocated_ap_eth_mac(::ce::nbapi::mac_address* ap_eth_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_eth_mac_;
  }
  if (ap_eth_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_eth_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_eth_mac, submessage_arena);
    }
    set_has_ap_eth_mac();
  } else {
    clear_has_ap_eth_mac();
  }
  ap_eth_mac_ = ap_eth_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.ap_location.ap_eth_mac)
}

// optional bytes campus_id = 2;
inline bool ap_location::has_campus_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ap_location::set_has_campus_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ap_location::clear_has_campus_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ap_location::clear_campus_id() {
  campus_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_campus_id();
}
inline const ::std::string& ap_location::campus_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_location.campus_id)
  return campus_id_.GetNoArena();
}
inline void ap_location::set_campus_id(const ::std::string& value) {
  set_has_campus_id();
  campus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_location.campus_id)
}
#if LANG_CXX11
inline void ap_location::set_campus_id(::std::string&& value) {
  set_has_campus_id();
  campus_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.ap_location.campus_id)
}
#endif
inline void ap_location::set_campus_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_campus_id();
  campus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.ap_location.campus_id)
}
inline void ap_location::set_campus_id(const void* value, size_t size) {
  set_has_campus_id();
  campus_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.ap_location.campus_id)
}
inline ::std::string* ap_location::mutable_campus_id() {
  set_has_campus_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ap_location.campus_id)
  return campus_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ap_location::release_campus_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.ap_location.campus_id)
  if (!has_campus_id()) {
    return NULL;
  }
  clear_has_campus_id();
  return campus_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ap_location::set_allocated_campus_id(::std::string* campus_id) {
  if (campus_id != NULL) {
    set_has_campus_id();
  } else {
    clear_has_campus_id();
  }
  campus_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), campus_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.ap_location.campus_id)
}

// optional bytes building_id = 3;
inline bool ap_location::has_building_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ap_location::set_has_building_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ap_location::clear_has_building_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ap_location::clear_building_id() {
  building_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_building_id();
}
inline const ::std::string& ap_location::building_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_location.building_id)
  return building_id_.GetNoArena();
}
inline void ap_location::set_building_id(const ::std::string& value) {
  set_has_building_id();
  building_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_location.building_id)
}
#if LANG_CXX11
inline void ap_location::set_building_id(::std::string&& value) {
  set_has_building_id();
  building_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.ap_location.building_id)
}
#endif
inline void ap_location::set_building_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_building_id();
  building_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.ap_location.building_id)
}
inline void ap_location::set_building_id(const void* value, size_t size) {
  set_has_building_id();
  building_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.ap_location.building_id)
}
inline ::std::string* ap_location::mutable_building_id() {
  set_has_building_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ap_location.building_id)
  return building_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ap_location::release_building_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.ap_location.building_id)
  if (!has_building_id()) {
    return NULL;
  }
  clear_has_building_id();
  return building_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ap_location::set_allocated_building_id(::std::string* building_id) {
  if (building_id != NULL) {
    set_has_building_id();
  } else {
    clear_has_building_id();
  }
  building_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), building_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.ap_location.building_id)
}

// optional bytes floor_id = 4;
inline bool ap_location::has_floor_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ap_location::set_has_floor_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ap_location::clear_has_floor_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ap_location::clear_floor_id() {
  floor_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_floor_id();
}
inline const ::std::string& ap_location::floor_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_location.floor_id)
  return floor_id_.GetNoArena();
}
inline void ap_location::set_floor_id(const ::std::string& value) {
  set_has_floor_id();
  floor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_location.floor_id)
}
#if LANG_CXX11
inline void ap_location::set_floor_id(::std::string&& value) {
  set_has_floor_id();
  floor_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.ap_location.floor_id)
}
#endif
inline void ap_location::set_floor_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_floor_id();
  floor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.ap_location.floor_id)
}
inline void ap_location::set_floor_id(const void* value, size_t size) {
  set_has_floor_id();
  floor_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.ap_location.floor_id)
}
inline ::std::string* ap_location::mutable_floor_id() {
  set_has_floor_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.ap_location.floor_id)
  return floor_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ap_location::release_floor_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.ap_location.floor_id)
  if (!has_floor_id()) {
    return NULL;
  }
  clear_has_floor_id();
  return floor_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ap_location::set_allocated_floor_id(::std::string* floor_id) {
  if (floor_id != NULL) {
    set_has_floor_id();
  } else {
    clear_has_floor_id();
  }
  floor_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), floor_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.ap_location.floor_id)
}

// optional double longitude = 5;
inline bool ap_location::has_longitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ap_location::set_has_longitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ap_location::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ap_location::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double ap_location::longitude() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_location.longitude)
  return longitude_;
}
inline void ap_location::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_location.longitude)
}

// optional double latitude = 6;
inline bool ap_location::has_latitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ap_location::set_has_latitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ap_location::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ap_location::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double ap_location::latitude() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_location.latitude)
  return latitude_;
}
inline void ap_location::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_location.latitude)
}

// optional double ap_x = 7;
inline bool ap_location::has_ap_x() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ap_location::set_has_ap_x() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ap_location::clear_has_ap_x() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ap_location::clear_ap_x() {
  ap_x_ = 0;
  clear_has_ap_x();
}
inline double ap_location::ap_x() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_location.ap_x)
  return ap_x_;
}
inline void ap_location::set_ap_x(double value) {
  set_has_ap_x();
  ap_x_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_location.ap_x)
}

// optional double ap_y = 8;
inline bool ap_location::has_ap_y() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ap_location::set_has_ap_y() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ap_location::clear_has_ap_y() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ap_location::clear_ap_y() {
  ap_y_ = 0;
  clear_has_ap_y();
}
inline double ap_location::ap_y() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.ap_location.ap_y)
  return ap_y_;
}
inline void ap_location::set_ap_y(double value) {
  set_has_ap_y();
  ap_y_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.ap_location.ap_y)
}

// -------------------------------------------------------------------

// nb_event

// optional uint64 seq = 1;
inline bool nb_event::has_seq() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void nb_event::set_has_seq() {
  _has_bits_[1] |= 0x00020000u;
}
inline void nb_event::clear_has_seq() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void nb_event::clear_seq() {
  seq_ = GOOGLE_ULONGLONG(0);
  clear_has_seq();
}
inline ::google::protobuf::uint64 nb_event::seq() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.seq)
  return seq_;
}
inline void nb_event::set_seq(::google::protobuf::uint64 value) {
  set_has_seq();
  seq_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.nb_event.seq)
}

// optional uint32 timestamp = 2;
inline bool nb_event::has_timestamp() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void nb_event::set_has_timestamp() {
  _has_bits_[1] |= 0x00040000u;
}
inline void nb_event::clear_has_timestamp() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void nb_event::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 nb_event::timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.timestamp)
  return timestamp_;
}
inline void nb_event::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.nb_event.timestamp)
}

// optional .ce.nbapi.nb_event.event_operation op = 3;
inline bool nb_event::has_op() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void nb_event::set_has_op() {
  _has_bits_[1] |= 0x00080000u;
}
inline void nb_event::clear_has_op() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void nb_event::clear_op() {
  op_ = 0;
  clear_has_op();
}
inline ::ce::nbapi::nb_event_event_operation nb_event::op() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.op)
  return static_cast< ::ce::nbapi::nb_event_event_operation >(op_);
}
inline void nb_event::set_op(::ce::nbapi::nb_event_event_operation value) {
  assert(::ce::nbapi::nb_event_event_operation_IsValid(value));
  set_has_op();
  op_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.nb_event.op)
}

// optional uint64 topic_seq = 4;
inline bool nb_event::has_topic_seq() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void nb_event::set_has_topic_seq() {
  _has_bits_[1] |= 0x00100000u;
}
inline void nb_event::clear_has_topic_seq() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void nb_event::clear_topic_seq() {
  topic_seq_ = GOOGLE_ULONGLONG(0);
  clear_has_topic_seq();
}
inline ::google::protobuf::uint64 nb_event::topic_seq() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.topic_seq)
  return topic_seq_;
}
inline void nb_event::set_topic_seq(::google::protobuf::uint64 value) {
  set_has_topic_seq();
  topic_seq_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.nb_event.topic_seq)
}

// optional bytes source_id = 5;
inline bool nb_event::has_source_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void nb_event::set_has_source_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void nb_event::clear_has_source_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void nb_event::clear_source_id() {
  source_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source_id();
}
inline const ::std::string& nb_event::source_id() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.source_id)
  return source_id_.GetNoArena();
}
inline void nb_event::set_source_id(const ::std::string& value) {
  set_has_source_id();
  source_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.nb_event.source_id)
}
#if LANG_CXX11
inline void nb_event::set_source_id(::std::string&& value) {
  set_has_source_id();
  source_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.nb_event.source_id)
}
#endif
inline void nb_event::set_source_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source_id();
  source_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.nb_event.source_id)
}
inline void nb_event::set_source_id(const void* value, size_t size) {
  set_has_source_id();
  source_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.nb_event.source_id)
}
inline ::std::string* nb_event::mutable_source_id() {
  set_has_source_id();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.source_id)
  return source_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* nb_event::release_source_id() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.source_id)
  if (!has_source_id()) {
    return NULL;
  }
  clear_has_source_id();
  return source_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void nb_event::set_allocated_source_id(::std::string* source_id) {
  if (source_id != NULL) {
    set_has_source_id();
  } else {
    clear_has_source_id();
  }
  source_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_id);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.source_id)
}

// optional .ce.nbapi.nb_event.license_info lic_info = 6 [default = hb_Dhak];
inline bool nb_event::has_lic_info() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void nb_event::set_has_lic_info() {
  _has_bits_[1] |= 0x00200000u;
}
inline void nb_event::clear_has_lic_info() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void nb_event::clear_lic_info() {
  lic_info_ = 10;
  clear_has_lic_info();
}
inline ::ce::nbapi::nb_event_license_info nb_event::lic_info() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.lic_info)
  return static_cast< ::ce::nbapi::nb_event_license_info >(lic_info_);
}
inline void nb_event::set_lic_info(::ce::nbapi::nb_event_license_info value) {
  assert(::ce::nbapi::nb_event_license_info_IsValid(value));
  set_has_lic_info();
  lic_info_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.nb_event.lic_info)
}

// optional .ce.nbapi.location location = 500;
inline bool nb_event::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void nb_event::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void nb_event::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void nb_event::clear_location() {
  if (location_ != NULL) location_->Clear();
  clear_has_location();
}
inline const ::ce::nbapi::location& nb_event::_internal_location() const {
  return *location_;
}
inline const ::ce::nbapi::location& nb_event::location() const {
  const ::ce::nbapi::location* p = location_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.location)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::location*>(
      &::ce::nbapi::_location_default_instance_);
}
inline ::ce::nbapi::location* nb_event::release_location() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.location)
  clear_has_location();
  ::ce::nbapi::location* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::ce::nbapi::location* nb_event::mutable_location() {
  set_has_location();
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::location>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.location)
  return location_;
}
inline void nb_event::set_allocated_location(::ce::nbapi::location* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    set_has_location();
  } else {
    clear_has_location();
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.location)
}

// optional .ce.nbapi.presence presence = 501;
inline bool nb_event::has_presence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void nb_event::set_has_presence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void nb_event::clear_has_presence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void nb_event::clear_presence() {
  if (presence_ != NULL) presence_->Clear();
  clear_has_presence();
}
inline const ::ce::nbapi::presence& nb_event::_internal_presence() const {
  return *presence_;
}
inline const ::ce::nbapi::presence& nb_event::presence() const {
  const ::ce::nbapi::presence* p = presence_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.presence)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::presence*>(
      &::ce::nbapi::_presence_default_instance_);
}
inline ::ce::nbapi::presence* nb_event::release_presence() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.presence)
  clear_has_presence();
  ::ce::nbapi::presence* temp = presence_;
  presence_ = NULL;
  return temp;
}
inline ::ce::nbapi::presence* nb_event::mutable_presence() {
  set_has_presence();
  if (presence_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::presence>(GetArenaNoVirtual());
    presence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.presence)
  return presence_;
}
inline void nb_event::set_allocated_presence(::ce::nbapi::presence* presence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete presence_;
  }
  if (presence) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      presence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, presence, submessage_arena);
    }
    set_has_presence();
  } else {
    clear_has_presence();
  }
  presence_ = presence;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.presence)
}

// optional .ce.nbapi.rssi rssi = 502;
inline bool nb_event::has_rssi() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void nb_event::set_has_rssi() {
  _has_bits_[0] |= 0x00000008u;
}
inline void nb_event::clear_has_rssi() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void nb_event::clear_rssi() {
  if (rssi_ != NULL) rssi_->Clear();
  clear_has_rssi();
}
inline const ::ce::nbapi::rssi& nb_event::_internal_rssi() const {
  return *rssi_;
}
inline const ::ce::nbapi::rssi& nb_event::rssi() const {
  const ::ce::nbapi::rssi* p = rssi_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.rssi)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::rssi*>(
      &::ce::nbapi::_rssi_default_instance_);
}
inline ::ce::nbapi::rssi* nb_event::release_rssi() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.rssi)
  clear_has_rssi();
  ::ce::nbapi::rssi* temp = rssi_;
  rssi_ = NULL;
  return temp;
}
inline ::ce::nbapi::rssi* nb_event::mutable_rssi() {
  set_has_rssi();
  if (rssi_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::rssi>(GetArenaNoVirtual());
    rssi_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.rssi)
  return rssi_;
}
inline void nb_event::set_allocated_rssi(::ce::nbapi::rssi* rssi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rssi_;
  }
  if (rssi) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rssi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rssi, submessage_arena);
    }
    set_has_rssi();
  } else {
    clear_has_rssi();
  }
  rssi_ = rssi;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.rssi)
}

// optional .ce.nbapi.station station = 503;
inline bool nb_event::has_station() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void nb_event::set_has_station() {
  _has_bits_[0] |= 0x00000010u;
}
inline void nb_event::clear_has_station() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void nb_event::clear_station() {
  if (station_ != NULL) station_->Clear();
  clear_has_station();
}
inline const ::ce::nbapi::station& nb_event::_internal_station() const {
  return *station_;
}
inline const ::ce::nbapi::station& nb_event::station() const {
  const ::ce::nbapi::station* p = station_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.station)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::station*>(
      &::ce::nbapi::_station_default_instance_);
}
inline ::ce::nbapi::station* nb_event::release_station() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.station)
  clear_has_station();
  ::ce::nbapi::station* temp = station_;
  station_ = NULL;
  return temp;
}
inline ::ce::nbapi::station* nb_event::mutable_station() {
  set_has_station();
  if (station_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::station>(GetArenaNoVirtual());
    station_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.station)
  return station_;
}
inline void nb_event::set_allocated_station(::ce::nbapi::station* station) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete station_;
  }
  if (station) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      station = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, station, submessage_arena);
    }
    set_has_station();
  } else {
    clear_has_station();
  }
  station_ = station;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.station)
}

// optional .ce.nbapi.radio radio = 505;
inline bool nb_event::has_radio() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void nb_event::set_has_radio() {
  _has_bits_[0] |= 0x00000020u;
}
inline void nb_event::clear_has_radio() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void nb_event::clear_radio() {
  if (radio_ != NULL) radio_->Clear();
  clear_has_radio();
}
inline const ::ce::nbapi::radio& nb_event::_internal_radio() const {
  return *radio_;
}
inline const ::ce::nbapi::radio& nb_event::radio() const {
  const ::ce::nbapi::radio* p = radio_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.radio)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::radio*>(
      &::ce::nbapi::_radio_default_instance_);
}
inline ::ce::nbapi::radio* nb_event::release_radio() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.radio)
  clear_has_radio();
  ::ce::nbapi::radio* temp = radio_;
  radio_ = NULL;
  return temp;
}
inline ::ce::nbapi::radio* nb_event::mutable_radio() {
  set_has_radio();
  if (radio_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::radio>(GetArenaNoVirtual());
    radio_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.radio)
  return radio_;
}
inline void nb_event::set_allocated_radio(::ce::nbapi::radio* radio) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radio_;
  }
  if (radio) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radio = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radio, submessage_arena);
    }
    set_has_radio();
  } else {
    clear_has_radio();
  }
  radio_ = radio;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.radio)
}

// optional .ce.nbapi.destination destination = 507;
inline bool nb_event::has_destination() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void nb_event::set_has_destination() {
  _has_bits_[0] |= 0x00000040u;
}
inline void nb_event::clear_has_destination() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void nb_event::clear_destination() {
  if (destination_ != NULL) destination_->Clear();
  clear_has_destination();
}
inline const ::ce::nbapi::destination& nb_event::_internal_destination() const {
  return *destination_;
}
inline const ::ce::nbapi::destination& nb_event::destination() const {
  const ::ce::nbapi::destination* p = destination_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.destination)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::destination*>(
      &::ce::nbapi::_destination_default_instance_);
}
inline ::ce::nbapi::destination* nb_event::release_destination() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.destination)
  clear_has_destination();
  ::ce::nbapi::destination* temp = destination_;
  destination_ = NULL;
  return temp;
}
inline ::ce::nbapi::destination* nb_event::mutable_destination() {
  set_has_destination();
  if (destination_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::destination>(GetArenaNoVirtual());
    destination_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.destination)
  return destination_;
}
inline void nb_event::set_allocated_destination(::ce::nbapi::destination* destination) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete destination_;
  }
  if (destination) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      destination = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, destination, submessage_arena);
    }
    set_has_destination();
  } else {
    clear_has_destination();
  }
  destination_ = destination;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.destination)
}

// optional .ce.nbapi.application application = 509;
inline bool nb_event::has_application() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void nb_event::set_has_application() {
  _has_bits_[0] |= 0x00000080u;
}
inline void nb_event::clear_has_application() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void nb_event::clear_application() {
  if (application_ != NULL) application_->Clear();
  clear_has_application();
}
inline const ::ce::nbapi::application& nb_event::_internal_application() const {
  return *application_;
}
inline const ::ce::nbapi::application& nb_event::application() const {
  const ::ce::nbapi::application* p = application_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.application)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::application*>(
      &::ce::nbapi::_application_default_instance_);
}
inline ::ce::nbapi::application* nb_event::release_application() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.application)
  clear_has_application();
  ::ce::nbapi::application* temp = application_;
  application_ = NULL;
  return temp;
}
inline ::ce::nbapi::application* nb_event::mutable_application() {
  set_has_application();
  if (application_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::application>(GetArenaNoVirtual());
    application_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.application)
  return application_;
}
inline void nb_event::set_allocated_application(::ce::nbapi::application* application) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete application_;
  }
  if (application) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      application = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, application, submessage_arena);
    }
    set_has_application();
  } else {
    clear_has_application();
  }
  application_ = application;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.application)
}

// optional .ce.nbapi.visibility_rec visibility_rec = 510;
inline bool nb_event::has_visibility_rec() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void nb_event::set_has_visibility_rec() {
  _has_bits_[0] |= 0x00000100u;
}
inline void nb_event::clear_has_visibility_rec() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void nb_event::clear_visibility_rec() {
  if (visibility_rec_ != NULL) visibility_rec_->Clear();
  clear_has_visibility_rec();
}
inline const ::ce::nbapi::visibility_rec& nb_event::_internal_visibility_rec() const {
  return *visibility_rec_;
}
inline const ::ce::nbapi::visibility_rec& nb_event::visibility_rec() const {
  const ::ce::nbapi::visibility_rec* p = visibility_rec_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.visibility_rec)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::visibility_rec*>(
      &::ce::nbapi::_visibility_rec_default_instance_);
}
inline ::ce::nbapi::visibility_rec* nb_event::release_visibility_rec() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.visibility_rec)
  clear_has_visibility_rec();
  ::ce::nbapi::visibility_rec* temp = visibility_rec_;
  visibility_rec_ = NULL;
  return temp;
}
inline ::ce::nbapi::visibility_rec* nb_event::mutable_visibility_rec() {
  set_has_visibility_rec();
  if (visibility_rec_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::visibility_rec>(GetArenaNoVirtual());
    visibility_rec_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.visibility_rec)
  return visibility_rec_;
}
inline void nb_event::set_allocated_visibility_rec(::ce::nbapi::visibility_rec* visibility_rec) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete visibility_rec_;
  }
  if (visibility_rec) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      visibility_rec = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, visibility_rec, submessage_arena);
    }
    set_has_visibility_rec();
  } else {
    clear_has_visibility_rec();
  }
  visibility_rec_ = visibility_rec;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.visibility_rec)
}

// optional .ce.nbapi.campus campus = 511;
inline bool nb_event::has_campus() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void nb_event::set_has_campus() {
  _has_bits_[0] |= 0x00000200u;
}
inline void nb_event::clear_has_campus() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void nb_event::clear_campus() {
  if (campus_ != NULL) campus_->Clear();
  clear_has_campus();
}
inline const ::ce::nbapi::campus& nb_event::_internal_campus() const {
  return *campus_;
}
inline const ::ce::nbapi::campus& nb_event::campus() const {
  const ::ce::nbapi::campus* p = campus_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.campus)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::campus*>(
      &::ce::nbapi::_campus_default_instance_);
}
inline ::ce::nbapi::campus* nb_event::release_campus() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.campus)
  clear_has_campus();
  ::ce::nbapi::campus* temp = campus_;
  campus_ = NULL;
  return temp;
}
inline ::ce::nbapi::campus* nb_event::mutable_campus() {
  set_has_campus();
  if (campus_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::campus>(GetArenaNoVirtual());
    campus_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.campus)
  return campus_;
}
inline void nb_event::set_allocated_campus(::ce::nbapi::campus* campus) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete campus_;
  }
  if (campus) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      campus = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, campus, submessage_arena);
    }
    set_has_campus();
  } else {
    clear_has_campus();
  }
  campus_ = campus;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.campus)
}

// optional .ce.nbapi.building building = 512;
inline bool nb_event::has_building() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void nb_event::set_has_building() {
  _has_bits_[0] |= 0x00000400u;
}
inline void nb_event::clear_has_building() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void nb_event::clear_building() {
  if (building_ != NULL) building_->Clear();
  clear_has_building();
}
inline const ::ce::nbapi::building& nb_event::_internal_building() const {
  return *building_;
}
inline const ::ce::nbapi::building& nb_event::building() const {
  const ::ce::nbapi::building* p = building_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.building)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::building*>(
      &::ce::nbapi::_building_default_instance_);
}
inline ::ce::nbapi::building* nb_event::release_building() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.building)
  clear_has_building();
  ::ce::nbapi::building* temp = building_;
  building_ = NULL;
  return temp;
}
inline ::ce::nbapi::building* nb_event::mutable_building() {
  set_has_building();
  if (building_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::building>(GetArenaNoVirtual());
    building_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.building)
  return building_;
}
inline void nb_event::set_allocated_building(::ce::nbapi::building* building) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete building_;
  }
  if (building) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      building = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, building, submessage_arena);
    }
    set_has_building();
  } else {
    clear_has_building();
  }
  building_ = building;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.building)
}

// optional .ce.nbapi.floor floor = 513;
inline bool nb_event::has_floor() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void nb_event::set_has_floor() {
  _has_bits_[0] |= 0x00000800u;
}
inline void nb_event::clear_has_floor() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void nb_event::clear_floor() {
  if (floor_ != NULL) floor_->Clear();
  clear_has_floor();
}
inline const ::ce::nbapi::floor& nb_event::_internal_floor() const {
  return *floor_;
}
inline const ::ce::nbapi::floor& nb_event::floor() const {
  const ::ce::nbapi::floor* p = floor_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.floor)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::floor*>(
      &::ce::nbapi::_floor_default_instance_);
}
inline ::ce::nbapi::floor* nb_event::release_floor() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.floor)
  clear_has_floor();
  ::ce::nbapi::floor* temp = floor_;
  floor_ = NULL;
  return temp;
}
inline ::ce::nbapi::floor* nb_event::mutable_floor() {
  set_has_floor();
  if (floor_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::floor>(GetArenaNoVirtual());
    floor_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.floor)
  return floor_;
}
inline void nb_event::set_allocated_floor(::ce::nbapi::floor* floor) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete floor_;
  }
  if (floor) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      floor = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, floor, submessage_arena);
    }
    set_has_floor();
  } else {
    clear_has_floor();
  }
  floor_ = floor;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.floor)
}

// optional .ce.nbapi.access_point access_point = 514;
inline bool nb_event::has_access_point() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void nb_event::set_has_access_point() {
  _has_bits_[0] |= 0x00001000u;
}
inline void nb_event::clear_has_access_point() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void nb_event::clear_access_point() {
  if (access_point_ != NULL) access_point_->Clear();
  clear_has_access_point();
}
inline const ::ce::nbapi::access_point& nb_event::_internal_access_point() const {
  return *access_point_;
}
inline const ::ce::nbapi::access_point& nb_event::access_point() const {
  const ::ce::nbapi::access_point* p = access_point_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.access_point)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::access_point*>(
      &::ce::nbapi::_access_point_default_instance_);
}
inline ::ce::nbapi::access_point* nb_event::release_access_point() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.access_point)
  clear_has_access_point();
  ::ce::nbapi::access_point* temp = access_point_;
  access_point_ = NULL;
  return temp;
}
inline ::ce::nbapi::access_point* nb_event::mutable_access_point() {
  set_has_access_point();
  if (access_point_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::access_point>(GetArenaNoVirtual());
    access_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.access_point)
  return access_point_;
}
inline void nb_event::set_allocated_access_point(::ce::nbapi::access_point* access_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete access_point_;
  }
  if (access_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      access_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, access_point, submessage_arena);
    }
    set_has_access_point();
  } else {
    clear_has_access_point();
  }
  access_point_ = access_point;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.access_point)
}

// optional .ce.nbapi.virtual_access_point virtual_access_point = 515;
inline bool nb_event::has_virtual_access_point() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void nb_event::set_has_virtual_access_point() {
  _has_bits_[0] |= 0x00002000u;
}
inline void nb_event::clear_has_virtual_access_point() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void nb_event::clear_virtual_access_point() {
  if (virtual_access_point_ != NULL) virtual_access_point_->Clear();
  clear_has_virtual_access_point();
}
inline const ::ce::nbapi::virtual_access_point& nb_event::_internal_virtual_access_point() const {
  return *virtual_access_point_;
}
inline const ::ce::nbapi::virtual_access_point& nb_event::virtual_access_point() const {
  const ::ce::nbapi::virtual_access_point* p = virtual_access_point_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.virtual_access_point)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::virtual_access_point*>(
      &::ce::nbapi::_virtual_access_point_default_instance_);
}
inline ::ce::nbapi::virtual_access_point* nb_event::release_virtual_access_point() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.virtual_access_point)
  clear_has_virtual_access_point();
  ::ce::nbapi::virtual_access_point* temp = virtual_access_point_;
  virtual_access_point_ = NULL;
  return temp;
}
inline ::ce::nbapi::virtual_access_point* nb_event::mutable_virtual_access_point() {
  set_has_virtual_access_point();
  if (virtual_access_point_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::virtual_access_point>(GetArenaNoVirtual());
    virtual_access_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.virtual_access_point)
  return virtual_access_point_;
}
inline void nb_event::set_allocated_virtual_access_point(::ce::nbapi::virtual_access_point* virtual_access_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete virtual_access_point_;
  }
  if (virtual_access_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      virtual_access_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, virtual_access_point, submessage_arena);
    }
    set_has_virtual_access_point();
  } else {
    clear_has_virtual_access_point();
  }
  virtual_access_point_ = virtual_access_point;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.virtual_access_point)
}

// optional .ce.nbapi.geofence geofence = 516;
inline bool nb_event::has_geofence() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void nb_event::set_has_geofence() {
  _has_bits_[0] |= 0x00004000u;
}
inline void nb_event::clear_has_geofence() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void nb_event::clear_geofence() {
  if (geofence_ != NULL) geofence_->Clear();
  clear_has_geofence();
}
inline const ::ce::nbapi::geofence& nb_event::_internal_geofence() const {
  return *geofence_;
}
inline const ::ce::nbapi::geofence& nb_event::geofence() const {
  const ::ce::nbapi::geofence* p = geofence_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.geofence)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::geofence*>(
      &::ce::nbapi::_geofence_default_instance_);
}
inline ::ce::nbapi::geofence* nb_event::release_geofence() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.geofence)
  clear_has_geofence();
  ::ce::nbapi::geofence* temp = geofence_;
  geofence_ = NULL;
  return temp;
}
inline ::ce::nbapi::geofence* nb_event::mutable_geofence() {
  set_has_geofence();
  if (geofence_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::geofence>(GetArenaNoVirtual());
    geofence_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.geofence)
  return geofence_;
}
inline void nb_event::set_allocated_geofence(::ce::nbapi::geofence* geofence) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete geofence_;
  }
  if (geofence) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      geofence = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geofence, submessage_arena);
    }
    set_has_geofence();
  } else {
    clear_has_geofence();
  }
  geofence_ = geofence;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.geofence)
}

// optional .ce.nbapi.geofence_notify geofence_notify = 517;
inline bool nb_event::has_geofence_notify() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void nb_event::set_has_geofence_notify() {
  _has_bits_[0] |= 0x00008000u;
}
inline void nb_event::clear_has_geofence_notify() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void nb_event::clear_geofence_notify() {
  if (geofence_notify_ != NULL) geofence_notify_->Clear();
  clear_has_geofence_notify();
}
inline const ::ce::nbapi::geofence_notify& nb_event::_internal_geofence_notify() const {
  return *geofence_notify_;
}
inline const ::ce::nbapi::geofence_notify& nb_event::geofence_notify() const {
  const ::ce::nbapi::geofence_notify* p = geofence_notify_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.geofence_notify)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::geofence_notify*>(
      &::ce::nbapi::_geofence_notify_default_instance_);
}
inline ::ce::nbapi::geofence_notify* nb_event::release_geofence_notify() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.geofence_notify)
  clear_has_geofence_notify();
  ::ce::nbapi::geofence_notify* temp = geofence_notify_;
  geofence_notify_ = NULL;
  return temp;
}
inline ::ce::nbapi::geofence_notify* nb_event::mutable_geofence_notify() {
  set_has_geofence_notify();
  if (geofence_notify_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::geofence_notify>(GetArenaNoVirtual());
    geofence_notify_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.geofence_notify)
  return geofence_notify_;
}
inline void nb_event::set_allocated_geofence_notify(::ce::nbapi::geofence_notify* geofence_notify) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete geofence_notify_;
  }
  if (geofence_notify) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      geofence_notify = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geofence_notify, submessage_arena);
    }
    set_has_geofence_notify();
  } else {
    clear_has_geofence_notify();
  }
  geofence_notify_ = geofence_notify;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.geofence_notify)
}

// optional .ce.nbapi.stats_radio stats_radio = 518;
inline bool nb_event::has_stats_radio() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void nb_event::set_has_stats_radio() {
  _has_bits_[0] |= 0x00010000u;
}
inline void nb_event::clear_has_stats_radio() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void nb_event::clear_stats_radio() {
  if (stats_radio_ != NULL) stats_radio_->Clear();
  clear_has_stats_radio();
}
inline const ::ce::nbapi::stats_radio& nb_event::_internal_stats_radio() const {
  return *stats_radio_;
}
inline const ::ce::nbapi::stats_radio& nb_event::stats_radio() const {
  const ::ce::nbapi::stats_radio* p = stats_radio_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.stats_radio)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::stats_radio*>(
      &::ce::nbapi::_stats_radio_default_instance_);
}
inline ::ce::nbapi::stats_radio* nb_event::release_stats_radio() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.stats_radio)
  clear_has_stats_radio();
  ::ce::nbapi::stats_radio* temp = stats_radio_;
  stats_radio_ = NULL;
  return temp;
}
inline ::ce::nbapi::stats_radio* nb_event::mutable_stats_radio() {
  set_has_stats_radio();
  if (stats_radio_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::stats_radio>(GetArenaNoVirtual());
    stats_radio_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.stats_radio)
  return stats_radio_;
}
inline void nb_event::set_allocated_stats_radio(::ce::nbapi::stats_radio* stats_radio) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_radio_;
  }
  if (stats_radio) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats_radio = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats_radio, submessage_arena);
    }
    set_has_stats_radio();
  } else {
    clear_has_stats_radio();
  }
  stats_radio_ = stats_radio;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.stats_radio)
}

// optional .ce.nbapi.stats_vap stats_vap = 519;
inline bool nb_event::has_stats_vap() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void nb_event::set_has_stats_vap() {
  _has_bits_[0] |= 0x00020000u;
}
inline void nb_event::clear_has_stats_vap() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void nb_event::clear_stats_vap() {
  if (stats_vap_ != NULL) stats_vap_->Clear();
  clear_has_stats_vap();
}
inline const ::ce::nbapi::stats_vap& nb_event::_internal_stats_vap() const {
  return *stats_vap_;
}
inline const ::ce::nbapi::stats_vap& nb_event::stats_vap() const {
  const ::ce::nbapi::stats_vap* p = stats_vap_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.stats_vap)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::stats_vap*>(
      &::ce::nbapi::_stats_vap_default_instance_);
}
inline ::ce::nbapi::stats_vap* nb_event::release_stats_vap() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.stats_vap)
  clear_has_stats_vap();
  ::ce::nbapi::stats_vap* temp = stats_vap_;
  stats_vap_ = NULL;
  return temp;
}
inline ::ce::nbapi::stats_vap* nb_event::mutable_stats_vap() {
  set_has_stats_vap();
  if (stats_vap_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::stats_vap>(GetArenaNoVirtual());
    stats_vap_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.stats_vap)
  return stats_vap_;
}
inline void nb_event::set_allocated_stats_vap(::ce::nbapi::stats_vap* stats_vap) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_vap_;
  }
  if (stats_vap) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats_vap = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats_vap, submessage_arena);
    }
    set_has_stats_vap();
  } else {
    clear_has_stats_vap();
  }
  stats_vap_ = stats_vap;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.stats_vap)
}

// optional .ce.nbapi.stats_station stats_station = 520;
inline bool nb_event::has_stats_station() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void nb_event::set_has_stats_station() {
  _has_bits_[0] |= 0x00040000u;
}
inline void nb_event::clear_has_stats_station() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void nb_event::clear_stats_station() {
  if (stats_station_ != NULL) stats_station_->Clear();
  clear_has_stats_station();
}
inline const ::ce::nbapi::stats_station& nb_event::_internal_stats_station() const {
  return *stats_station_;
}
inline const ::ce::nbapi::stats_station& nb_event::stats_station() const {
  const ::ce::nbapi::stats_station* p = stats_station_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.stats_station)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::stats_station*>(
      &::ce::nbapi::_stats_station_default_instance_);
}
inline ::ce::nbapi::stats_station* nb_event::release_stats_station() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.stats_station)
  clear_has_stats_station();
  ::ce::nbapi::stats_station* temp = stats_station_;
  stats_station_ = NULL;
  return temp;
}
inline ::ce::nbapi::stats_station* nb_event::mutable_stats_station() {
  set_has_stats_station();
  if (stats_station_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::stats_station>(GetArenaNoVirtual());
    stats_station_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.stats_station)
  return stats_station_;
}
inline void nb_event::set_allocated_stats_station(::ce::nbapi::stats_station* stats_station) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_station_;
  }
  if (stats_station) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats_station = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats_station, submessage_arena);
    }
    set_has_stats_station();
  } else {
    clear_has_stats_station();
  }
  stats_station_ = stats_station;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.stats_station)
}

// optional .ce.nbapi.ap_neighbor_list ap_neighbor_list = 521;
inline bool nb_event::has_ap_neighbor_list() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void nb_event::set_has_ap_neighbor_list() {
  _has_bits_[0] |= 0x00080000u;
}
inline void nb_event::clear_has_ap_neighbor_list() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void nb_event::clear_ap_neighbor_list() {
  if (ap_neighbor_list_ != NULL) ap_neighbor_list_->Clear();
  clear_has_ap_neighbor_list();
}
inline const ::ce::nbapi::ap_neighbor_list& nb_event::_internal_ap_neighbor_list() const {
  return *ap_neighbor_list_;
}
inline const ::ce::nbapi::ap_neighbor_list& nb_event::ap_neighbor_list() const {
  const ::ce::nbapi::ap_neighbor_list* p = ap_neighbor_list_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.ap_neighbor_list)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ap_neighbor_list*>(
      &::ce::nbapi::_ap_neighbor_list_default_instance_);
}
inline ::ce::nbapi::ap_neighbor_list* nb_event::release_ap_neighbor_list() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.ap_neighbor_list)
  clear_has_ap_neighbor_list();
  ::ce::nbapi::ap_neighbor_list* temp = ap_neighbor_list_;
  ap_neighbor_list_ = NULL;
  return temp;
}
inline ::ce::nbapi::ap_neighbor_list* nb_event::mutable_ap_neighbor_list() {
  set_has_ap_neighbor_list();
  if (ap_neighbor_list_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ap_neighbor_list>(GetArenaNoVirtual());
    ap_neighbor_list_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.ap_neighbor_list)
  return ap_neighbor_list_;
}
inline void nb_event::set_allocated_ap_neighbor_list(::ce::nbapi::ap_neighbor_list* ap_neighbor_list) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_neighbor_list_;
  }
  if (ap_neighbor_list) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_neighbor_list = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_neighbor_list, submessage_arena);
    }
    set_has_ap_neighbor_list();
  } else {
    clear_has_ap_neighbor_list();
  }
  ap_neighbor_list_ = ap_neighbor_list;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.ap_neighbor_list)
}

// optional .ce.nbapi.utilization_stats_radio utilization_stats_radio = 522;
inline bool nb_event::has_utilization_stats_radio() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void nb_event::set_has_utilization_stats_radio() {
  _has_bits_[0] |= 0x00100000u;
}
inline void nb_event::clear_has_utilization_stats_radio() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void nb_event::clear_utilization_stats_radio() {
  if (utilization_stats_radio_ != NULL) utilization_stats_radio_->Clear();
  clear_has_utilization_stats_radio();
}
inline const ::ce::nbapi::utilization_stats_radio& nb_event::_internal_utilization_stats_radio() const {
  return *utilization_stats_radio_;
}
inline const ::ce::nbapi::utilization_stats_radio& nb_event::utilization_stats_radio() const {
  const ::ce::nbapi::utilization_stats_radio* p = utilization_stats_radio_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.utilization_stats_radio)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::utilization_stats_radio*>(
      &::ce::nbapi::_utilization_stats_radio_default_instance_);
}
inline ::ce::nbapi::utilization_stats_radio* nb_event::release_utilization_stats_radio() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.utilization_stats_radio)
  clear_has_utilization_stats_radio();
  ::ce::nbapi::utilization_stats_radio* temp = utilization_stats_radio_;
  utilization_stats_radio_ = NULL;
  return temp;
}
inline ::ce::nbapi::utilization_stats_radio* nb_event::mutable_utilization_stats_radio() {
  set_has_utilization_stats_radio();
  if (utilization_stats_radio_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::utilization_stats_radio>(GetArenaNoVirtual());
    utilization_stats_radio_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.utilization_stats_radio)
  return utilization_stats_radio_;
}
inline void nb_event::set_allocated_utilization_stats_radio(::ce::nbapi::utilization_stats_radio* utilization_stats_radio) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete utilization_stats_radio_;
  }
  if (utilization_stats_radio) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      utilization_stats_radio = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, utilization_stats_radio, submessage_arena);
    }
    set_has_utilization_stats_radio();
  } else {
    clear_has_utilization_stats_radio();
  }
  utilization_stats_radio_ = utilization_stats_radio;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.utilization_stats_radio)
}

// optional .ce.nbapi.sta_rssi sta_rssi = 523;
inline bool nb_event::has_sta_rssi() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void nb_event::set_has_sta_rssi() {
  _has_bits_[0] |= 0x00200000u;
}
inline void nb_event::clear_has_sta_rssi() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void nb_event::clear_sta_rssi() {
  if (sta_rssi_ != NULL) sta_rssi_->Clear();
  clear_has_sta_rssi();
}
inline const ::ce::nbapi::sta_rssi& nb_event::_internal_sta_rssi() const {
  return *sta_rssi_;
}
inline const ::ce::nbapi::sta_rssi& nb_event::sta_rssi() const {
  const ::ce::nbapi::sta_rssi* p = sta_rssi_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.sta_rssi)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::sta_rssi*>(
      &::ce::nbapi::_sta_rssi_default_instance_);
}
inline ::ce::nbapi::sta_rssi* nb_event::release_sta_rssi() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.sta_rssi)
  clear_has_sta_rssi();
  ::ce::nbapi::sta_rssi* temp = sta_rssi_;
  sta_rssi_ = NULL;
  return temp;
}
inline ::ce::nbapi::sta_rssi* nb_event::mutable_sta_rssi() {
  set_has_sta_rssi();
  if (sta_rssi_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::sta_rssi>(GetArenaNoVirtual());
    sta_rssi_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.sta_rssi)
  return sta_rssi_;
}
inline void nb_event::set_allocated_sta_rssi(::ce::nbapi::sta_rssi* sta_rssi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sta_rssi_;
  }
  if (sta_rssi) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sta_rssi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sta_rssi, submessage_arena);
    }
    set_has_sta_rssi();
  } else {
    clear_has_sta_rssi();
  }
  sta_rssi_ = sta_rssi;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.sta_rssi)
}

// optional .ce.nbapi.ap_rssi ap_rssi = 524;
inline bool nb_event::has_ap_rssi() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void nb_event::set_has_ap_rssi() {
  _has_bits_[0] |= 0x00400000u;
}
inline void nb_event::clear_has_ap_rssi() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void nb_event::clear_ap_rssi() {
  if (ap_rssi_ != NULL) ap_rssi_->Clear();
  clear_has_ap_rssi();
}
inline const ::ce::nbapi::ap_rssi& nb_event::_internal_ap_rssi() const {
  return *ap_rssi_;
}
inline const ::ce::nbapi::ap_rssi& nb_event::ap_rssi() const {
  const ::ce::nbapi::ap_rssi* p = ap_rssi_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.ap_rssi)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ap_rssi*>(
      &::ce::nbapi::_ap_rssi_default_instance_);
}
inline ::ce::nbapi::ap_rssi* nb_event::release_ap_rssi() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.ap_rssi)
  clear_has_ap_rssi();
  ::ce::nbapi::ap_rssi* temp = ap_rssi_;
  ap_rssi_ = NULL;
  return temp;
}
inline ::ce::nbapi::ap_rssi* nb_event::mutable_ap_rssi() {
  set_has_ap_rssi();
  if (ap_rssi_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ap_rssi>(GetArenaNoVirtual());
    ap_rssi_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.ap_rssi)
  return ap_rssi_;
}
inline void nb_event::set_allocated_ap_rssi(::ce::nbapi::ap_rssi* ap_rssi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_rssi_;
  }
  if (ap_rssi) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_rssi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_rssi, submessage_arena);
    }
    set_has_ap_rssi();
  } else {
    clear_has_ap_rssi();
  }
  ap_rssi_ = ap_rssi;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.ap_rssi)
}

// optional .ce.nbapi.proximity proximity = 525;
inline bool nb_event::has_proximity() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void nb_event::set_has_proximity() {
  _has_bits_[0] |= 0x00800000u;
}
inline void nb_event::clear_has_proximity() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void nb_event::clear_proximity() {
  if (proximity_ != NULL) proximity_->Clear();
  clear_has_proximity();
}
inline const ::ce::nbapi::proximity& nb_event::_internal_proximity() const {
  return *proximity_;
}
inline const ::ce::nbapi::proximity& nb_event::proximity() const {
  const ::ce::nbapi::proximity* p = proximity_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.proximity)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::proximity*>(
      &::ce::nbapi::_proximity_default_instance_);
}
inline ::ce::nbapi::proximity* nb_event::release_proximity() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.proximity)
  clear_has_proximity();
  ::ce::nbapi::proximity* temp = proximity_;
  proximity_ = NULL;
  return temp;
}
inline ::ce::nbapi::proximity* nb_event::mutable_proximity() {
  set_has_proximity();
  if (proximity_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::proximity>(GetArenaNoVirtual());
    proximity_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.proximity)
  return proximity_;
}
inline void nb_event::set_allocated_proximity(::ce::nbapi::proximity* proximity) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete proximity_;
  }
  if (proximity) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      proximity = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, proximity, submessage_arena);
    }
    set_has_proximity();
  } else {
    clear_has_proximity();
  }
  proximity_ = proximity;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.proximity)
}

// optional .ce.nbapi.webcc_category webcc_category = 526;
inline bool nb_event::has_webcc_category() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void nb_event::set_has_webcc_category() {
  _has_bits_[0] |= 0x01000000u;
}
inline void nb_event::clear_has_webcc_category() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void nb_event::clear_webcc_category() {
  if (webcc_category_ != NULL) webcc_category_->Clear();
  clear_has_webcc_category();
}
inline const ::ce::nbapi::webcc_category& nb_event::_internal_webcc_category() const {
  return *webcc_category_;
}
inline const ::ce::nbapi::webcc_category& nb_event::webcc_category() const {
  const ::ce::nbapi::webcc_category* p = webcc_category_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.webcc_category)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::webcc_category*>(
      &::ce::nbapi::_webcc_category_default_instance_);
}
inline ::ce::nbapi::webcc_category* nb_event::release_webcc_category() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.webcc_category)
  clear_has_webcc_category();
  ::ce::nbapi::webcc_category* temp = webcc_category_;
  webcc_category_ = NULL;
  return temp;
}
inline ::ce::nbapi::webcc_category* nb_event::mutable_webcc_category() {
  set_has_webcc_category();
  if (webcc_category_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::webcc_category>(GetArenaNoVirtual());
    webcc_category_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.webcc_category)
  return webcc_category_;
}
inline void nb_event::set_allocated_webcc_category(::ce::nbapi::webcc_category* webcc_category) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete webcc_category_;
  }
  if (webcc_category) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      webcc_category = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, webcc_category, submessage_arena);
    }
    set_has_webcc_category();
  } else {
    clear_has_webcc_category();
  }
  webcc_category_ = webcc_category;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.webcc_category)
}

// optional .ce.nbapi.webcc_info webcc_info = 527;
inline bool nb_event::has_webcc_info() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void nb_event::set_has_webcc_info() {
  _has_bits_[0] |= 0x02000000u;
}
inline void nb_event::clear_has_webcc_info() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void nb_event::clear_webcc_info() {
  if (webcc_info_ != NULL) webcc_info_->Clear();
  clear_has_webcc_info();
}
inline const ::ce::nbapi::webcc_info& nb_event::_internal_webcc_info() const {
  return *webcc_info_;
}
inline const ::ce::nbapi::webcc_info& nb_event::webcc_info() const {
  const ::ce::nbapi::webcc_info* p = webcc_info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.webcc_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::webcc_info*>(
      &::ce::nbapi::_webcc_info_default_instance_);
}
inline ::ce::nbapi::webcc_info* nb_event::release_webcc_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.webcc_info)
  clear_has_webcc_info();
  ::ce::nbapi::webcc_info* temp = webcc_info_;
  webcc_info_ = NULL;
  return temp;
}
inline ::ce::nbapi::webcc_info* nb_event::mutable_webcc_info() {
  set_has_webcc_info();
  if (webcc_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::webcc_info>(GetArenaNoVirtual());
    webcc_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.webcc_info)
  return webcc_info_;
}
inline void nb_event::set_allocated_webcc_info(::ce::nbapi::webcc_info* webcc_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete webcc_info_;
  }
  if (webcc_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      webcc_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, webcc_info, submessage_arena);
    }
    set_has_webcc_info();
  } else {
    clear_has_webcc_info();
  }
  webcc_info_ = webcc_info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.webcc_info)
}

// optional .ce.nbapi.security_message security_message = 528;
inline bool nb_event::has_security_message() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void nb_event::set_has_security_message() {
  _has_bits_[0] |= 0x04000000u;
}
inline void nb_event::clear_has_security_message() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void nb_event::clear_security_message() {
  if (security_message_ != NULL) security_message_->Clear();
  clear_has_security_message();
}
inline const ::ce::nbapi::security_message& nb_event::_internal_security_message() const {
  return *security_message_;
}
inline const ::ce::nbapi::security_message& nb_event::security_message() const {
  const ::ce::nbapi::security_message* p = security_message_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.security_message)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::security_message*>(
      &::ce::nbapi::_security_message_default_instance_);
}
inline ::ce::nbapi::security_message* nb_event::release_security_message() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.security_message)
  clear_has_security_message();
  ::ce::nbapi::security_message* temp = security_message_;
  security_message_ = NULL;
  return temp;
}
inline ::ce::nbapi::security_message* nb_event::mutable_security_message() {
  set_has_security_message();
  if (security_message_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::security_message>(GetArenaNoVirtual());
    security_message_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.security_message)
  return security_message_;
}
inline void nb_event::set_allocated_security_message(::ce::nbapi::security_message* security_message) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete security_message_;
  }
  if (security_message) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      security_message = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, security_message, submessage_arena);
    }
    set_has_security_message();
  } else {
    clear_has_security_message();
  }
  security_message_ = security_message;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.security_message)
}

// optional .ce.nbapi.spectrum_info spectrum_info = 529;
inline bool nb_event::has_spectrum_info() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void nb_event::set_has_spectrum_info() {
  _has_bits_[0] |= 0x08000000u;
}
inline void nb_event::clear_has_spectrum_info() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void nb_event::clear_spectrum_info() {
  if (spectrum_info_ != NULL) spectrum_info_->Clear();
  clear_has_spectrum_info();
}
inline const ::ce::nbapi::spectrum_info& nb_event::_internal_spectrum_info() const {
  return *spectrum_info_;
}
inline const ::ce::nbapi::spectrum_info& nb_event::spectrum_info() const {
  const ::ce::nbapi::spectrum_info* p = spectrum_info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.spectrum_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::spectrum_info*>(
      &::ce::nbapi::_spectrum_info_default_instance_);
}
inline ::ce::nbapi::spectrum_info* nb_event::release_spectrum_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.spectrum_info)
  clear_has_spectrum_info();
  ::ce::nbapi::spectrum_info* temp = spectrum_info_;
  spectrum_info_ = NULL;
  return temp;
}
inline ::ce::nbapi::spectrum_info* nb_event::mutable_spectrum_info() {
  set_has_spectrum_info();
  if (spectrum_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::spectrum_info>(GetArenaNoVirtual());
    spectrum_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.spectrum_info)
  return spectrum_info_;
}
inline void nb_event::set_allocated_spectrum_info(::ce::nbapi::spectrum_info* spectrum_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete spectrum_info_;
  }
  if (spectrum_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      spectrum_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, spectrum_info, submessage_arena);
    }
    set_has_spectrum_info();
  } else {
    clear_has_spectrum_info();
  }
  spectrum_info_ = spectrum_info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.spectrum_info)
}

// optional .ce.nbapi.state_station state_station = 530;
inline bool nb_event::has_state_station() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void nb_event::set_has_state_station() {
  _has_bits_[0] |= 0x10000000u;
}
inline void nb_event::clear_has_state_station() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void nb_event::clear_state_station() {
  if (state_station_ != NULL) state_station_->Clear();
  clear_has_state_station();
}
inline const ::ce::nbapi::state_station& nb_event::_internal_state_station() const {
  return *state_station_;
}
inline const ::ce::nbapi::state_station& nb_event::state_station() const {
  const ::ce::nbapi::state_station* p = state_station_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.state_station)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::state_station*>(
      &::ce::nbapi::_state_station_default_instance_);
}
inline ::ce::nbapi::state_station* nb_event::release_state_station() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.state_station)
  clear_has_state_station();
  ::ce::nbapi::state_station* temp = state_station_;
  state_station_ = NULL;
  return temp;
}
inline ::ce::nbapi::state_station* nb_event::mutable_state_station() {
  set_has_state_station();
  if (state_station_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::state_station>(GetArenaNoVirtual());
    state_station_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.state_station)
  return state_station_;
}
inline void nb_event::set_allocated_state_station(::ce::nbapi::state_station* state_station) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_station_;
  }
  if (state_station) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state_station = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state_station, submessage_arena);
    }
    set_has_state_station();
  } else {
    clear_has_state_station();
  }
  state_station_ = state_station;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.state_station)
}

// optional .ce.nbapi.controller_info controller = 531;
inline bool nb_event::has_controller() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void nb_event::set_has_controller() {
  _has_bits_[0] |= 0x20000000u;
}
inline void nb_event::clear_has_controller() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void nb_event::clear_controller() {
  if (controller_ != NULL) controller_->Clear();
  clear_has_controller();
}
inline const ::ce::nbapi::controller_info& nb_event::_internal_controller() const {
  return *controller_;
}
inline const ::ce::nbapi::controller_info& nb_event::controller() const {
  const ::ce::nbapi::controller_info* p = controller_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.controller)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::controller_info*>(
      &::ce::nbapi::_controller_info_default_instance_);
}
inline ::ce::nbapi::controller_info* nb_event::release_controller() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.controller)
  clear_has_controller();
  ::ce::nbapi::controller_info* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline ::ce::nbapi::controller_info* nb_event::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::controller_info>(GetArenaNoVirtual());
    controller_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.controller)
  return controller_;
}
inline void nb_event::set_allocated_controller(::ce::nbapi::controller_info* controller) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete controller_;
  }
  if (controller) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      controller = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, controller, submessage_arena);
    }
    set_has_controller();
  } else {
    clear_has_controller();
  }
  controller_ = controller;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.controller)
}

// optional .ce.nbapi.cluster_info cluster = 532;
inline bool nb_event::has_cluster() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void nb_event::set_has_cluster() {
  _has_bits_[0] |= 0x40000000u;
}
inline void nb_event::clear_has_cluster() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void nb_event::clear_cluster() {
  if (cluster_ != NULL) cluster_->Clear();
  clear_has_cluster();
}
inline const ::ce::nbapi::cluster_info& nb_event::_internal_cluster() const {
  return *cluster_;
}
inline const ::ce::nbapi::cluster_info& nb_event::cluster() const {
  const ::ce::nbapi::cluster_info* p = cluster_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.cluster)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::cluster_info*>(
      &::ce::nbapi::_cluster_info_default_instance_);
}
inline ::ce::nbapi::cluster_info* nb_event::release_cluster() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.cluster)
  clear_has_cluster();
  ::ce::nbapi::cluster_info* temp = cluster_;
  cluster_ = NULL;
  return temp;
}
inline ::ce::nbapi::cluster_info* nb_event::mutable_cluster() {
  set_has_cluster();
  if (cluster_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::cluster_info>(GetArenaNoVirtual());
    cluster_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.cluster)
  return cluster_;
}
inline void nb_event::set_allocated_cluster(::ce::nbapi::cluster_info* cluster) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cluster_;
  }
  if (cluster) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cluster = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cluster, submessage_arena);
    }
    set_has_cluster();
  } else {
    clear_has_cluster();
  }
  cluster_ = cluster;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.cluster)
}

// optional .ce.nbapi.uplink_bandwidth uplink_bandwidth = 533;
inline bool nb_event::has_uplink_bandwidth() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void nb_event::set_has_uplink_bandwidth() {
  _has_bits_[0] |= 0x80000000u;
}
inline void nb_event::clear_has_uplink_bandwidth() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void nb_event::clear_uplink_bandwidth() {
  if (uplink_bandwidth_ != NULL) uplink_bandwidth_->Clear();
  clear_has_uplink_bandwidth();
}
inline const ::ce::nbapi::uplink_bandwidth& nb_event::_internal_uplink_bandwidth() const {
  return *uplink_bandwidth_;
}
inline const ::ce::nbapi::uplink_bandwidth& nb_event::uplink_bandwidth() const {
  const ::ce::nbapi::uplink_bandwidth* p = uplink_bandwidth_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.uplink_bandwidth)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::uplink_bandwidth*>(
      &::ce::nbapi::_uplink_bandwidth_default_instance_);
}
inline ::ce::nbapi::uplink_bandwidth* nb_event::release_uplink_bandwidth() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.uplink_bandwidth)
  clear_has_uplink_bandwidth();
  ::ce::nbapi::uplink_bandwidth* temp = uplink_bandwidth_;
  uplink_bandwidth_ = NULL;
  return temp;
}
inline ::ce::nbapi::uplink_bandwidth* nb_event::mutable_uplink_bandwidth() {
  set_has_uplink_bandwidth();
  if (uplink_bandwidth_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::uplink_bandwidth>(GetArenaNoVirtual());
    uplink_bandwidth_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.uplink_bandwidth)
  return uplink_bandwidth_;
}
inline void nb_event::set_allocated_uplink_bandwidth(::ce::nbapi::uplink_bandwidth* uplink_bandwidth) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete uplink_bandwidth_;
  }
  if (uplink_bandwidth) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      uplink_bandwidth = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uplink_bandwidth, submessage_arena);
    }
    set_has_uplink_bandwidth();
  } else {
    clear_has_uplink_bandwidth();
  }
  uplink_bandwidth_ = uplink_bandwidth;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.uplink_bandwidth)
}

// optional .ce.nbapi.iap_client_url iapClientURL = 544;
inline bool nb_event::has_iapclienturl() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void nb_event::set_has_iapclienturl() {
  _has_bits_[1] |= 0x00000001u;
}
inline void nb_event::clear_has_iapclienturl() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void nb_event::clear_iapclienturl() {
  if (iapclienturl_ != NULL) iapclienturl_->Clear();
  clear_has_iapclienturl();
}
inline const ::ce::nbapi::iap_client_url& nb_event::_internal_iapclienturl() const {
  return *iapclienturl_;
}
inline const ::ce::nbapi::iap_client_url& nb_event::iapclienturl() const {
  const ::ce::nbapi::iap_client_url* p = iapclienturl_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.iapClientURL)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::iap_client_url*>(
      &::ce::nbapi::_iap_client_url_default_instance_);
}
inline ::ce::nbapi::iap_client_url* nb_event::release_iapclienturl() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.iapClientURL)
  clear_has_iapclienturl();
  ::ce::nbapi::iap_client_url* temp = iapclienturl_;
  iapclienturl_ = NULL;
  return temp;
}
inline ::ce::nbapi::iap_client_url* nb_event::mutable_iapclienturl() {
  set_has_iapclienturl();
  if (iapclienturl_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::iap_client_url>(GetArenaNoVirtual());
    iapclienturl_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.iapClientURL)
  return iapclienturl_;
}
inline void nb_event::set_allocated_iapclienturl(::ce::nbapi::iap_client_url* iapclienturl) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete iapclienturl_;
  }
  if (iapclienturl) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      iapclienturl = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, iapclienturl, submessage_arena);
    }
    set_has_iapclienturl();
  } else {
    clear_has_iapclienturl();
  }
  iapclienturl_ = iapclienturl;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.iapClientURL)
}

// optional .ce.nbapi.rogue_info rogue_info = 545;
inline bool nb_event::has_rogue_info() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void nb_event::set_has_rogue_info() {
  _has_bits_[1] |= 0x00000002u;
}
inline void nb_event::clear_has_rogue_info() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void nb_event::clear_rogue_info() {
  if (rogue_info_ != NULL) rogue_info_->Clear();
  clear_has_rogue_info();
}
inline const ::ce::nbapi::rogue_info& nb_event::_internal_rogue_info() const {
  return *rogue_info_;
}
inline const ::ce::nbapi::rogue_info& nb_event::rogue_info() const {
  const ::ce::nbapi::rogue_info* p = rogue_info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.rogue_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::rogue_info*>(
      &::ce::nbapi::_rogue_info_default_instance_);
}
inline ::ce::nbapi::rogue_info* nb_event::release_rogue_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.rogue_info)
  clear_has_rogue_info();
  ::ce::nbapi::rogue_info* temp = rogue_info_;
  rogue_info_ = NULL;
  return temp;
}
inline ::ce::nbapi::rogue_info* nb_event::mutable_rogue_info() {
  set_has_rogue_info();
  if (rogue_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::rogue_info>(GetArenaNoVirtual());
    rogue_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.rogue_info)
  return rogue_info_;
}
inline void nb_event::set_allocated_rogue_info(::ce::nbapi::rogue_info* rogue_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rogue_info_;
  }
  if (rogue_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rogue_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rogue_info, submessage_arena);
    }
    set_has_rogue_info();
  } else {
    clear_has_rogue_info();
  }
  rogue_info_ = rogue_info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.rogue_info)
}

// optional .ce.nbapi.air_monitor_info air_mon_info = 546;
inline bool nb_event::has_air_mon_info() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void nb_event::set_has_air_mon_info() {
  _has_bits_[1] |= 0x00000004u;
}
inline void nb_event::clear_has_air_mon_info() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void nb_event::clear_air_mon_info() {
  if (air_mon_info_ != NULL) air_mon_info_->Clear();
  clear_has_air_mon_info();
}
inline const ::ce::nbapi::air_monitor_info& nb_event::_internal_air_mon_info() const {
  return *air_mon_info_;
}
inline const ::ce::nbapi::air_monitor_info& nb_event::air_mon_info() const {
  const ::ce::nbapi::air_monitor_info* p = air_mon_info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.air_mon_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::air_monitor_info*>(
      &::ce::nbapi::_air_monitor_info_default_instance_);
}
inline ::ce::nbapi::air_monitor_info* nb_event::release_air_mon_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.air_mon_info)
  clear_has_air_mon_info();
  ::ce::nbapi::air_monitor_info* temp = air_mon_info_;
  air_mon_info_ = NULL;
  return temp;
}
inline ::ce::nbapi::air_monitor_info* nb_event::mutable_air_mon_info() {
  set_has_air_mon_info();
  if (air_mon_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::air_monitor_info>(GetArenaNoVirtual());
    air_mon_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.air_mon_info)
  return air_mon_info_;
}
inline void nb_event::set_allocated_air_mon_info(::ce::nbapi::air_monitor_info* air_mon_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete air_mon_info_;
  }
  if (air_mon_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      air_mon_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, air_mon_info, submessage_arena);
    }
    set_has_air_mon_info();
  } else {
    clear_has_air_mon_info();
  }
  air_mon_info_ = air_mon_info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.air_mon_info)
}

// optional .ce.nbapi.ap_location ap_location = 547;
inline bool nb_event::has_ap_location() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void nb_event::set_has_ap_location() {
  _has_bits_[1] |= 0x00000008u;
}
inline void nb_event::clear_has_ap_location() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void nb_event::clear_ap_location() {
  if (ap_location_ != NULL) ap_location_->Clear();
  clear_has_ap_location();
}
inline const ::ce::nbapi::ap_location& nb_event::_internal_ap_location() const {
  return *ap_location_;
}
inline const ::ce::nbapi::ap_location& nb_event::ap_location() const {
  const ::ce::nbapi::ap_location* p = ap_location_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.ap_location)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ap_location*>(
      &::ce::nbapi::_ap_location_default_instance_);
}
inline ::ce::nbapi::ap_location* nb_event::release_ap_location() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.ap_location)
  clear_has_ap_location();
  ::ce::nbapi::ap_location* temp = ap_location_;
  ap_location_ = NULL;
  return temp;
}
inline ::ce::nbapi::ap_location* nb_event::mutable_ap_location() {
  set_has_ap_location();
  if (ap_location_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ap_location>(GetArenaNoVirtual());
    ap_location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.ap_location)
  return ap_location_;
}
inline void nb_event::set_allocated_ap_location(::ce::nbapi::ap_location* ap_location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_location_;
  }
  if (ap_location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_location, submessage_arena);
    }
    set_has_ap_location();
  } else {
    clear_has_ap_location();
  }
  ap_location_ = ap_location;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.ap_location)
}

// optional .ce.nbapi.state_access_point state_access_point = 548;
inline bool nb_event::has_state_access_point() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void nb_event::set_has_state_access_point() {
  _has_bits_[1] |= 0x00000010u;
}
inline void nb_event::clear_has_state_access_point() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void nb_event::clear_state_access_point() {
  if (state_access_point_ != NULL) state_access_point_->Clear();
  clear_has_state_access_point();
}
inline const ::ce::nbapi::state_access_point& nb_event::_internal_state_access_point() const {
  return *state_access_point_;
}
inline const ::ce::nbapi::state_access_point& nb_event::state_access_point() const {
  const ::ce::nbapi::state_access_point* p = state_access_point_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.state_access_point)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::state_access_point*>(
      &::ce::nbapi::_state_access_point_default_instance_);
}
inline ::ce::nbapi::state_access_point* nb_event::release_state_access_point() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.state_access_point)
  clear_has_state_access_point();
  ::ce::nbapi::state_access_point* temp = state_access_point_;
  state_access_point_ = NULL;
  return temp;
}
inline ::ce::nbapi::state_access_point* nb_event::mutable_state_access_point() {
  set_has_state_access_point();
  if (state_access_point_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::state_access_point>(GetArenaNoVirtual());
    state_access_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.state_access_point)
  return state_access_point_;
}
inline void nb_event::set_allocated_state_access_point(::ce::nbapi::state_access_point* state_access_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete state_access_point_;
  }
  if (state_access_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      state_access_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, state_access_point, submessage_arena);
    }
    set_has_state_access_point();
  } else {
    clear_has_state_access_point();
  }
  state_access_point_ = state_access_point;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.state_access_point)
}

// optional .ce.nbapi.stats_modem stats_modem = 549;
inline bool nb_event::has_stats_modem() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void nb_event::set_has_stats_modem() {
  _has_bits_[1] |= 0x00000020u;
}
inline void nb_event::clear_has_stats_modem() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void nb_event::clear_stats_modem() {
  if (stats_modem_ != NULL) stats_modem_->Clear();
  clear_has_stats_modem();
}
inline const ::ce::nbapi::stats_modem& nb_event::_internal_stats_modem() const {
  return *stats_modem_;
}
inline const ::ce::nbapi::stats_modem& nb_event::stats_modem() const {
  const ::ce::nbapi::stats_modem* p = stats_modem_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.stats_modem)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::stats_modem*>(
      &::ce::nbapi::_stats_modem_default_instance_);
}
inline ::ce::nbapi::stats_modem* nb_event::release_stats_modem() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.stats_modem)
  clear_has_stats_modem();
  ::ce::nbapi::stats_modem* temp = stats_modem_;
  stats_modem_ = NULL;
  return temp;
}
inline ::ce::nbapi::stats_modem* nb_event::mutable_stats_modem() {
  set_has_stats_modem();
  if (stats_modem_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::stats_modem>(GetArenaNoVirtual());
    stats_modem_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.stats_modem)
  return stats_modem_;
}
inline void nb_event::set_allocated_stats_modem(::ce::nbapi::stats_modem* stats_modem) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_modem_;
  }
  if (stats_modem) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats_modem = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats_modem, submessage_arena);
    }
    set_has_stats_modem();
  } else {
    clear_has_stats_modem();
  }
  stats_modem_ = stats_modem;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.stats_modem)
}

// optional .ce.nbapi.uplink_info uplink_info = 550;
inline bool nb_event::has_uplink_info() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void nb_event::set_has_uplink_info() {
  _has_bits_[1] |= 0x00000040u;
}
inline void nb_event::clear_has_uplink_info() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void nb_event::clear_uplink_info() {
  if (uplink_info_ != NULL) uplink_info_->Clear();
  clear_has_uplink_info();
}
inline const ::ce::nbapi::uplink_info& nb_event::_internal_uplink_info() const {
  return *uplink_info_;
}
inline const ::ce::nbapi::uplink_info& nb_event::uplink_info() const {
  const ::ce::nbapi::uplink_info* p = uplink_info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.uplink_info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::uplink_info*>(
      &::ce::nbapi::_uplink_info_default_instance_);
}
inline ::ce::nbapi::uplink_info* nb_event::release_uplink_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.uplink_info)
  clear_has_uplink_info();
  ::ce::nbapi::uplink_info* temp = uplink_info_;
  uplink_info_ = NULL;
  return temp;
}
inline ::ce::nbapi::uplink_info* nb_event::mutable_uplink_info() {
  set_has_uplink_info();
  if (uplink_info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::uplink_info>(GetArenaNoVirtual());
    uplink_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.uplink_info)
  return uplink_info_;
}
inline void nb_event::set_allocated_uplink_info(::ce::nbapi::uplink_info* uplink_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete uplink_info_;
  }
  if (uplink_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      uplink_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, uplink_info, submessage_arena);
    }
    set_has_uplink_info();
  } else {
    clear_has_uplink_info();
  }
  uplink_info_ = uplink_info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.uplink_info)
}

// optional .ce.nbapi.stats_uplink stats_uplink = 551;
inline bool nb_event::has_stats_uplink() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void nb_event::set_has_stats_uplink() {
  _has_bits_[1] |= 0x00000080u;
}
inline void nb_event::clear_has_stats_uplink() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void nb_event::clear_stats_uplink() {
  if (stats_uplink_ != NULL) stats_uplink_->Clear();
  clear_has_stats_uplink();
}
inline const ::ce::nbapi::stats_uplink& nb_event::_internal_stats_uplink() const {
  return *stats_uplink_;
}
inline const ::ce::nbapi::stats_uplink& nb_event::stats_uplink() const {
  const ::ce::nbapi::stats_uplink* p = stats_uplink_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.stats_uplink)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::stats_uplink*>(
      &::ce::nbapi::_stats_uplink_default_instance_);
}
inline ::ce::nbapi::stats_uplink* nb_event::release_stats_uplink() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.stats_uplink)
  clear_has_stats_uplink();
  ::ce::nbapi::stats_uplink* temp = stats_uplink_;
  stats_uplink_ = NULL;
  return temp;
}
inline ::ce::nbapi::stats_uplink* nb_event::mutable_stats_uplink() {
  set_has_stats_uplink();
  if (stats_uplink_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::stats_uplink>(GetArenaNoVirtual());
    stats_uplink_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.stats_uplink)
  return stats_uplink_;
}
inline void nb_event::set_allocated_stats_uplink(::ce::nbapi::stats_uplink* stats_uplink) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_uplink_;
  }
  if (stats_uplink) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats_uplink = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats_uplink, submessage_arena);
    }
    set_has_stats_uplink();
  } else {
    clear_has_stats_uplink();
  }
  stats_uplink_ = stats_uplink;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.stats_uplink)
}

// optional .ce.nbapi.wan_comp_uplink wan_comp_uplink = 552;
inline bool nb_event::has_wan_comp_uplink() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void nb_event::set_has_wan_comp_uplink() {
  _has_bits_[1] |= 0x00000100u;
}
inline void nb_event::clear_has_wan_comp_uplink() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void nb_event::clear_wan_comp_uplink() {
  if (wan_comp_uplink_ != NULL) wan_comp_uplink_->Clear();
  clear_has_wan_comp_uplink();
}
inline const ::ce::nbapi::wan_comp_uplink& nb_event::_internal_wan_comp_uplink() const {
  return *wan_comp_uplink_;
}
inline const ::ce::nbapi::wan_comp_uplink& nb_event::wan_comp_uplink() const {
  const ::ce::nbapi::wan_comp_uplink* p = wan_comp_uplink_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.wan_comp_uplink)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::wan_comp_uplink*>(
      &::ce::nbapi::_wan_comp_uplink_default_instance_);
}
inline ::ce::nbapi::wan_comp_uplink* nb_event::release_wan_comp_uplink() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.wan_comp_uplink)
  clear_has_wan_comp_uplink();
  ::ce::nbapi::wan_comp_uplink* temp = wan_comp_uplink_;
  wan_comp_uplink_ = NULL;
  return temp;
}
inline ::ce::nbapi::wan_comp_uplink* nb_event::mutable_wan_comp_uplink() {
  set_has_wan_comp_uplink();
  if (wan_comp_uplink_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::wan_comp_uplink>(GetArenaNoVirtual());
    wan_comp_uplink_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.wan_comp_uplink)
  return wan_comp_uplink_;
}
inline void nb_event::set_allocated_wan_comp_uplink(::ce::nbapi::wan_comp_uplink* wan_comp_uplink) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wan_comp_uplink_;
  }
  if (wan_comp_uplink) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wan_comp_uplink = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wan_comp_uplink, submessage_arena);
    }
    set_has_wan_comp_uplink();
  } else {
    clear_has_wan_comp_uplink();
  }
  wan_comp_uplink_ = wan_comp_uplink;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.wan_comp_uplink)
}

// optional .ce.nbapi.stats_ip_probe_uplink stats_ip_probe_uplink = 553;
inline bool nb_event::has_stats_ip_probe_uplink() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void nb_event::set_has_stats_ip_probe_uplink() {
  _has_bits_[1] |= 0x00000200u;
}
inline void nb_event::clear_has_stats_ip_probe_uplink() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void nb_event::clear_stats_ip_probe_uplink() {
  if (stats_ip_probe_uplink_ != NULL) stats_ip_probe_uplink_->Clear();
  clear_has_stats_ip_probe_uplink();
}
inline const ::ce::nbapi::stats_ip_probe_uplink& nb_event::_internal_stats_ip_probe_uplink() const {
  return *stats_ip_probe_uplink_;
}
inline const ::ce::nbapi::stats_ip_probe_uplink& nb_event::stats_ip_probe_uplink() const {
  const ::ce::nbapi::stats_ip_probe_uplink* p = stats_ip_probe_uplink_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.stats_ip_probe_uplink)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::stats_ip_probe_uplink*>(
      &::ce::nbapi::_stats_ip_probe_uplink_default_instance_);
}
inline ::ce::nbapi::stats_ip_probe_uplink* nb_event::release_stats_ip_probe_uplink() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.stats_ip_probe_uplink)
  clear_has_stats_ip_probe_uplink();
  ::ce::nbapi::stats_ip_probe_uplink* temp = stats_ip_probe_uplink_;
  stats_ip_probe_uplink_ = NULL;
  return temp;
}
inline ::ce::nbapi::stats_ip_probe_uplink* nb_event::mutable_stats_ip_probe_uplink() {
  set_has_stats_ip_probe_uplink();
  if (stats_ip_probe_uplink_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::stats_ip_probe_uplink>(GetArenaNoVirtual());
    stats_ip_probe_uplink_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.stats_ip_probe_uplink)
  return stats_ip_probe_uplink_;
}
inline void nb_event::set_allocated_stats_ip_probe_uplink(::ce::nbapi::stats_ip_probe_uplink* stats_ip_probe_uplink) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_ip_probe_uplink_;
  }
  if (stats_ip_probe_uplink) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats_ip_probe_uplink = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats_ip_probe_uplink, submessage_arena);
    }
    set_has_stats_ip_probe_uplink();
  } else {
    clear_has_stats_ip_probe_uplink();
  }
  stats_ip_probe_uplink_ = stats_ip_probe_uplink;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.stats_ip_probe_uplink)
}

// optional .ce.nbapi.summary_webcat_iap summary_webcat = 554;
inline bool nb_event::has_summary_webcat() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void nb_event::set_has_summary_webcat() {
  _has_bits_[1] |= 0x00000400u;
}
inline void nb_event::clear_has_summary_webcat() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void nb_event::clear_summary_webcat() {
  if (summary_webcat_ != NULL) summary_webcat_->Clear();
  clear_has_summary_webcat();
}
inline const ::ce::nbapi::summary_webcat_iap& nb_event::_internal_summary_webcat() const {
  return *summary_webcat_;
}
inline const ::ce::nbapi::summary_webcat_iap& nb_event::summary_webcat() const {
  const ::ce::nbapi::summary_webcat_iap* p = summary_webcat_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.summary_webcat)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::summary_webcat_iap*>(
      &::ce::nbapi::_summary_webcat_iap_default_instance_);
}
inline ::ce::nbapi::summary_webcat_iap* nb_event::release_summary_webcat() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.summary_webcat)
  clear_has_summary_webcat();
  ::ce::nbapi::summary_webcat_iap* temp = summary_webcat_;
  summary_webcat_ = NULL;
  return temp;
}
inline ::ce::nbapi::summary_webcat_iap* nb_event::mutable_summary_webcat() {
  set_has_summary_webcat();
  if (summary_webcat_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::summary_webcat_iap>(GetArenaNoVirtual());
    summary_webcat_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.summary_webcat)
  return summary_webcat_;
}
inline void nb_event::set_allocated_summary_webcat(::ce::nbapi::summary_webcat_iap* summary_webcat) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete summary_webcat_;
  }
  if (summary_webcat) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      summary_webcat = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, summary_webcat, submessage_arena);
    }
    set_has_summary_webcat();
  } else {
    clear_has_summary_webcat();
  }
  summary_webcat_ = summary_webcat;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.summary_webcat)
}

// optional .ce.nbapi.summary_appid_iap summary_appid = 555;
inline bool nb_event::has_summary_appid() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void nb_event::set_has_summary_appid() {
  _has_bits_[1] |= 0x00000800u;
}
inline void nb_event::clear_has_summary_appid() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void nb_event::clear_summary_appid() {
  if (summary_appid_ != NULL) summary_appid_->Clear();
  clear_has_summary_appid();
}
inline const ::ce::nbapi::summary_appid_iap& nb_event::_internal_summary_appid() const {
  return *summary_appid_;
}
inline const ::ce::nbapi::summary_appid_iap& nb_event::summary_appid() const {
  const ::ce::nbapi::summary_appid_iap* p = summary_appid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.summary_appid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::summary_appid_iap*>(
      &::ce::nbapi::_summary_appid_iap_default_instance_);
}
inline ::ce::nbapi::summary_appid_iap* nb_event::release_summary_appid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.summary_appid)
  clear_has_summary_appid();
  ::ce::nbapi::summary_appid_iap* temp = summary_appid_;
  summary_appid_ = NULL;
  return temp;
}
inline ::ce::nbapi::summary_appid_iap* nb_event::mutable_summary_appid() {
  set_has_summary_appid();
  if (summary_appid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::summary_appid_iap>(GetArenaNoVirtual());
    summary_appid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.summary_appid)
  return summary_appid_;
}
inline void nb_event::set_allocated_summary_appid(::ce::nbapi::summary_appid_iap* summary_appid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete summary_appid_;
  }
  if (summary_appid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      summary_appid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, summary_appid, submessage_arena);
    }
    set_has_summary_appid();
  } else {
    clear_has_summary_appid();
  }
  summary_appid_ = summary_appid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.summary_appid)
}

// optional .ce.nbapi.summary_webrep_iap summary_webrep = 556;
inline bool nb_event::has_summary_webrep() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void nb_event::set_has_summary_webrep() {
  _has_bits_[1] |= 0x00001000u;
}
inline void nb_event::clear_has_summary_webrep() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void nb_event::clear_summary_webrep() {
  if (summary_webrep_ != NULL) summary_webrep_->Clear();
  clear_has_summary_webrep();
}
inline const ::ce::nbapi::summary_webrep_iap& nb_event::_internal_summary_webrep() const {
  return *summary_webrep_;
}
inline const ::ce::nbapi::summary_webrep_iap& nb_event::summary_webrep() const {
  const ::ce::nbapi::summary_webrep_iap* p = summary_webrep_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.summary_webrep)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::summary_webrep_iap*>(
      &::ce::nbapi::_summary_webrep_iap_default_instance_);
}
inline ::ce::nbapi::summary_webrep_iap* nb_event::release_summary_webrep() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.summary_webrep)
  clear_has_summary_webrep();
  ::ce::nbapi::summary_webrep_iap* temp = summary_webrep_;
  summary_webrep_ = NULL;
  return temp;
}
inline ::ce::nbapi::summary_webrep_iap* nb_event::mutable_summary_webrep() {
  set_has_summary_webrep();
  if (summary_webrep_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::summary_webrep_iap>(GetArenaNoVirtual());
    summary_webrep_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.summary_webrep)
  return summary_webrep_;
}
inline void nb_event::set_allocated_summary_webrep(::ce::nbapi::summary_webrep_iap* summary_webrep) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete summary_webrep_;
  }
  if (summary_webrep) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      summary_webrep = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, summary_webrep, submessage_arena);
    }
    set_has_summary_webrep();
  } else {
    clear_has_summary_webrep();
  }
  summary_webrep_ = summary_webrep;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.summary_webrep)
}

// optional .ce.nbapi.stats_role_iap stats_role = 557;
inline bool nb_event::has_stats_role() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void nb_event::set_has_stats_role() {
  _has_bits_[1] |= 0x00002000u;
}
inline void nb_event::clear_has_stats_role() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void nb_event::clear_stats_role() {
  if (stats_role_ != NULL) stats_role_->Clear();
  clear_has_stats_role();
}
inline const ::ce::nbapi::stats_role_iap& nb_event::_internal_stats_role() const {
  return *stats_role_;
}
inline const ::ce::nbapi::stats_role_iap& nb_event::stats_role() const {
  const ::ce::nbapi::stats_role_iap* p = stats_role_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.stats_role)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::stats_role_iap*>(
      &::ce::nbapi::_stats_role_iap_default_instance_);
}
inline ::ce::nbapi::stats_role_iap* nb_event::release_stats_role() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.stats_role)
  clear_has_stats_role();
  ::ce::nbapi::stats_role_iap* temp = stats_role_;
  stats_role_ = NULL;
  return temp;
}
inline ::ce::nbapi::stats_role_iap* nb_event::mutable_stats_role() {
  set_has_stats_role();
  if (stats_role_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::stats_role_iap>(GetArenaNoVirtual());
    stats_role_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.stats_role)
  return stats_role_;
}
inline void nb_event::set_allocated_stats_role(::ce::nbapi::stats_role_iap* stats_role) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_role_;
  }
  if (stats_role) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats_role = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats_role, submessage_arena);
    }
    set_has_stats_role();
  } else {
    clear_has_stats_role();
  }
  stats_role_ = stats_role;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.stats_role)
}

// optional .ce.nbapi.stats_vlan_iap stats_vlan = 558;
inline bool nb_event::has_stats_vlan() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void nb_event::set_has_stats_vlan() {
  _has_bits_[1] |= 0x00004000u;
}
inline void nb_event::clear_has_stats_vlan() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void nb_event::clear_stats_vlan() {
  if (stats_vlan_ != NULL) stats_vlan_->Clear();
  clear_has_stats_vlan();
}
inline const ::ce::nbapi::stats_vlan_iap& nb_event::_internal_stats_vlan() const {
  return *stats_vlan_;
}
inline const ::ce::nbapi::stats_vlan_iap& nb_event::stats_vlan() const {
  const ::ce::nbapi::stats_vlan_iap* p = stats_vlan_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.stats_vlan)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::stats_vlan_iap*>(
      &::ce::nbapi::_stats_vlan_iap_default_instance_);
}
inline ::ce::nbapi::stats_vlan_iap* nb_event::release_stats_vlan() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.stats_vlan)
  clear_has_stats_vlan();
  ::ce::nbapi::stats_vlan_iap* temp = stats_vlan_;
  stats_vlan_ = NULL;
  return temp;
}
inline ::ce::nbapi::stats_vlan_iap* nb_event::mutable_stats_vlan() {
  set_has_stats_vlan();
  if (stats_vlan_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::stats_vlan_iap>(GetArenaNoVirtual());
    stats_vlan_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.stats_vlan)
  return stats_vlan_;
}
inline void nb_event::set_allocated_stats_vlan(::ce::nbapi::stats_vlan_iap* stats_vlan) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_vlan_;
  }
  if (stats_vlan) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats_vlan = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats_vlan, submessage_arena);
    }
    set_has_stats_vlan();
  } else {
    clear_has_stats_vlan();
  }
  stats_vlan_ = stats_vlan;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.stats_vlan)
}

// optional .ce.nbapi.stats_ssid_iap stats_ssid = 559;
inline bool nb_event::has_stats_ssid() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void nb_event::set_has_stats_ssid() {
  _has_bits_[1] |= 0x00008000u;
}
inline void nb_event::clear_has_stats_ssid() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void nb_event::clear_stats_ssid() {
  if (stats_ssid_ != NULL) stats_ssid_->Clear();
  clear_has_stats_ssid();
}
inline const ::ce::nbapi::stats_ssid_iap& nb_event::_internal_stats_ssid() const {
  return *stats_ssid_;
}
inline const ::ce::nbapi::stats_ssid_iap& nb_event::stats_ssid() const {
  const ::ce::nbapi::stats_ssid_iap* p = stats_ssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.stats_ssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::stats_ssid_iap*>(
      &::ce::nbapi::_stats_ssid_iap_default_instance_);
}
inline ::ce::nbapi::stats_ssid_iap* nb_event::release_stats_ssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.stats_ssid)
  clear_has_stats_ssid();
  ::ce::nbapi::stats_ssid_iap* temp = stats_ssid_;
  stats_ssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::stats_ssid_iap* nb_event::mutable_stats_ssid() {
  set_has_stats_ssid();
  if (stats_ssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::stats_ssid_iap>(GetArenaNoVirtual());
    stats_ssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.stats_ssid)
  return stats_ssid_;
}
inline void nb_event::set_allocated_stats_ssid(::ce::nbapi::stats_ssid_iap* stats_ssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_ssid_;
  }
  if (stats_ssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats_ssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats_ssid, submessage_arena);
    }
    set_has_stats_ssid();
  } else {
    clear_has_stats_ssid();
  }
  stats_ssid_ = stats_ssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.stats_ssid)
}

// optional .ce.nbapi.tag_rssi tag_rssi = 560;
inline bool nb_event::has_tag_rssi() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void nb_event::set_has_tag_rssi() {
  _has_bits_[1] |= 0x00010000u;
}
inline void nb_event::clear_has_tag_rssi() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void nb_event::clear_tag_rssi() {
  if (tag_rssi_ != NULL) tag_rssi_->Clear();
  clear_has_tag_rssi();
}
inline const ::ce::nbapi::tag_rssi& nb_event::_internal_tag_rssi() const {
  return *tag_rssi_;
}
inline const ::ce::nbapi::tag_rssi& nb_event::tag_rssi() const {
  const ::ce::nbapi::tag_rssi* p = tag_rssi_;
  // @@protoc_insertion_point(field_get:ce.nbapi.nb_event.tag_rssi)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::tag_rssi*>(
      &::ce::nbapi::_tag_rssi_default_instance_);
}
inline ::ce::nbapi::tag_rssi* nb_event::release_tag_rssi() {
  // @@protoc_insertion_point(field_release:ce.nbapi.nb_event.tag_rssi)
  clear_has_tag_rssi();
  ::ce::nbapi::tag_rssi* temp = tag_rssi_;
  tag_rssi_ = NULL;
  return temp;
}
inline ::ce::nbapi::tag_rssi* nb_event::mutable_tag_rssi() {
  set_has_tag_rssi();
  if (tag_rssi_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::tag_rssi>(GetArenaNoVirtual());
    tag_rssi_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.nb_event.tag_rssi)
  return tag_rssi_;
}
inline void nb_event::set_allocated_tag_rssi(::ce::nbapi::tag_rssi* tag_rssi) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete tag_rssi_;
  }
  if (tag_rssi) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      tag_rssi = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tag_rssi, submessage_arena);
    }
    set_has_tag_rssi();
  } else {
    clear_has_tag_rssi();
  }
  tag_rssi_ = tag_rssi;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.nb_event.tag_rssi)
}

// -------------------------------------------------------------------

// query_response_Location_result

// required .ce.nbapi.location msg = 11;
inline bool query_response_Location_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Location_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Location_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Location_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::location& query_response_Location_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::location& query_response_Location_result::msg() const {
  const ::ce::nbapi::location* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Location_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::location*>(
      &::ce::nbapi::_location_default_instance_);
}
inline ::ce::nbapi::location* query_response_Location_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Location_result.msg)
  clear_has_msg();
  ::ce::nbapi::location* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::location* query_response_Location_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::location>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Location_result.msg)
  return msg_;
}
inline void query_response_Location_result::set_allocated_msg(::ce::nbapi::location* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Location_result.msg)
}

// optional uint32 ts = 12;
inline bool query_response_Location_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Location_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Location_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Location_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Location_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Location_result.ts)
  return ts_;
}
inline void query_response_Location_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Location_result.ts)
}

// -------------------------------------------------------------------

// query_response_Presence_result

// required .ce.nbapi.presence msg = 21;
inline bool query_response_Presence_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Presence_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Presence_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Presence_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::presence& query_response_Presence_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::presence& query_response_Presence_result::msg() const {
  const ::ce::nbapi::presence* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Presence_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::presence*>(
      &::ce::nbapi::_presence_default_instance_);
}
inline ::ce::nbapi::presence* query_response_Presence_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Presence_result.msg)
  clear_has_msg();
  ::ce::nbapi::presence* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::presence* query_response_Presence_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::presence>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Presence_result.msg)
  return msg_;
}
inline void query_response_Presence_result::set_allocated_msg(::ce::nbapi::presence* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Presence_result.msg)
}

// optional uint32 ts = 22;
inline bool query_response_Presence_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Presence_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Presence_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Presence_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Presence_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Presence_result.ts)
  return ts_;
}
inline void query_response_Presence_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Presence_result.ts)
}

// -------------------------------------------------------------------

// query_response_Rssi_result

// required .ce.nbapi.rssi msg = 31;
inline bool query_response_Rssi_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Rssi_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Rssi_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Rssi_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::rssi& query_response_Rssi_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::rssi& query_response_Rssi_result::msg() const {
  const ::ce::nbapi::rssi* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Rssi_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::rssi*>(
      &::ce::nbapi::_rssi_default_instance_);
}
inline ::ce::nbapi::rssi* query_response_Rssi_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Rssi_result.msg)
  clear_has_msg();
  ::ce::nbapi::rssi* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::rssi* query_response_Rssi_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::rssi>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Rssi_result.msg)
  return msg_;
}
inline void query_response_Rssi_result::set_allocated_msg(::ce::nbapi::rssi* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Rssi_result.msg)
}

// optional uint32 ts = 32;
inline bool query_response_Rssi_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Rssi_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Rssi_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Rssi_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Rssi_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Rssi_result.ts)
  return ts_;
}
inline void query_response_Rssi_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Rssi_result.ts)
}

// -------------------------------------------------------------------

// query_response_Station_result

// required .ce.nbapi.station msg = 41;
inline bool query_response_Station_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Station_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Station_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Station_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::station& query_response_Station_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::station& query_response_Station_result::msg() const {
  const ::ce::nbapi::station* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Station_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::station*>(
      &::ce::nbapi::_station_default_instance_);
}
inline ::ce::nbapi::station* query_response_Station_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Station_result.msg)
  clear_has_msg();
  ::ce::nbapi::station* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::station* query_response_Station_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::station>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Station_result.msg)
  return msg_;
}
inline void query_response_Station_result::set_allocated_msg(::ce::nbapi::station* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Station_result.msg)
}

// optional uint32 ts = 42;
inline bool query_response_Station_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Station_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Station_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Station_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Station_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Station_result.ts)
  return ts_;
}
inline void query_response_Station_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Station_result.ts)
}

// -------------------------------------------------------------------

// query_response_Radio_result

// required .ce.nbapi.radio msg = 51;
inline bool query_response_Radio_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Radio_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Radio_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Radio_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::radio& query_response_Radio_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::radio& query_response_Radio_result::msg() const {
  const ::ce::nbapi::radio* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Radio_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::radio*>(
      &::ce::nbapi::_radio_default_instance_);
}
inline ::ce::nbapi::radio* query_response_Radio_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Radio_result.msg)
  clear_has_msg();
  ::ce::nbapi::radio* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::radio* query_response_Radio_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::radio>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Radio_result.msg)
  return msg_;
}
inline void query_response_Radio_result::set_allocated_msg(::ce::nbapi::radio* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Radio_result.msg)
}

// optional uint32 ts = 52;
inline bool query_response_Radio_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Radio_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Radio_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Radio_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Radio_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Radio_result.ts)
  return ts_;
}
inline void query_response_Radio_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Radio_result.ts)
}

// -------------------------------------------------------------------

// query_response_Destination_result

// required .ce.nbapi.destination msg = 61;
inline bool query_response_Destination_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Destination_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Destination_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Destination_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::destination& query_response_Destination_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::destination& query_response_Destination_result::msg() const {
  const ::ce::nbapi::destination* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Destination_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::destination*>(
      &::ce::nbapi::_destination_default_instance_);
}
inline ::ce::nbapi::destination* query_response_Destination_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Destination_result.msg)
  clear_has_msg();
  ::ce::nbapi::destination* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::destination* query_response_Destination_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::destination>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Destination_result.msg)
  return msg_;
}
inline void query_response_Destination_result::set_allocated_msg(::ce::nbapi::destination* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Destination_result.msg)
}

// optional uint32 ts = 62;
inline bool query_response_Destination_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Destination_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Destination_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Destination_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Destination_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Destination_result.ts)
  return ts_;
}
inline void query_response_Destination_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Destination_result.ts)
}

// -------------------------------------------------------------------

// query_response_Application_result

// required .ce.nbapi.application msg = 71;
inline bool query_response_Application_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Application_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Application_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Application_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::application& query_response_Application_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::application& query_response_Application_result::msg() const {
  const ::ce::nbapi::application* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Application_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::application*>(
      &::ce::nbapi::_application_default_instance_);
}
inline ::ce::nbapi::application* query_response_Application_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Application_result.msg)
  clear_has_msg();
  ::ce::nbapi::application* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::application* query_response_Application_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::application>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Application_result.msg)
  return msg_;
}
inline void query_response_Application_result::set_allocated_msg(::ce::nbapi::application* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Application_result.msg)
}

// optional uint32 ts = 72;
inline bool query_response_Application_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Application_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Application_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Application_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Application_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Application_result.ts)
  return ts_;
}
inline void query_response_Application_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Application_result.ts)
}

// -------------------------------------------------------------------

// query_response_Visibility_rec_result

// required .ce.nbapi.visibility_rec msg = 81;
inline bool query_response_Visibility_rec_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Visibility_rec_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Visibility_rec_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Visibility_rec_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::visibility_rec& query_response_Visibility_rec_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::visibility_rec& query_response_Visibility_rec_result::msg() const {
  const ::ce::nbapi::visibility_rec* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Visibility_rec_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::visibility_rec*>(
      &::ce::nbapi::_visibility_rec_default_instance_);
}
inline ::ce::nbapi::visibility_rec* query_response_Visibility_rec_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Visibility_rec_result.msg)
  clear_has_msg();
  ::ce::nbapi::visibility_rec* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::visibility_rec* query_response_Visibility_rec_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::visibility_rec>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Visibility_rec_result.msg)
  return msg_;
}
inline void query_response_Visibility_rec_result::set_allocated_msg(::ce::nbapi::visibility_rec* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Visibility_rec_result.msg)
}

// optional uint32 ts = 82;
inline bool query_response_Visibility_rec_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Visibility_rec_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Visibility_rec_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Visibility_rec_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Visibility_rec_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Visibility_rec_result.ts)
  return ts_;
}
inline void query_response_Visibility_rec_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Visibility_rec_result.ts)
}

// -------------------------------------------------------------------

// query_response_Campus_result

// required .ce.nbapi.campus msg = 91;
inline bool query_response_Campus_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Campus_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Campus_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Campus_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::campus& query_response_Campus_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::campus& query_response_Campus_result::msg() const {
  const ::ce::nbapi::campus* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Campus_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::campus*>(
      &::ce::nbapi::_campus_default_instance_);
}
inline ::ce::nbapi::campus* query_response_Campus_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Campus_result.msg)
  clear_has_msg();
  ::ce::nbapi::campus* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::campus* query_response_Campus_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::campus>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Campus_result.msg)
  return msg_;
}
inline void query_response_Campus_result::set_allocated_msg(::ce::nbapi::campus* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Campus_result.msg)
}

// optional uint32 ts = 92;
inline bool query_response_Campus_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Campus_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Campus_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Campus_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Campus_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Campus_result.ts)
  return ts_;
}
inline void query_response_Campus_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Campus_result.ts)
}

// -------------------------------------------------------------------

// query_response_Building_result

// required .ce.nbapi.building msg = 101;
inline bool query_response_Building_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Building_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Building_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Building_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::building& query_response_Building_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::building& query_response_Building_result::msg() const {
  const ::ce::nbapi::building* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Building_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::building*>(
      &::ce::nbapi::_building_default_instance_);
}
inline ::ce::nbapi::building* query_response_Building_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Building_result.msg)
  clear_has_msg();
  ::ce::nbapi::building* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::building* query_response_Building_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::building>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Building_result.msg)
  return msg_;
}
inline void query_response_Building_result::set_allocated_msg(::ce::nbapi::building* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Building_result.msg)
}

// optional uint32 ts = 102;
inline bool query_response_Building_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Building_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Building_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Building_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Building_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Building_result.ts)
  return ts_;
}
inline void query_response_Building_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Building_result.ts)
}

// -------------------------------------------------------------------

// query_response_Floor_result

// required .ce.nbapi.floor msg = 111;
inline bool query_response_Floor_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Floor_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Floor_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Floor_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::floor& query_response_Floor_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::floor& query_response_Floor_result::msg() const {
  const ::ce::nbapi::floor* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Floor_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::floor*>(
      &::ce::nbapi::_floor_default_instance_);
}
inline ::ce::nbapi::floor* query_response_Floor_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Floor_result.msg)
  clear_has_msg();
  ::ce::nbapi::floor* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::floor* query_response_Floor_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::floor>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Floor_result.msg)
  return msg_;
}
inline void query_response_Floor_result::set_allocated_msg(::ce::nbapi::floor* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Floor_result.msg)
}

// optional uint32 ts = 112;
inline bool query_response_Floor_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Floor_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Floor_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Floor_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Floor_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Floor_result.ts)
  return ts_;
}
inline void query_response_Floor_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Floor_result.ts)
}

// -------------------------------------------------------------------

// query_response_Access_point_result

// required .ce.nbapi.access_point msg = 121;
inline bool query_response_Access_point_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Access_point_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Access_point_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Access_point_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::access_point& query_response_Access_point_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::access_point& query_response_Access_point_result::msg() const {
  const ::ce::nbapi::access_point* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Access_point_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::access_point*>(
      &::ce::nbapi::_access_point_default_instance_);
}
inline ::ce::nbapi::access_point* query_response_Access_point_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Access_point_result.msg)
  clear_has_msg();
  ::ce::nbapi::access_point* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::access_point* query_response_Access_point_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::access_point>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Access_point_result.msg)
  return msg_;
}
inline void query_response_Access_point_result::set_allocated_msg(::ce::nbapi::access_point* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Access_point_result.msg)
}

// optional uint32 ts = 122;
inline bool query_response_Access_point_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Access_point_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Access_point_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Access_point_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Access_point_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Access_point_result.ts)
  return ts_;
}
inline void query_response_Access_point_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Access_point_result.ts)
}

// -------------------------------------------------------------------

// query_response_Virtual_access_point_result

// required .ce.nbapi.virtual_access_point msg = 131;
inline bool query_response_Virtual_access_point_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Virtual_access_point_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Virtual_access_point_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Virtual_access_point_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::virtual_access_point& query_response_Virtual_access_point_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::virtual_access_point& query_response_Virtual_access_point_result::msg() const {
  const ::ce::nbapi::virtual_access_point* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Virtual_access_point_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::virtual_access_point*>(
      &::ce::nbapi::_virtual_access_point_default_instance_);
}
inline ::ce::nbapi::virtual_access_point* query_response_Virtual_access_point_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Virtual_access_point_result.msg)
  clear_has_msg();
  ::ce::nbapi::virtual_access_point* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::virtual_access_point* query_response_Virtual_access_point_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::virtual_access_point>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Virtual_access_point_result.msg)
  return msg_;
}
inline void query_response_Virtual_access_point_result::set_allocated_msg(::ce::nbapi::virtual_access_point* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Virtual_access_point_result.msg)
}

// optional uint32 ts = 132;
inline bool query_response_Virtual_access_point_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Virtual_access_point_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Virtual_access_point_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Virtual_access_point_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Virtual_access_point_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Virtual_access_point_result.ts)
  return ts_;
}
inline void query_response_Virtual_access_point_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Virtual_access_point_result.ts)
}

// -------------------------------------------------------------------

// query_response_Geofence_result

// required .ce.nbapi.geofence msg = 141;
inline bool query_response_Geofence_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Geofence_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Geofence_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Geofence_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::geofence& query_response_Geofence_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::geofence& query_response_Geofence_result::msg() const {
  const ::ce::nbapi::geofence* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Geofence_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::geofence*>(
      &::ce::nbapi::_geofence_default_instance_);
}
inline ::ce::nbapi::geofence* query_response_Geofence_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Geofence_result.msg)
  clear_has_msg();
  ::ce::nbapi::geofence* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::geofence* query_response_Geofence_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::geofence>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Geofence_result.msg)
  return msg_;
}
inline void query_response_Geofence_result::set_allocated_msg(::ce::nbapi::geofence* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Geofence_result.msg)
}

// optional uint32 ts = 142;
inline bool query_response_Geofence_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Geofence_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Geofence_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Geofence_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Geofence_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Geofence_result.ts)
  return ts_;
}
inline void query_response_Geofence_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Geofence_result.ts)
}

// -------------------------------------------------------------------

// query_response_Proximity_result

// required .ce.nbapi.proximity msg = 152;
inline bool query_response_Proximity_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Proximity_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Proximity_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Proximity_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::proximity& query_response_Proximity_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::proximity& query_response_Proximity_result::msg() const {
  const ::ce::nbapi::proximity* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Proximity_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::proximity*>(
      &::ce::nbapi::_proximity_default_instance_);
}
inline ::ce::nbapi::proximity* query_response_Proximity_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Proximity_result.msg)
  clear_has_msg();
  ::ce::nbapi::proximity* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::proximity* query_response_Proximity_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::proximity>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Proximity_result.msg)
  return msg_;
}
inline void query_response_Proximity_result::set_allocated_msg(::ce::nbapi::proximity* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Proximity_result.msg)
}

// optional uint32 ts = 153;
inline bool query_response_Proximity_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Proximity_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Proximity_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Proximity_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Proximity_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Proximity_result.ts)
  return ts_;
}
inline void query_response_Proximity_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Proximity_result.ts)
}

// -------------------------------------------------------------------

// query_response_WebCCCategory_result

// required .ce.nbapi.webcc_category msg = 161;
inline bool query_response_WebCCCategory_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_WebCCCategory_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_WebCCCategory_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_WebCCCategory_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::webcc_category& query_response_WebCCCategory_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::webcc_category& query_response_WebCCCategory_result::msg() const {
  const ::ce::nbapi::webcc_category* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.WebCCCategory_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::webcc_category*>(
      &::ce::nbapi::_webcc_category_default_instance_);
}
inline ::ce::nbapi::webcc_category* query_response_WebCCCategory_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.WebCCCategory_result.msg)
  clear_has_msg();
  ::ce::nbapi::webcc_category* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::webcc_category* query_response_WebCCCategory_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::webcc_category>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.WebCCCategory_result.msg)
  return msg_;
}
inline void query_response_WebCCCategory_result::set_allocated_msg(::ce::nbapi::webcc_category* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.WebCCCategory_result.msg)
}

// optional uint32 ts = 162;
inline bool query_response_WebCCCategory_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_WebCCCategory_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_WebCCCategory_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_WebCCCategory_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_WebCCCategory_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.WebCCCategory_result.ts)
  return ts_;
}
inline void query_response_WebCCCategory_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.WebCCCategory_result.ts)
}

// -------------------------------------------------------------------

// query_response_Info_result

// required .ce.nbapi.info msg = 171;
inline bool query_response_Info_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Info_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Info_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Info_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::info& query_response_Info_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::info& query_response_Info_result::msg() const {
  const ::ce::nbapi::info* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Info_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::info*>(
      &::ce::nbapi::_info_default_instance_);
}
inline ::ce::nbapi::info* query_response_Info_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Info_result.msg)
  clear_has_msg();
  ::ce::nbapi::info* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::info* query_response_Info_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::info>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Info_result.msg)
  return msg_;
}
inline void query_response_Info_result::set_allocated_msg(::ce::nbapi::info* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Info_result.msg)
}

// optional uint32 ts = 172;
inline bool query_response_Info_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Info_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Info_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Info_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Info_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Info_result.ts)
  return ts_;
}
inline void query_response_Info_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Info_result.ts)
}

// -------------------------------------------------------------------

// query_response_Topology_result

// required .ce.nbapi.topology msg = 181;
inline bool query_response_Topology_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Topology_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Topology_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Topology_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::topology& query_response_Topology_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::topology& query_response_Topology_result::msg() const {
  const ::ce::nbapi::topology* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Topology_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::topology*>(
      &::ce::nbapi::_topology_default_instance_);
}
inline ::ce::nbapi::topology* query_response_Topology_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Topology_result.msg)
  clear_has_msg();
  ::ce::nbapi::topology* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::topology* query_response_Topology_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::topology>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Topology_result.msg)
  return msg_;
}
inline void query_response_Topology_result::set_allocated_msg(::ce::nbapi::topology* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Topology_result.msg)
}

// optional uint32 ts = 182;
inline bool query_response_Topology_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Topology_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Topology_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Topology_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Topology_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Topology_result.ts)
  return ts_;
}
inline void query_response_Topology_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Topology_result.ts)
}

// -------------------------------------------------------------------

// query_response_Controller_result

// required .ce.nbapi.controller_info msg = 191;
inline bool query_response_Controller_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Controller_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Controller_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Controller_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::controller_info& query_response_Controller_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::controller_info& query_response_Controller_result::msg() const {
  const ::ce::nbapi::controller_info* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Controller_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::controller_info*>(
      &::ce::nbapi::_controller_info_default_instance_);
}
inline ::ce::nbapi::controller_info* query_response_Controller_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Controller_result.msg)
  clear_has_msg();
  ::ce::nbapi::controller_info* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::controller_info* query_response_Controller_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::controller_info>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Controller_result.msg)
  return msg_;
}
inline void query_response_Controller_result::set_allocated_msg(::ce::nbapi::controller_info* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Controller_result.msg)
}

// optional uint32 ts = 192;
inline bool query_response_Controller_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Controller_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Controller_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Controller_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Controller_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Controller_result.ts)
  return ts_;
}
inline void query_response_Controller_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Controller_result.ts)
}

// -------------------------------------------------------------------

// query_response_Cluster_result

// required .ce.nbapi.cluster_info msg = 201;
inline bool query_response_Cluster_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Cluster_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Cluster_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Cluster_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::cluster_info& query_response_Cluster_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::cluster_info& query_response_Cluster_result::msg() const {
  const ::ce::nbapi::cluster_info* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Cluster_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::cluster_info*>(
      &::ce::nbapi::_cluster_info_default_instance_);
}
inline ::ce::nbapi::cluster_info* query_response_Cluster_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Cluster_result.msg)
  clear_has_msg();
  ::ce::nbapi::cluster_info* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::cluster_info* query_response_Cluster_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::cluster_info>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Cluster_result.msg)
  return msg_;
}
inline void query_response_Cluster_result::set_allocated_msg(::ce::nbapi::cluster_info* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Cluster_result.msg)
}

// optional uint32 ts = 202;
inline bool query_response_Cluster_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Cluster_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Cluster_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Cluster_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Cluster_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Cluster_result.ts)
  return ts_;
}
inline void query_response_Cluster_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Cluster_result.ts)
}

// -------------------------------------------------------------------

// query_response_Access_point_location_result

// required .ce.nbapi.ap_location msg = 211;
inline bool query_response_Access_point_location_result::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response_Access_point_location_result::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response_Access_point_location_result::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response_Access_point_location_result::clear_msg() {
  if (msg_ != NULL) msg_->Clear();
  clear_has_msg();
}
inline const ::ce::nbapi::ap_location& query_response_Access_point_location_result::_internal_msg() const {
  return *msg_;
}
inline const ::ce::nbapi::ap_location& query_response_Access_point_location_result::msg() const {
  const ::ce::nbapi::ap_location* p = msg_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Access_point_location_result.msg)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ap_location*>(
      &::ce::nbapi::_ap_location_default_instance_);
}
inline ::ce::nbapi::ap_location* query_response_Access_point_location_result::release_msg() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.Access_point_location_result.msg)
  clear_has_msg();
  ::ce::nbapi::ap_location* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline ::ce::nbapi::ap_location* query_response_Access_point_location_result::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ap_location>(GetArenaNoVirtual());
    msg_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.Access_point_location_result.msg)
  return msg_;
}
inline void query_response_Access_point_location_result::set_allocated_msg(::ce::nbapi::ap_location* msg) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete msg_;
  }
  if (msg) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      msg = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, msg, submessage_arena);
    }
    set_has_msg();
  } else {
    clear_has_msg();
  }
  msg_ = msg;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.Access_point_location_result.msg)
}

// optional uint32 ts = 212;
inline bool query_response_Access_point_location_result::has_ts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void query_response_Access_point_location_result::set_has_ts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void query_response_Access_point_location_result::clear_has_ts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void query_response_Access_point_location_result::clear_ts() {
  ts_ = 0u;
  clear_has_ts();
}
inline ::google::protobuf::uint32 query_response_Access_point_location_result::ts() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.Access_point_location_result.ts)
  return ts_;
}
inline void query_response_Access_point_location_result::set_ts(::google::protobuf::uint32 value) {
  set_has_ts();
  ts_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.query_response.Access_point_location_result.ts)
}

// -------------------------------------------------------------------

// query_response

// repeated group Location_result = 10 { ... };
inline int query_response::location_result_size() const {
  return location_result_.size();
}
inline void query_response::clear_location_result() {
  location_result_.Clear();
}
inline ::ce::nbapi::query_response_Location_result* query_response::mutable_location_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.location_result)
  return location_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Location_result >*
query_response::mutable_location_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.location_result)
  return &location_result_;
}
inline const ::ce::nbapi::query_response_Location_result& query_response::location_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.location_result)
  return location_result_.Get(index);
}
inline ::ce::nbapi::query_response_Location_result* query_response::add_location_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.location_result)
  return location_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Location_result >&
query_response::location_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.location_result)
  return location_result_;
}

// repeated group Presence_result = 20 { ... };
inline int query_response::presence_result_size() const {
  return presence_result_.size();
}
inline void query_response::clear_presence_result() {
  presence_result_.Clear();
}
inline ::ce::nbapi::query_response_Presence_result* query_response::mutable_presence_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.presence_result)
  return presence_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Presence_result >*
query_response::mutable_presence_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.presence_result)
  return &presence_result_;
}
inline const ::ce::nbapi::query_response_Presence_result& query_response::presence_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.presence_result)
  return presence_result_.Get(index);
}
inline ::ce::nbapi::query_response_Presence_result* query_response::add_presence_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.presence_result)
  return presence_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Presence_result >&
query_response::presence_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.presence_result)
  return presence_result_;
}

// repeated group Rssi_result = 30 { ... };
inline int query_response::rssi_result_size() const {
  return rssi_result_.size();
}
inline void query_response::clear_rssi_result() {
  rssi_result_.Clear();
}
inline ::ce::nbapi::query_response_Rssi_result* query_response::mutable_rssi_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.rssi_result)
  return rssi_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Rssi_result >*
query_response::mutable_rssi_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.rssi_result)
  return &rssi_result_;
}
inline const ::ce::nbapi::query_response_Rssi_result& query_response::rssi_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.rssi_result)
  return rssi_result_.Get(index);
}
inline ::ce::nbapi::query_response_Rssi_result* query_response::add_rssi_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.rssi_result)
  return rssi_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Rssi_result >&
query_response::rssi_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.rssi_result)
  return rssi_result_;
}

// repeated group Station_result = 40 { ... };
inline int query_response::station_result_size() const {
  return station_result_.size();
}
inline void query_response::clear_station_result() {
  station_result_.Clear();
}
inline ::ce::nbapi::query_response_Station_result* query_response::mutable_station_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.station_result)
  return station_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Station_result >*
query_response::mutable_station_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.station_result)
  return &station_result_;
}
inline const ::ce::nbapi::query_response_Station_result& query_response::station_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.station_result)
  return station_result_.Get(index);
}
inline ::ce::nbapi::query_response_Station_result* query_response::add_station_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.station_result)
  return station_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Station_result >&
query_response::station_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.station_result)
  return station_result_;
}

// repeated group Radio_result = 50 { ... };
inline int query_response::radio_result_size() const {
  return radio_result_.size();
}
inline void query_response::clear_radio_result() {
  radio_result_.Clear();
}
inline ::ce::nbapi::query_response_Radio_result* query_response::mutable_radio_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.radio_result)
  return radio_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Radio_result >*
query_response::mutable_radio_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.radio_result)
  return &radio_result_;
}
inline const ::ce::nbapi::query_response_Radio_result& query_response::radio_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.radio_result)
  return radio_result_.Get(index);
}
inline ::ce::nbapi::query_response_Radio_result* query_response::add_radio_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.radio_result)
  return radio_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Radio_result >&
query_response::radio_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.radio_result)
  return radio_result_;
}

// repeated group Destination_result = 60 { ... };
inline int query_response::destination_result_size() const {
  return destination_result_.size();
}
inline void query_response::clear_destination_result() {
  destination_result_.Clear();
}
inline ::ce::nbapi::query_response_Destination_result* query_response::mutable_destination_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.destination_result)
  return destination_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Destination_result >*
query_response::mutable_destination_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.destination_result)
  return &destination_result_;
}
inline const ::ce::nbapi::query_response_Destination_result& query_response::destination_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.destination_result)
  return destination_result_.Get(index);
}
inline ::ce::nbapi::query_response_Destination_result* query_response::add_destination_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.destination_result)
  return destination_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Destination_result >&
query_response::destination_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.destination_result)
  return destination_result_;
}

// repeated group Application_result = 70 { ... };
inline int query_response::application_result_size() const {
  return application_result_.size();
}
inline void query_response::clear_application_result() {
  application_result_.Clear();
}
inline ::ce::nbapi::query_response_Application_result* query_response::mutable_application_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.application_result)
  return application_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Application_result >*
query_response::mutable_application_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.application_result)
  return &application_result_;
}
inline const ::ce::nbapi::query_response_Application_result& query_response::application_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.application_result)
  return application_result_.Get(index);
}
inline ::ce::nbapi::query_response_Application_result* query_response::add_application_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.application_result)
  return application_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Application_result >&
query_response::application_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.application_result)
  return application_result_;
}

// repeated group Visibility_rec_result = 80 { ... };
inline int query_response::visibility_rec_result_size() const {
  return visibility_rec_result_.size();
}
inline void query_response::clear_visibility_rec_result() {
  visibility_rec_result_.Clear();
}
inline ::ce::nbapi::query_response_Visibility_rec_result* query_response::mutable_visibility_rec_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.visibility_rec_result)
  return visibility_rec_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Visibility_rec_result >*
query_response::mutable_visibility_rec_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.visibility_rec_result)
  return &visibility_rec_result_;
}
inline const ::ce::nbapi::query_response_Visibility_rec_result& query_response::visibility_rec_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.visibility_rec_result)
  return visibility_rec_result_.Get(index);
}
inline ::ce::nbapi::query_response_Visibility_rec_result* query_response::add_visibility_rec_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.visibility_rec_result)
  return visibility_rec_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Visibility_rec_result >&
query_response::visibility_rec_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.visibility_rec_result)
  return visibility_rec_result_;
}

// repeated group Campus_result = 90 { ... };
inline int query_response::campus_result_size() const {
  return campus_result_.size();
}
inline void query_response::clear_campus_result() {
  campus_result_.Clear();
}
inline ::ce::nbapi::query_response_Campus_result* query_response::mutable_campus_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.campus_result)
  return campus_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Campus_result >*
query_response::mutable_campus_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.campus_result)
  return &campus_result_;
}
inline const ::ce::nbapi::query_response_Campus_result& query_response::campus_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.campus_result)
  return campus_result_.Get(index);
}
inline ::ce::nbapi::query_response_Campus_result* query_response::add_campus_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.campus_result)
  return campus_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Campus_result >&
query_response::campus_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.campus_result)
  return campus_result_;
}

// repeated group Building_result = 100 { ... };
inline int query_response::building_result_size() const {
  return building_result_.size();
}
inline void query_response::clear_building_result() {
  building_result_.Clear();
}
inline ::ce::nbapi::query_response_Building_result* query_response::mutable_building_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.building_result)
  return building_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Building_result >*
query_response::mutable_building_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.building_result)
  return &building_result_;
}
inline const ::ce::nbapi::query_response_Building_result& query_response::building_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.building_result)
  return building_result_.Get(index);
}
inline ::ce::nbapi::query_response_Building_result* query_response::add_building_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.building_result)
  return building_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Building_result >&
query_response::building_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.building_result)
  return building_result_;
}

// repeated group Floor_result = 110 { ... };
inline int query_response::floor_result_size() const {
  return floor_result_.size();
}
inline void query_response::clear_floor_result() {
  floor_result_.Clear();
}
inline ::ce::nbapi::query_response_Floor_result* query_response::mutable_floor_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.floor_result)
  return floor_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Floor_result >*
query_response::mutable_floor_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.floor_result)
  return &floor_result_;
}
inline const ::ce::nbapi::query_response_Floor_result& query_response::floor_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.floor_result)
  return floor_result_.Get(index);
}
inline ::ce::nbapi::query_response_Floor_result* query_response::add_floor_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.floor_result)
  return floor_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Floor_result >&
query_response::floor_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.floor_result)
  return floor_result_;
}

// repeated group Access_point_result = 120 { ... };
inline int query_response::access_point_result_size() const {
  return access_point_result_.size();
}
inline void query_response::clear_access_point_result() {
  access_point_result_.Clear();
}
inline ::ce::nbapi::query_response_Access_point_result* query_response::mutable_access_point_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.access_point_result)
  return access_point_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Access_point_result >*
query_response::mutable_access_point_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.access_point_result)
  return &access_point_result_;
}
inline const ::ce::nbapi::query_response_Access_point_result& query_response::access_point_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.access_point_result)
  return access_point_result_.Get(index);
}
inline ::ce::nbapi::query_response_Access_point_result* query_response::add_access_point_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.access_point_result)
  return access_point_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Access_point_result >&
query_response::access_point_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.access_point_result)
  return access_point_result_;
}

// repeated group Virtual_access_point_result = 130 { ... };
inline int query_response::virtual_access_point_result_size() const {
  return virtual_access_point_result_.size();
}
inline void query_response::clear_virtual_access_point_result() {
  virtual_access_point_result_.Clear();
}
inline ::ce::nbapi::query_response_Virtual_access_point_result* query_response::mutable_virtual_access_point_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.virtual_access_point_result)
  return virtual_access_point_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Virtual_access_point_result >*
query_response::mutable_virtual_access_point_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.virtual_access_point_result)
  return &virtual_access_point_result_;
}
inline const ::ce::nbapi::query_response_Virtual_access_point_result& query_response::virtual_access_point_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.virtual_access_point_result)
  return virtual_access_point_result_.Get(index);
}
inline ::ce::nbapi::query_response_Virtual_access_point_result* query_response::add_virtual_access_point_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.virtual_access_point_result)
  return virtual_access_point_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Virtual_access_point_result >&
query_response::virtual_access_point_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.virtual_access_point_result)
  return virtual_access_point_result_;
}

// repeated group Geofence_result = 140 { ... };
inline int query_response::geofence_result_size() const {
  return geofence_result_.size();
}
inline void query_response::clear_geofence_result() {
  geofence_result_.Clear();
}
inline ::ce::nbapi::query_response_Geofence_result* query_response::mutable_geofence_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.geofence_result)
  return geofence_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Geofence_result >*
query_response::mutable_geofence_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.geofence_result)
  return &geofence_result_;
}
inline const ::ce::nbapi::query_response_Geofence_result& query_response::geofence_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.geofence_result)
  return geofence_result_.Get(index);
}
inline ::ce::nbapi::query_response_Geofence_result* query_response::add_geofence_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.geofence_result)
  return geofence_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Geofence_result >&
query_response::geofence_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.geofence_result)
  return geofence_result_;
}

// repeated group Proximity_result = 150 { ... };
inline int query_response::proximity_result_size() const {
  return proximity_result_.size();
}
inline void query_response::clear_proximity_result() {
  proximity_result_.Clear();
}
inline ::ce::nbapi::query_response_Proximity_result* query_response::mutable_proximity_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.proximity_result)
  return proximity_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Proximity_result >*
query_response::mutable_proximity_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.proximity_result)
  return &proximity_result_;
}
inline const ::ce::nbapi::query_response_Proximity_result& query_response::proximity_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.proximity_result)
  return proximity_result_.Get(index);
}
inline ::ce::nbapi::query_response_Proximity_result* query_response::add_proximity_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.proximity_result)
  return proximity_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Proximity_result >&
query_response::proximity_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.proximity_result)
  return proximity_result_;
}

// repeated group WebCCCategory_result = 160 { ... };
inline int query_response::webcccategory_result_size() const {
  return webcccategory_result_.size();
}
inline void query_response::clear_webcccategory_result() {
  webcccategory_result_.Clear();
}
inline ::ce::nbapi::query_response_WebCCCategory_result* query_response::mutable_webcccategory_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.webcccategory_result)
  return webcccategory_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_WebCCCategory_result >*
query_response::mutable_webcccategory_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.webcccategory_result)
  return &webcccategory_result_;
}
inline const ::ce::nbapi::query_response_WebCCCategory_result& query_response::webcccategory_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.webcccategory_result)
  return webcccategory_result_.Get(index);
}
inline ::ce::nbapi::query_response_WebCCCategory_result* query_response::add_webcccategory_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.webcccategory_result)
  return webcccategory_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_WebCCCategory_result >&
query_response::webcccategory_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.webcccategory_result)
  return webcccategory_result_;
}

// optional group Info_result = 170 { ... };
inline bool query_response::has_info_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void query_response::set_has_info_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void query_response::clear_has_info_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void query_response::clear_info_result() {
  if (info_result_ != NULL) info_result_->Clear();
  clear_has_info_result();
}
inline const ::ce::nbapi::query_response_Info_result& query_response::_internal_info_result() const {
  return *info_result_;
}
inline const ::ce::nbapi::query_response_Info_result& query_response::info_result() const {
  const ::ce::nbapi::query_response_Info_result* p = info_result_;
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.info_result)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::query_response_Info_result*>(
      &::ce::nbapi::_query_response_Info_result_default_instance_);
}
inline ::ce::nbapi::query_response_Info_result* query_response::release_info_result() {
  // @@protoc_insertion_point(field_release:ce.nbapi.query_response.info_result)
  clear_has_info_result();
  ::ce::nbapi::query_response_Info_result* temp = info_result_;
  info_result_ = NULL;
  return temp;
}
inline ::ce::nbapi::query_response_Info_result* query_response::mutable_info_result() {
  set_has_info_result();
  if (info_result_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::query_response_Info_result>(GetArenaNoVirtual());
    info_result_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.info_result)
  return info_result_;
}
inline void query_response::set_allocated_info_result(::ce::nbapi::query_response_Info_result* info_result) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_result_;
  }
  if (info_result) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info_result = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info_result, submessage_arena);
    }
    set_has_info_result();
  } else {
    clear_has_info_result();
  }
  info_result_ = info_result;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.query_response.info_result)
}

// repeated group Topology_result = 180 { ... };
inline int query_response::topology_result_size() const {
  return topology_result_.size();
}
inline void query_response::clear_topology_result() {
  topology_result_.Clear();
}
inline ::ce::nbapi::query_response_Topology_result* query_response::mutable_topology_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.topology_result)
  return topology_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Topology_result >*
query_response::mutable_topology_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.topology_result)
  return &topology_result_;
}
inline const ::ce::nbapi::query_response_Topology_result& query_response::topology_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.topology_result)
  return topology_result_.Get(index);
}
inline ::ce::nbapi::query_response_Topology_result* query_response::add_topology_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.topology_result)
  return topology_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Topology_result >&
query_response::topology_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.topology_result)
  return topology_result_;
}

// repeated group Controller_result = 190 { ... };
inline int query_response::controller_result_size() const {
  return controller_result_.size();
}
inline void query_response::clear_controller_result() {
  controller_result_.Clear();
}
inline ::ce::nbapi::query_response_Controller_result* query_response::mutable_controller_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.controller_result)
  return controller_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Controller_result >*
query_response::mutable_controller_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.controller_result)
  return &controller_result_;
}
inline const ::ce::nbapi::query_response_Controller_result& query_response::controller_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.controller_result)
  return controller_result_.Get(index);
}
inline ::ce::nbapi::query_response_Controller_result* query_response::add_controller_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.controller_result)
  return controller_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Controller_result >&
query_response::controller_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.controller_result)
  return controller_result_;
}

// repeated group Cluster_result = 200 { ... };
inline int query_response::cluster_result_size() const {
  return cluster_result_.size();
}
inline void query_response::clear_cluster_result() {
  cluster_result_.Clear();
}
inline ::ce::nbapi::query_response_Cluster_result* query_response::mutable_cluster_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.cluster_result)
  return cluster_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Cluster_result >*
query_response::mutable_cluster_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.cluster_result)
  return &cluster_result_;
}
inline const ::ce::nbapi::query_response_Cluster_result& query_response::cluster_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.cluster_result)
  return cluster_result_.Get(index);
}
inline ::ce::nbapi::query_response_Cluster_result* query_response::add_cluster_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.cluster_result)
  return cluster_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Cluster_result >&
query_response::cluster_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.cluster_result)
  return cluster_result_;
}

// repeated group Access_point_location_result = 210 { ... };
inline int query_response::access_point_location_result_size() const {
  return access_point_location_result_.size();
}
inline void query_response::clear_access_point_location_result() {
  access_point_location_result_.Clear();
}
inline ::ce::nbapi::query_response_Access_point_location_result* query_response::mutable_access_point_location_result(int index) {
  // @@protoc_insertion_point(field_mutable:ce.nbapi.query_response.access_point_location_result)
  return access_point_location_result_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Access_point_location_result >*
query_response::mutable_access_point_location_result() {
  // @@protoc_insertion_point(field_mutable_list:ce.nbapi.query_response.access_point_location_result)
  return &access_point_location_result_;
}
inline const ::ce::nbapi::query_response_Access_point_location_result& query_response::access_point_location_result(int index) const {
  // @@protoc_insertion_point(field_get:ce.nbapi.query_response.access_point_location_result)
  return access_point_location_result_.Get(index);
}
inline ::ce::nbapi::query_response_Access_point_location_result* query_response::add_access_point_location_result() {
  // @@protoc_insertion_point(field_add:ce.nbapi.query_response.access_point_location_result)
  return access_point_location_result_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ce::nbapi::query_response_Access_point_location_result >&
query_response::access_point_location_result() const {
  // @@protoc_insertion_point(field_list:ce.nbapi.query_response.access_point_location_result)
  return access_point_location_result_;
}

// -------------------------------------------------------------------

// iap_client_url

// optional .ce.nbapi.iap_message_info info = 1;
inline bool iap_client_url::has_info() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void iap_client_url::set_has_info() {
  _has_bits_[0] |= 0x00000002u;
}
inline void iap_client_url::clear_has_info() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void iap_client_url::clear_info() {
  if (info_ != NULL) info_->Clear();
  clear_has_info();
}
inline const ::ce::nbapi::iap_message_info& iap_client_url::_internal_info() const {
  return *info_;
}
inline const ::ce::nbapi::iap_message_info& iap_client_url::info() const {
  const ::ce::nbapi::iap_message_info* p = info_;
  // @@protoc_insertion_point(field_get:ce.nbapi.iap_client_url.info)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::iap_message_info*>(
      &::ce::nbapi::_iap_message_info_default_instance_);
}
inline ::ce::nbapi::iap_message_info* iap_client_url::release_info() {
  // @@protoc_insertion_point(field_release:ce.nbapi.iap_client_url.info)
  clear_has_info();
  ::ce::nbapi::iap_message_info* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::ce::nbapi::iap_message_info* iap_client_url::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::iap_message_info>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.iap_client_url.info)
  return info_;
}
inline void iap_client_url::set_allocated_info(::ce::nbapi::iap_message_info* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    set_has_info();
  } else {
    clear_has_info();
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.iap_client_url.info)
}

// optional uint64 timestamp = 2;
inline bool iap_client_url::has_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void iap_client_url::set_has_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void iap_client_url::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void iap_client_url::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 iap_client_url::timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.iap_client_url.timestamp)
  return timestamp_;
}
inline void iap_client_url::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.iap_client_url.timestamp)
}

// optional .ce.nbapi.mac_address ap_mac = 3;
inline bool iap_client_url::has_ap_mac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void iap_client_url::set_has_ap_mac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void iap_client_url::clear_has_ap_mac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void iap_client_url::clear_ap_mac() {
  if (ap_mac_ != NULL) ap_mac_->Clear();
  clear_has_ap_mac();
}
inline const ::ce::nbapi::mac_address& iap_client_url::_internal_ap_mac() const {
  return *ap_mac_;
}
inline const ::ce::nbapi::mac_address& iap_client_url::ap_mac() const {
  const ::ce::nbapi::mac_address* p = ap_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.iap_client_url.ap_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* iap_client_url::release_ap_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.iap_client_url.ap_mac)
  clear_has_ap_mac();
  ::ce::nbapi::mac_address* temp = ap_mac_;
  ap_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* iap_client_url::mutable_ap_mac() {
  set_has_ap_mac();
  if (ap_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    ap_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.iap_client_url.ap_mac)
  return ap_mac_;
}
inline void iap_client_url::set_allocated_ap_mac(::ce::nbapi::mac_address* ap_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ap_mac_;
  }
  if (ap_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ap_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ap_mac, submessage_arena);
    }
    set_has_ap_mac();
  } else {
    clear_has_ap_mac();
  }
  ap_mac_ = ap_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.iap_client_url.ap_mac)
}

// optional .ce.nbapi.url_detail_record url_record = 4;
inline bool iap_client_url::has_url_record() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void iap_client_url::set_has_url_record() {
  _has_bits_[0] |= 0x00000008u;
}
inline void iap_client_url::clear_has_url_record() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void iap_client_url::clear_url_record() {
  if (url_record_ != NULL) url_record_->Clear();
  clear_has_url_record();
}
inline const ::ce::nbapi::url_detail_record& iap_client_url::_internal_url_record() const {
  return *url_record_;
}
inline const ::ce::nbapi::url_detail_record& iap_client_url::url_record() const {
  const ::ce::nbapi::url_detail_record* p = url_record_;
  // @@protoc_insertion_point(field_get:ce.nbapi.iap_client_url.url_record)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::url_detail_record*>(
      &::ce::nbapi::_url_detail_record_default_instance_);
}
inline ::ce::nbapi::url_detail_record* iap_client_url::release_url_record() {
  // @@protoc_insertion_point(field_release:ce.nbapi.iap_client_url.url_record)
  clear_has_url_record();
  ::ce::nbapi::url_detail_record* temp = url_record_;
  url_record_ = NULL;
  return temp;
}
inline ::ce::nbapi::url_detail_record* iap_client_url::mutable_url_record() {
  set_has_url_record();
  if (url_record_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::url_detail_record>(GetArenaNoVirtual());
    url_record_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.iap_client_url.url_record)
  return url_record_;
}
inline void iap_client_url::set_allocated_url_record(::ce::nbapi::url_detail_record* url_record) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete url_record_;
  }
  if (url_record) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      url_record = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, url_record, submessage_arena);
    }
    set_has_url_record();
  } else {
    clear_has_url_record();
  }
  url_record_ = url_record;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.iap_client_url.url_record)
}

// optional string ap_host_name = 5;
inline bool iap_client_url::has_ap_host_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void iap_client_url::set_has_ap_host_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void iap_client_url::clear_has_ap_host_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void iap_client_url::clear_ap_host_name() {
  ap_host_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ap_host_name();
}
inline const ::std::string& iap_client_url::ap_host_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.iap_client_url.ap_host_name)
  return ap_host_name_.GetNoArena();
}
inline void iap_client_url::set_ap_host_name(const ::std::string& value) {
  set_has_ap_host_name();
  ap_host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.iap_client_url.ap_host_name)
}
#if LANG_CXX11
inline void iap_client_url::set_ap_host_name(::std::string&& value) {
  set_has_ap_host_name();
  ap_host_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.iap_client_url.ap_host_name)
}
#endif
inline void iap_client_url::set_ap_host_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_ap_host_name();
  ap_host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.iap_client_url.ap_host_name)
}
inline void iap_client_url::set_ap_host_name(const char* value, size_t size) {
  set_has_ap_host_name();
  ap_host_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.iap_client_url.ap_host_name)
}
inline ::std::string* iap_client_url::mutable_ap_host_name() {
  set_has_ap_host_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.iap_client_url.ap_host_name)
  return ap_host_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* iap_client_url::release_ap_host_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.iap_client_url.ap_host_name)
  if (!has_ap_host_name()) {
    return NULL;
  }
  clear_has_ap_host_name();
  return ap_host_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void iap_client_url::set_allocated_ap_host_name(::std::string* ap_host_name) {
  if (ap_host_name != NULL) {
    set_has_ap_host_name();
  } else {
    clear_has_ap_host_name();
  }
  ap_host_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ap_host_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.iap_client_url.ap_host_name)
}

// -------------------------------------------------------------------

// url_detail_record

// optional .ce.nbapi.ip_address client_ip = 1;
inline bool url_detail_record::has_client_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void url_detail_record::set_has_client_ip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void url_detail_record::clear_has_client_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void url_detail_record::clear_client_ip() {
  if (client_ip_ != NULL) client_ip_->Clear();
  clear_has_client_ip();
}
inline const ::ce::nbapi::ip_address& url_detail_record::_internal_client_ip() const {
  return *client_ip_;
}
inline const ::ce::nbapi::ip_address& url_detail_record::client_ip() const {
  const ::ce::nbapi::ip_address* p = client_ip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.url_detail_record.client_ip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* url_detail_record::release_client_ip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.url_detail_record.client_ip)
  clear_has_client_ip();
  ::ce::nbapi::ip_address* temp = client_ip_;
  client_ip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* url_detail_record::mutable_client_ip() {
  set_has_client_ip();
  if (client_ip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    client_ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.url_detail_record.client_ip)
  return client_ip_;
}
inline void url_detail_record::set_allocated_client_ip(::ce::nbapi::ip_address* client_ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete client_ip_;
  }
  if (client_ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_ip, submessage_arena);
    }
    set_has_client_ip();
  } else {
    clear_has_client_ip();
  }
  client_ip_ = client_ip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.url_detail_record.client_ip)
}

// optional .ce.nbapi.ip_address dest_ip = 2;
inline bool url_detail_record::has_dest_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void url_detail_record::set_has_dest_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void url_detail_record::clear_has_dest_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void url_detail_record::clear_dest_ip() {
  if (dest_ip_ != NULL) dest_ip_->Clear();
  clear_has_dest_ip();
}
inline const ::ce::nbapi::ip_address& url_detail_record::_internal_dest_ip() const {
  return *dest_ip_;
}
inline const ::ce::nbapi::ip_address& url_detail_record::dest_ip() const {
  const ::ce::nbapi::ip_address* p = dest_ip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.url_detail_record.dest_ip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* url_detail_record::release_dest_ip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.url_detail_record.dest_ip)
  clear_has_dest_ip();
  ::ce::nbapi::ip_address* temp = dest_ip_;
  dest_ip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* url_detail_record::mutable_dest_ip() {
  set_has_dest_ip();
  if (dest_ip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    dest_ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.url_detail_record.dest_ip)
  return dest_ip_;
}
inline void url_detail_record::set_allocated_dest_ip(::ce::nbapi::ip_address* dest_ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete dest_ip_;
  }
  if (dest_ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dest_ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dest_ip, submessage_arena);
    }
    set_has_dest_ip();
  } else {
    clear_has_dest_ip();
  }
  dest_ip_ = dest_ip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.url_detail_record.dest_ip)
}

// optional bytes url = 3;
inline bool url_detail_record::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void url_detail_record::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void url_detail_record::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void url_detail_record::clear_url() {
  url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_url();
}
inline const ::std::string& url_detail_record::url() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.url_detail_record.url)
  return url_.GetNoArena();
}
inline void url_detail_record::set_url(const ::std::string& value) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.url_detail_record.url)
}
#if LANG_CXX11
inline void url_detail_record::set_url(::std::string&& value) {
  set_has_url();
  url_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.url_detail_record.url)
}
#endif
inline void url_detail_record::set_url(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.url_detail_record.url)
}
inline void url_detail_record::set_url(const void* value, size_t size) {
  set_has_url();
  url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.url_detail_record.url)
}
inline ::std::string* url_detail_record::mutable_url() {
  set_has_url();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.url_detail_record.url)
  return url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* url_detail_record::release_url() {
  // @@protoc_insertion_point(field_release:ce.nbapi.url_detail_record.url)
  if (!has_url()) {
    return NULL;
  }
  clear_has_url();
  return url_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void url_detail_record::set_allocated_url(::std::string* url) {
  if (url != NULL) {
    set_has_url();
  } else {
    clear_has_url();
  }
  url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), url);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.url_detail_record.url)
}

// optional uint32 hit_count = 4;
inline bool url_detail_record::has_hit_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void url_detail_record::set_has_hit_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void url_detail_record::clear_has_hit_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void url_detail_record::clear_hit_count() {
  hit_count_ = 0u;
  clear_has_hit_count();
}
inline ::google::protobuf::uint32 url_detail_record::hit_count() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.url_detail_record.hit_count)
  return hit_count_;
}
inline void url_detail_record::set_hit_count(::google::protobuf::uint32 value) {
  set_has_hit_count();
  hit_count_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.url_detail_record.hit_count)
}

// optional .ce.nbapi.mac_address client_mac = 5;
inline bool url_detail_record::has_client_mac() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void url_detail_record::set_has_client_mac() {
  _has_bits_[0] |= 0x00000008u;
}
inline void url_detail_record::clear_has_client_mac() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void url_detail_record::clear_client_mac() {
  if (client_mac_ != NULL) client_mac_->Clear();
  clear_has_client_mac();
}
inline const ::ce::nbapi::mac_address& url_detail_record::_internal_client_mac() const {
  return *client_mac_;
}
inline const ::ce::nbapi::mac_address& url_detail_record::client_mac() const {
  const ::ce::nbapi::mac_address* p = client_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.url_detail_record.client_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* url_detail_record::release_client_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.url_detail_record.client_mac)
  clear_has_client_mac();
  ::ce::nbapi::mac_address* temp = client_mac_;
  client_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* url_detail_record::mutable_client_mac() {
  set_has_client_mac();
  if (client_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    client_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.url_detail_record.client_mac)
  return client_mac_;
}
inline void url_detail_record::set_allocated_client_mac(::ce::nbapi::mac_address* client_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete client_mac_;
  }
  if (client_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      client_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, client_mac, submessage_arena);
    }
    set_has_client_mac();
  } else {
    clear_has_client_mac();
  }
  client_mac_ = client_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.url_detail_record.client_mac)
}

// optional .ce.nbapi.url_detail_record.url_http_method http_method = 6;
inline bool url_detail_record::has_http_method() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void url_detail_record::set_has_http_method() {
  _has_bits_[0] |= 0x00000040u;
}
inline void url_detail_record::clear_has_http_method() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void url_detail_record::clear_http_method() {
  http_method_ = 1;
  clear_has_http_method();
}
inline ::ce::nbapi::url_detail_record_url_http_method url_detail_record::http_method() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.url_detail_record.http_method)
  return static_cast< ::ce::nbapi::url_detail_record_url_http_method >(http_method_);
}
inline void url_detail_record::set_http_method(::ce::nbapi::url_detail_record_url_http_method value) {
  assert(::ce::nbapi::url_detail_record_url_http_method_IsValid(value));
  set_has_http_method();
  http_method_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.url_detail_record.http_method)
}

// optional uint64 last_hit_timestamp = 7;
inline bool url_detail_record::has_last_hit_timestamp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void url_detail_record::set_has_last_hit_timestamp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void url_detail_record::clear_has_last_hit_timestamp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void url_detail_record::clear_last_hit_timestamp() {
  last_hit_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_last_hit_timestamp();
}
inline ::google::protobuf::uint64 url_detail_record::last_hit_timestamp() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.url_detail_record.last_hit_timestamp)
  return last_hit_timestamp_;
}
inline void url_detail_record::set_last_hit_timestamp(::google::protobuf::uint64 value) {
  set_has_last_hit_timestamp();
  last_hit_timestamp_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.url_detail_record.last_hit_timestamp)
}

// -------------------------------------------------------------------

// iap_message_info

// optional uint32 version = 1;
inline bool iap_message_info::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void iap_message_info::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void iap_message_info::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void iap_message_info::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 iap_message_info::version() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.iap_message_info.version)
  return version_;
}
inline void iap_message_info::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.iap_message_info.version)
}

// optional uint64 sequence = 3;
inline bool iap_message_info::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void iap_message_info::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void iap_message_info::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void iap_message_info::clear_sequence() {
  sequence_ = GOOGLE_ULONGLONG(0);
  clear_has_sequence();
}
inline ::google::protobuf::uint64 iap_message_info::sequence() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.iap_message_info.sequence)
  return sequence_;
}
inline void iap_message_info::set_sequence(::google::protobuf::uint64 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.iap_message_info.sequence)
}

// optional bytes guid = 4;
inline bool iap_message_info::has_guid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void iap_message_info::set_has_guid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void iap_message_info::clear_has_guid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void iap_message_info::clear_guid() {
  guid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_guid();
}
inline const ::std::string& iap_message_info::guid() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.iap_message_info.guid)
  return guid_.GetNoArena();
}
inline void iap_message_info::set_guid(const ::std::string& value) {
  set_has_guid();
  guid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.iap_message_info.guid)
}
#if LANG_CXX11
inline void iap_message_info::set_guid(::std::string&& value) {
  set_has_guid();
  guid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.iap_message_info.guid)
}
#endif
inline void iap_message_info::set_guid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_guid();
  guid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.iap_message_info.guid)
}
inline void iap_message_info::set_guid(const void* value, size_t size) {
  set_has_guid();
  guid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.iap_message_info.guid)
}
inline ::std::string* iap_message_info::mutable_guid() {
  set_has_guid();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.iap_message_info.guid)
  return guid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* iap_message_info::release_guid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.iap_message_info.guid)
  if (!has_guid()) {
    return NULL;
  }
  clear_has_guid();
  return guid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void iap_message_info::set_allocated_guid(::std::string* guid) {
  if (guid != NULL) {
    set_has_guid();
  } else {
    clear_has_guid();
  }
  guid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), guid);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.iap_message_info.guid)
}

// optional string oem_tag = 5;
inline bool iap_message_info::has_oem_tag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void iap_message_info::set_has_oem_tag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void iap_message_info::clear_has_oem_tag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void iap_message_info::clear_oem_tag() {
  oem_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_oem_tag();
}
inline const ::std::string& iap_message_info::oem_tag() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.iap_message_info.oem_tag)
  return oem_tag_.GetNoArena();
}
inline void iap_message_info::set_oem_tag(const ::std::string& value) {
  set_has_oem_tag();
  oem_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.iap_message_info.oem_tag)
}
#if LANG_CXX11
inline void iap_message_info::set_oem_tag(::std::string&& value) {
  set_has_oem_tag();
  oem_tag_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.iap_message_info.oem_tag)
}
#endif
inline void iap_message_info::set_oem_tag(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_oem_tag();
  oem_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.iap_message_info.oem_tag)
}
inline void iap_message_info::set_oem_tag(const char* value, size_t size) {
  set_has_oem_tag();
  oem_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.iap_message_info.oem_tag)
}
inline ::std::string* iap_message_info::mutable_oem_tag() {
  set_has_oem_tag();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.iap_message_info.oem_tag)
  return oem_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* iap_message_info::release_oem_tag() {
  // @@protoc_insertion_point(field_release:ce.nbapi.iap_message_info.oem_tag)
  if (!has_oem_tag()) {
    return NULL;
  }
  clear_has_oem_tag();
  return oem_tag_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void iap_message_info::set_allocated_oem_tag(::std::string* oem_tag) {
  if (oem_tag != NULL) {
    set_has_oem_tag();
  } else {
    clear_has_oem_tag();
  }
  oem_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), oem_tag);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.iap_message_info.oem_tag)
}

// -------------------------------------------------------------------

// air_monitor_info

// optional .ce.nbapi.mac_address monitor_mac = 1;
inline bool air_monitor_info::has_monitor_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void air_monitor_info::set_has_monitor_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void air_monitor_info::clear_has_monitor_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void air_monitor_info::clear_monitor_mac() {
  if (monitor_mac_ != NULL) monitor_mac_->Clear();
  clear_has_monitor_mac();
}
inline const ::ce::nbapi::mac_address& air_monitor_info::_internal_monitor_mac() const {
  return *monitor_mac_;
}
inline const ::ce::nbapi::mac_address& air_monitor_info::monitor_mac() const {
  const ::ce::nbapi::mac_address* p = monitor_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_info.monitor_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* air_monitor_info::release_monitor_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.air_monitor_info.monitor_mac)
  clear_has_monitor_mac();
  ::ce::nbapi::mac_address* temp = monitor_mac_;
  monitor_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* air_monitor_info::mutable_monitor_mac() {
  set_has_monitor_mac();
  if (monitor_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    monitor_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.air_monitor_info.monitor_mac)
  return monitor_mac_;
}
inline void air_monitor_info::set_allocated_monitor_mac(::ce::nbapi::mac_address* monitor_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete monitor_mac_;
  }
  if (monitor_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      monitor_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, monitor_mac, submessage_arena);
    }
    set_has_monitor_mac();
  } else {
    clear_has_monitor_mac();
  }
  monitor_mac_ = monitor_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.air_monitor_info.monitor_mac)
}

// optional bytes essid = 2;
inline bool air_monitor_info::has_essid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void air_monitor_info::set_has_essid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void air_monitor_info::clear_has_essid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void air_monitor_info::clear_essid() {
  essid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_essid();
}
inline const ::std::string& air_monitor_info::essid() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_info.essid)
  return essid_.GetNoArena();
}
inline void air_monitor_info::set_essid(const ::std::string& value) {
  set_has_essid();
  essid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.air_monitor_info.essid)
}
#if LANG_CXX11
inline void air_monitor_info::set_essid(::std::string&& value) {
  set_has_essid();
  essid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.air_monitor_info.essid)
}
#endif
inline void air_monitor_info::set_essid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_essid();
  essid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.air_monitor_info.essid)
}
inline void air_monitor_info::set_essid(const void* value, size_t size) {
  set_has_essid();
  essid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.air_monitor_info.essid)
}
inline ::std::string* air_monitor_info::mutable_essid() {
  set_has_essid();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.air_monitor_info.essid)
  return essid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* air_monitor_info::release_essid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.air_monitor_info.essid)
  if (!has_essid()) {
    return NULL;
  }
  clear_has_essid();
  return essid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void air_monitor_info::set_allocated_essid(::std::string* essid) {
  if (essid != NULL) {
    set_has_essid();
  } else {
    clear_has_essid();
  }
  essid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), essid);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.air_monitor_info.essid)
}

// optional uint32 monitor_channel = 3;
inline bool air_monitor_info::has_monitor_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void air_monitor_info::set_has_monitor_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void air_monitor_info::clear_has_monitor_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void air_monitor_info::clear_monitor_channel() {
  monitor_channel_ = 0u;
  clear_has_monitor_channel();
}
inline ::google::protobuf::uint32 air_monitor_info::monitor_channel() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_info.monitor_channel)
  return monitor_channel_;
}
inline void air_monitor_info::set_monitor_channel(::google::protobuf::uint32 value) {
  set_has_monitor_channel();
  monitor_channel_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.air_monitor_info.monitor_channel)
}

// optional uint32 is_ap = 4;
inline bool air_monitor_info::has_is_ap() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void air_monitor_info::set_has_is_ap() {
  _has_bits_[0] |= 0x00000040u;
}
inline void air_monitor_info::clear_has_is_ap() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void air_monitor_info::clear_is_ap() {
  is_ap_ = 0u;
  clear_has_is_ap();
}
inline ::google::protobuf::uint32 air_monitor_info::is_ap() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_info.is_ap)
  return is_ap_;
}
inline void air_monitor_info::set_is_ap(::google::protobuf::uint32 value) {
  set_has_is_ap();
  is_ap_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.air_monitor_info.is_ap)
}

// optional uint32 classification_type = 5;
inline bool air_monitor_info::has_classification_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void air_monitor_info::set_has_classification_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void air_monitor_info::clear_has_classification_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void air_monitor_info::clear_classification_type() {
  classification_type_ = 0u;
  clear_has_classification_type();
}
inline ::google::protobuf::uint32 air_monitor_info::classification_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_info.classification_type)
  return classification_type_;
}
inline void air_monitor_info::set_classification_type(::google::protobuf::uint32 value) {
  set_has_classification_type();
  classification_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.air_monitor_info.classification_type)
}

// optional uint32 phy_type = 6;
inline bool air_monitor_info::has_phy_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void air_monitor_info::set_has_phy_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void air_monitor_info::clear_has_phy_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void air_monitor_info::clear_phy_type() {
  phy_type_ = 0u;
  clear_has_phy_type();
}
inline ::google::protobuf::uint32 air_monitor_info::phy_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_info.phy_type)
  return phy_type_;
}
inline void air_monitor_info::set_phy_type(::google::protobuf::uint32 value) {
  set_has_phy_type();
  phy_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.air_monitor_info.phy_type)
}

// optional uint32 ht_type = 7;
inline bool air_monitor_info::has_ht_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void air_monitor_info::set_has_ht_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void air_monitor_info::clear_has_ht_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void air_monitor_info::clear_ht_type() {
  ht_type_ = 0u;
  clear_has_ht_type();
}
inline ::google::protobuf::uint32 air_monitor_info::ht_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_info.ht_type)
  return ht_type_;
}
inline void air_monitor_info::set_ht_type(::google::protobuf::uint32 value) {
  set_has_ht_type();
  ht_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.air_monitor_info.ht_type)
}

// optional .ce.nbapi.mac_address heard_mac = 8;
inline bool air_monitor_info::has_heard_mac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void air_monitor_info::set_has_heard_mac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void air_monitor_info::clear_has_heard_mac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void air_monitor_info::clear_heard_mac() {
  if (heard_mac_ != NULL) heard_mac_->Clear();
  clear_has_heard_mac();
}
inline const ::ce::nbapi::mac_address& air_monitor_info::_internal_heard_mac() const {
  return *heard_mac_;
}
inline const ::ce::nbapi::mac_address& air_monitor_info::heard_mac() const {
  const ::ce::nbapi::mac_address* p = heard_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_info.heard_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* air_monitor_info::release_heard_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.air_monitor_info.heard_mac)
  clear_has_heard_mac();
  ::ce::nbapi::mac_address* temp = heard_mac_;
  heard_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* air_monitor_info::mutable_heard_mac() {
  set_has_heard_mac();
  if (heard_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    heard_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.air_monitor_info.heard_mac)
  return heard_mac_;
}
inline void air_monitor_info::set_allocated_heard_mac(::ce::nbapi::mac_address* heard_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete heard_mac_;
  }
  if (heard_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      heard_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, heard_mac, submessage_arena);
    }
    set_has_heard_mac();
  } else {
    clear_has_heard_mac();
  }
  heard_mac_ = heard_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.air_monitor_info.heard_mac)
}

// optional .ce.nbapi.mac_address bssid = 9;
inline bool air_monitor_info::has_bssid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void air_monitor_info::set_has_bssid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void air_monitor_info::clear_has_bssid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void air_monitor_info::clear_bssid() {
  if (bssid_ != NULL) bssid_->Clear();
  clear_has_bssid();
}
inline const ::ce::nbapi::mac_address& air_monitor_info::_internal_bssid() const {
  return *bssid_;
}
inline const ::ce::nbapi::mac_address& air_monitor_info::bssid() const {
  const ::ce::nbapi::mac_address* p = bssid_;
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_info.bssid)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* air_monitor_info::release_bssid() {
  // @@protoc_insertion_point(field_release:ce.nbapi.air_monitor_info.bssid)
  clear_has_bssid();
  ::ce::nbapi::mac_address* temp = bssid_;
  bssid_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* air_monitor_info::mutable_bssid() {
  set_has_bssid();
  if (bssid_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    bssid_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.air_monitor_info.bssid)
  return bssid_;
}
inline void air_monitor_info::set_allocated_bssid(::ce::nbapi::mac_address* bssid) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete bssid_;
  }
  if (bssid) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      bssid = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, bssid, submessage_arena);
    }
    set_has_bssid();
  } else {
    clear_has_bssid();
  }
  bssid_ = bssid;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.air_monitor_info.bssid)
}

// optional uint32 encr_type = 10;
inline bool air_monitor_info::has_encr_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void air_monitor_info::set_has_encr_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void air_monitor_info::clear_has_encr_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void air_monitor_info::clear_encr_type() {
  encr_type_ = 0u;
  clear_has_encr_type();
}
inline ::google::protobuf::uint32 air_monitor_info::encr_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_info.encr_type)
  return encr_type_;
}
inline void air_monitor_info::set_encr_type(::google::protobuf::uint32 value) {
  set_has_encr_type();
  encr_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.air_monitor_info.encr_type)
}

// optional uint32 encr_cipher = 11;
inline bool air_monitor_info::has_encr_cipher() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void air_monitor_info::set_has_encr_cipher() {
  _has_bits_[0] |= 0x00000800u;
}
inline void air_monitor_info::clear_has_encr_cipher() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void air_monitor_info::clear_encr_cipher() {
  encr_cipher_ = 0u;
  clear_has_encr_cipher();
}
inline ::google::protobuf::uint32 air_monitor_info::encr_cipher() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_info.encr_cipher)
  return encr_cipher_;
}
inline void air_monitor_info::set_encr_cipher(::google::protobuf::uint32 value) {
  set_has_encr_cipher();
  encr_cipher_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.air_monitor_info.encr_cipher)
}

// optional uint32 auth_alg = 12;
inline bool air_monitor_info::has_auth_alg() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void air_monitor_info::set_has_auth_alg() {
  _has_bits_[0] |= 0x00001000u;
}
inline void air_monitor_info::clear_has_auth_alg() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void air_monitor_info::clear_auth_alg() {
  auth_alg_ = 0u;
  clear_has_auth_alg();
}
inline ::google::protobuf::uint32 air_monitor_info::auth_alg() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_info.auth_alg)
  return auth_alg_;
}
inline void air_monitor_info::set_auth_alg(::google::protobuf::uint32 value) {
  set_has_auth_alg();
  auth_alg_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.air_monitor_info.auth_alg)
}

// optional .ce.nbapi.air_monitor_rogue_info am_rogue = 13;
inline bool air_monitor_info::has_am_rogue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void air_monitor_info::set_has_am_rogue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void air_monitor_info::clear_has_am_rogue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void air_monitor_info::clear_am_rogue() {
  if (am_rogue_ != NULL) am_rogue_->Clear();
  clear_has_am_rogue();
}
inline const ::ce::nbapi::air_monitor_rogue_info& air_monitor_info::_internal_am_rogue() const {
  return *am_rogue_;
}
inline const ::ce::nbapi::air_monitor_rogue_info& air_monitor_info::am_rogue() const {
  const ::ce::nbapi::air_monitor_rogue_info* p = am_rogue_;
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_info.am_rogue)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::air_monitor_rogue_info*>(
      &::ce::nbapi::_air_monitor_rogue_info_default_instance_);
}
inline ::ce::nbapi::air_monitor_rogue_info* air_monitor_info::release_am_rogue() {
  // @@protoc_insertion_point(field_release:ce.nbapi.air_monitor_info.am_rogue)
  clear_has_am_rogue();
  ::ce::nbapi::air_monitor_rogue_info* temp = am_rogue_;
  am_rogue_ = NULL;
  return temp;
}
inline ::ce::nbapi::air_monitor_rogue_info* air_monitor_info::mutable_am_rogue() {
  set_has_am_rogue();
  if (am_rogue_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::air_monitor_rogue_info>(GetArenaNoVirtual());
    am_rogue_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.air_monitor_info.am_rogue)
  return am_rogue_;
}
inline void air_monitor_info::set_allocated_am_rogue(::ce::nbapi::air_monitor_rogue_info* am_rogue) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete am_rogue_;
  }
  if (am_rogue) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      am_rogue = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, am_rogue, submessage_arena);
    }
    set_has_am_rogue();
  } else {
    clear_has_am_rogue();
  }
  am_rogue_ = am_rogue;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.air_monitor_info.am_rogue)
}

// -------------------------------------------------------------------

// air_monitor_rogue_info

// optional uint32 match_type = 1;
inline bool air_monitor_rogue_info::has_match_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void air_monitor_rogue_info::set_has_match_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void air_monitor_rogue_info::clear_has_match_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void air_monitor_rogue_info::clear_match_type() {
  match_type_ = 0u;
  clear_has_match_type();
}
inline ::google::protobuf::uint32 air_monitor_rogue_info::match_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_rogue_info.match_type)
  return match_type_;
}
inline void air_monitor_rogue_info::set_match_type(::google::protobuf::uint32 value) {
  set_has_match_type();
  match_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.air_monitor_rogue_info.match_type)
}

// optional .ce.nbapi.mac_address match_mac = 2;
inline bool air_monitor_rogue_info::has_match_mac() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void air_monitor_rogue_info::set_has_match_mac() {
  _has_bits_[0] |= 0x00000002u;
}
inline void air_monitor_rogue_info::clear_has_match_mac() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void air_monitor_rogue_info::clear_match_mac() {
  if (match_mac_ != NULL) match_mac_->Clear();
  clear_has_match_mac();
}
inline const ::ce::nbapi::mac_address& air_monitor_rogue_info::_internal_match_mac() const {
  return *match_mac_;
}
inline const ::ce::nbapi::mac_address& air_monitor_rogue_info::match_mac() const {
  const ::ce::nbapi::mac_address* p = match_mac_;
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_rogue_info.match_mac)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::mac_address*>(
      &::ce::nbapi::_mac_address_default_instance_);
}
inline ::ce::nbapi::mac_address* air_monitor_rogue_info::release_match_mac() {
  // @@protoc_insertion_point(field_release:ce.nbapi.air_monitor_rogue_info.match_mac)
  clear_has_match_mac();
  ::ce::nbapi::mac_address* temp = match_mac_;
  match_mac_ = NULL;
  return temp;
}
inline ::ce::nbapi::mac_address* air_monitor_rogue_info::mutable_match_mac() {
  set_has_match_mac();
  if (match_mac_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::mac_address>(GetArenaNoVirtual());
    match_mac_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.air_monitor_rogue_info.match_mac)
  return match_mac_;
}
inline void air_monitor_rogue_info::set_allocated_match_mac(::ce::nbapi::mac_address* match_mac) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete match_mac_;
  }
  if (match_mac) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      match_mac = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, match_mac, submessage_arena);
    }
    set_has_match_mac();
  } else {
    clear_has_match_mac();
  }
  match_mac_ = match_mac;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.air_monitor_rogue_info.match_mac)
}

// optional .ce.nbapi.ip_address match_ip = 3;
inline bool air_monitor_rogue_info::has_match_ip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void air_monitor_rogue_info::set_has_match_ip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void air_monitor_rogue_info::clear_has_match_ip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void air_monitor_rogue_info::clear_match_ip() {
  if (match_ip_ != NULL) match_ip_->Clear();
  clear_has_match_ip();
}
inline const ::ce::nbapi::ip_address& air_monitor_rogue_info::_internal_match_ip() const {
  return *match_ip_;
}
inline const ::ce::nbapi::ip_address& air_monitor_rogue_info::match_ip() const {
  const ::ce::nbapi::ip_address* p = match_ip_;
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_rogue_info.match_ip)
  return p != NULL ? *p : *reinterpret_cast<const ::ce::nbapi::ip_address*>(
      &::ce::nbapi::_ip_address_default_instance_);
}
inline ::ce::nbapi::ip_address* air_monitor_rogue_info::release_match_ip() {
  // @@protoc_insertion_point(field_release:ce.nbapi.air_monitor_rogue_info.match_ip)
  clear_has_match_ip();
  ::ce::nbapi::ip_address* temp = match_ip_;
  match_ip_ = NULL;
  return temp;
}
inline ::ce::nbapi::ip_address* air_monitor_rogue_info::mutable_match_ip() {
  set_has_match_ip();
  if (match_ip_ == NULL) {
    auto* p = CreateMaybeMessage<::ce::nbapi::ip_address>(GetArenaNoVirtual());
    match_ip_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ce.nbapi.air_monitor_rogue_info.match_ip)
  return match_ip_;
}
inline void air_monitor_rogue_info::set_allocated_match_ip(::ce::nbapi::ip_address* match_ip) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete match_ip_;
  }
  if (match_ip) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      match_ip = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, match_ip, submessage_arena);
    }
    set_has_match_ip();
  } else {
    clear_has_match_ip();
  }
  match_ip_ = match_ip;
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.air_monitor_rogue_info.match_ip)
}

// optional string monitor_name = 4;
inline bool air_monitor_rogue_info::has_monitor_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void air_monitor_rogue_info::set_has_monitor_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void air_monitor_rogue_info::clear_has_monitor_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void air_monitor_rogue_info::clear_monitor_name() {
  monitor_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_monitor_name();
}
inline const ::std::string& air_monitor_rogue_info::monitor_name() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_rogue_info.monitor_name)
  return monitor_name_.GetNoArena();
}
inline void air_monitor_rogue_info::set_monitor_name(const ::std::string& value) {
  set_has_monitor_name();
  monitor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:ce.nbapi.air_monitor_rogue_info.monitor_name)
}
#if LANG_CXX11
inline void air_monitor_rogue_info::set_monitor_name(::std::string&& value) {
  set_has_monitor_name();
  monitor_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:ce.nbapi.air_monitor_rogue_info.monitor_name)
}
#endif
inline void air_monitor_rogue_info::set_monitor_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_monitor_name();
  monitor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:ce.nbapi.air_monitor_rogue_info.monitor_name)
}
inline void air_monitor_rogue_info::set_monitor_name(const char* value, size_t size) {
  set_has_monitor_name();
  monitor_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:ce.nbapi.air_monitor_rogue_info.monitor_name)
}
inline ::std::string* air_monitor_rogue_info::mutable_monitor_name() {
  set_has_monitor_name();
  // @@protoc_insertion_point(field_mutable:ce.nbapi.air_monitor_rogue_info.monitor_name)
  return monitor_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* air_monitor_rogue_info::release_monitor_name() {
  // @@protoc_insertion_point(field_release:ce.nbapi.air_monitor_rogue_info.monitor_name)
  if (!has_monitor_name()) {
    return NULL;
  }
  clear_has_monitor_name();
  return monitor_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void air_monitor_rogue_info::set_allocated_monitor_name(::std::string* monitor_name) {
  if (monitor_name != NULL) {
    set_has_monitor_name();
  } else {
    clear_has_monitor_name();
  }
  monitor_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), monitor_name);
  // @@protoc_insertion_point(field_set_allocated:ce.nbapi.air_monitor_rogue_info.monitor_name)
}

// optional uint32 nat_match_type = 5;
inline bool air_monitor_rogue_info::has_nat_match_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void air_monitor_rogue_info::set_has_nat_match_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void air_monitor_rogue_info::clear_has_nat_match_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void air_monitor_rogue_info::clear_nat_match_type() {
  nat_match_type_ = 0u;
  clear_has_nat_match_type();
}
inline ::google::protobuf::uint32 air_monitor_rogue_info::nat_match_type() const {
  // @@protoc_insertion_point(field_get:ce.nbapi.air_monitor_rogue_info.nat_match_type)
  return nat_match_type_;
}
inline void air_monitor_rogue_info::set_nat_match_type(::google::protobuf::uint32 value) {
  set_has_nat_match_type();
  nat_match_type_ = value;
  // @@protoc_insertion_point(field_set:ce.nbapi.air_monitor_rogue_info.nat_match_type)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace nbapi
}  // namespace ce

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ce::nbapi::ip_address_addr_family> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::ip_address_addr_family>() {
  return ::ce::nbapi::ip_address_addr_family_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::ap_neighbor_network_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::ap_neighbor_network_type>() {
  return ::ce::nbapi::ap_neighbor_network_type_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::util_stats_util_stat_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::util_stats_util_stat_type>() {
  return ::ce::nbapi::util_stats_util_stat_type_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::location_algorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::location_algorithm>() {
  return ::ce::nbapi::location_algorithm_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::location_error_code> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::location_error_code>() {
  return ::ce::nbapi::location_error_code_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::access_point_deployment_mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::access_point_deployment_mode>() {
  return ::ce::nbapi::access_point_deployment_mode_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::radio_radio_mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::radio_radio_mode>() {
  return ::ce::nbapi::radio_radio_mode_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::visibility_rec_ip_protocol> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::visibility_rec_ip_protocol>() {
  return ::ce::nbapi::visibility_rec_ip_protocol_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::visibility_rec_IapAppEnforcementStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::visibility_rec_IapAppEnforcementStatus>() {
  return ::ce::nbapi::visibility_rec_IapAppEnforcementStatus_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::geofence_notify_zone_event> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::geofence_notify_zone_event>() {
  return ::ce::nbapi::geofence_notify_zone_event_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::stats_radio_radio_mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::stats_radio_radio_mode>() {
  return ::ce::nbapi::stats_radio_radio_mode_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::security_message_security_msg_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::security_message_security_msg_type>() {
  return ::ce::nbapi::security_message_security_msg_type_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::info_mode_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::info_mode_type>() {
  return ::ce::nbapi::info_mode_type_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::nb_event_event_operation> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::nb_event_event_operation>() {
  return ::ce::nbapi::nb_event_event_operation_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::nb_event_license_info> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::nb_event_license_info>() {
  return ::ce::nbapi::nb_event_license_info_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::url_detail_record_url_http_method> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::url_detail_record_url_http_method>() {
  return ::ce::nbapi::url_detail_record_url_http_method_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::data_prio> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::data_prio>() {
  return ::ce::nbapi::data_prio_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::traffic_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::traffic_type>() {
  return ::ce::nbapi::traffic_type_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::ht_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::ht_type>() {
  return ::ce::nbapi::ht_type_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::phy_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::phy_type>() {
  return ::ce::nbapi::phy_type_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::measurement_unit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::measurement_unit>() {
  return ::ce::nbapi::measurement_unit_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::vpn_tunnel_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::vpn_tunnel_type>() {
  return ::ce::nbapi::vpn_tunnel_type_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::target_dev_type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::target_dev_type>() {
  return ::ce::nbapi::target_dev_type_descriptor();
}
template <> struct is_proto_enum< ::ce::nbapi::iap_enforcement_status> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ce::nbapi::iap_enforcement_status>() {
  return ::ce::nbapi::iap_enforcement_status_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_schema_2eproto
